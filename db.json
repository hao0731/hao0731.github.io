{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/error-page.png","path":"img/error-page.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/butterfly-icon.png","path":"img/butterfly-icon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"source/.nojekyll","path":".nojekyll","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.nojekyll","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1741415798859},{"_id":"source/_posts/0002-nestjs-discovery-module/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1694943849440},{"_id":"source/_data/widget.yml","hash":"55611def3a587eb3a743b970f6738c641d5dd29b","modified":1694250063391},{"_id":"source/googlead8647818dbace5f.html","hash":"3bade42ea2d3e6c6b833d35be2634cd6c86f1bae","modified":1741181961490},{"_id":"source/.DS_Store","hash":"f4b2dcf3ca32e8a86a82046f2d8a16c5252d9ea2","modified":1744725727813},{"_id":"source/about/index.md","hash":"3f3efceb895267faaccaeefc363ce22e71a85af9","modified":1736604971927},{"_id":"source/robots.txt","hash":"9265774ed7fbf757c009d249cc1963c924ef5f23","modified":1741415217263},{"_id":"source/_posts/.DS_Store","hash":"6667b543b3ed7d953929a32b49f017bd0fbea99c","modified":1744725755961},{"_id":"source/_posts/0002-nestjs-discovery-module.md","hash":"e44b1f690a79dfefe5d2e96c80026ad5938bc83e","modified":1694943742596},{"_id":"source/_posts/0001-dynamic-load-web-component.md","hash":"2d458ff055e03fb3d1050f53a703288119525358","modified":1694350079398},{"_id":"source/_posts/0004-nestjs-valkey.md","hash":"e0720e82c98396a16afe371c1c657a8d615fa2e6","modified":1740306541062},{"_id":"source/_posts/0005-nestjs-pact.md","hash":"9c41b9bd29383d71c0adaf65ec4d4d20b904cba5","modified":1744120794320},{"_id":"source/_posts/0003-what-is-krakend.md","hash":"3189f2a8712343920f6b192ea781b845c6b51718","modified":1736595613352},{"_id":"source/_posts/0006-nestjs-pact-broker.md","hash":"802cf76b37862303fa96e5afcba6cdc56548b169","modified":1745156551868},{"_id":"source/tags/index.md","hash":"813bee740cbc590b61deecc3480aefba4d8e0c7e","modified":1694251324021},{"_id":"source/images/.DS_Store","hash":"8b3ade9678b63309bd9ad380fe7f99cd44cc4806","modified":1694352530860},{"_id":"source/categories/index.md","hash":"77c911213b73839337448719f907b97118081950","modified":1694251317517},{"_id":"source/_posts/0001-dynamic-load-web-component/web-component-dynamic-loader.png","hash":"e6661b14f68c0d4b2ae56a1d0a05666c48afe905","modified":1694348898625},{"_id":"source/_posts/0004-nestjs-valkey/valkey-logo.png","hash":"b50a32dfd492757d79d3b5918f03cbf5a76ba70b","modified":1740293787503},{"_id":"source/_posts/0005-nestjs-pact/pact-logo.png","hash":"be380d7472c90879620a0c1cc09e2de91a033b28","modified":1741425754847},{"_id":"source/_posts/0005-nestjs-pact/contract-testing-concept.png","hash":"b540d8840bae8ef2dfb18494d2cb5cdf246aac3e","modified":1741425754843},{"_id":"source/_posts/0001-dynamic-load-web-component/web-component-for-framework.png","hash":"fac7da0536d5b76a5b4d96d8094fe5aa06850ede","modified":1694347396606},{"_id":"source/_posts/0003-what-is-krakend/krakend-flow.png","hash":"6828280421f114b94faa3043e7489e69fee58184","modified":1736152807140},{"_id":"source/_posts/0004-nestjs-valkey/serve-valkey-cli.png","hash":"d62bb391dfa5986c690b5deca173d55e00a4d88d","modified":1740295807921},{"_id":"source/_posts/0004-nestjs-valkey/valkey-get-expired-value.png","hash":"3ae9f1488a1c6c3c68faa420493345ea06a1b524","modified":1740297458631},{"_id":"source/_posts/0004-nestjs-valkey/valkey-get-command.png","hash":"725a14f7ce3c12dc39b5288a06d003267fbc9f85","modified":1740297422415},{"_id":"source/_posts/0004-nestjs-valkey/valkey-set-command.png","hash":"81469026a479fabae90c6c20829e9aaba9db0529","modified":1740297382759},{"_id":"source/_posts/0005-nestjs-pact/generated-contract.png","hash":"cf5ff48e85ef7281df495a6aabf6c2cc4f89d607","modified":1741425754844},{"_id":"source/_posts/0003-what-is-krakend/health-check-result.png","hash":"7d2ebc70f2cd7cb3faaa866654b6b4920c007cb1","modified":1736157005219},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-broker-ui-matrix-entry.png","hash":"43d9d94aa792f8c49c6cfae587336e680ab0bce8","modified":1744809377452},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-broker-ui.png","hash":"fce61b45224ccea52f6e7fe7edf38d734274208d","modified":1744725624438},{"_id":"source/_posts/0005-nestjs-pact/consumer-class-diagram.png","hash":"a3b5782742af72c814fcb60c87e6ce31aac2ca4a","modified":1741425754838},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-cli-publish-result.png","hash":"8c869ffd05966ee2cbc9021b112ba44ad30b43b1","modified":1745156128986},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-verification-result1.png","hash":"49904132472dfdc1a675c3927813da86be25e450","modified":1745156747747},{"_id":"source/_posts/0005-nestjs-pact/provider-class-diagram.png","hash":"d603d034b6c7ffe720b3cd12bfd7d477c67b1fbe","modified":1741425754848},{"_id":"source/_posts/0003-what-is-krakend/krakend-result.png","hash":"2dddae207c7327a117227a7c6324c4825d1029d9","modified":1736586522649},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-broker-ui-matrix-all-result1.png","hash":"bf02c311a23cd9a8f0f57c749f998a67f8da3431","modified":1744810231241},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-cli-help.png","hash":"b2dc45f0a4345d77d18c444e75f337658c1ece52","modified":1745152488108},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-verification-result2.png","hash":"9e8a7eb49b1e52e9649bd125ffa89e0dbebb6a0e","modified":1745156895046},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-broker-ui-matrix.png","hash":"37b9978f18d6760bc93302c508e81c485e72a899","modified":1744809917298},{"_id":"source/_posts/0003-what-is-krakend/krakend-help.png","hash":"bdd901690a5a9cc21c960fadfde27c431d3403fa","modified":1736343634645},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-broker-ui-matrix-all-result2.png","hash":"d6888b351e94bba2ac5cb686e9e00f2438cdfaf7","modified":1744810386240},{"_id":"source/_posts/0005-nestjs-pact/provider-test-result.png","hash":"8bd9647d8d2a595d79ad229501af871e0982f267","modified":1741425754851},{"_id":"source/_posts/0005-nestjs-pact/pact-flow-concept.png","hash":"4965fda29a963932ea59ae0ebca4e4867874f6a9","modified":1741425754847},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"0f469650107841dc1dc716aa94b3ca2bb0721762","modified":1744119776096},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"e1b9096ae0c4e5ef0a911aec05dbad4a3aae3173","modified":1744119776103},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1744119775307},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"92e45255b8725f0a00450c88fcfd51ec61e1db67","modified":1744119776099},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"7166aff350fcf84cbc01835fad5731eb855cecd7","modified":1744119776497},{"_id":"node_modules/hexo-theme-butterfly/plugins.yml","hash":"a2704f0406484fdae3410e9992cf996f9859356e","modified":1744119776511},{"_id":"node_modules/hexo-theme-butterfly/languages/ja.yml","hash":"a281d3cc3e117e90597b783dc5569dba3976d2eb","modified":1744119776509},{"_id":"node_modules/hexo-theme-butterfly/.github/FUNDING.yml","hash":"da5e77f5e0cdb7e11b36546fb6796d10e3dfbe5d","modified":1744119776508},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"a2c938b1ef69195aec10c90dc7d1871953548e01","modified":1744119776501},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"a2c938b1ef69195aec10c90dc7d1871953548e01","modified":1744119776503},{"_id":"node_modules/hexo-theme-butterfly/languages/ko.yml","hash":"c7d861c58f204f47a5b4d6e118e1f1e8fb8a852f","modified":1744119776510},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"e0bf36edf18cf3380b900be7528b536252990c26","modified":1744119776514},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"bd7ee35aa30964493d2729ef105bb86331b096c3","modified":1744119776515},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1744119776242},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-HK.yml","hash":"bac3063ad2892be232f7d91361c28585a3cc7eb5","modified":1744119776515},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"a7e9805a781e34e38d27462e6ce2a5821c34bb9f","modified":1744119776285},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"a93004cc8ec8050df603d32a6e6e02cd96fd9875","modified":1744119776346},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"7ce2a49c6c41847de4ccea377ade116339984434","modified":1744119776359},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"ca5333bd262cb58c195c844b593a0eed0c721766","modified":1744119776395},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"10ce05c8dbde09f53bdabe40b5388de9ccc71a31","modified":1744119776499},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"65c4a49c65c3fc4d9dc88b9791a75710c698c3a1","modified":1744119776370},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1744119776499},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"f9b02aac0dbbb2b71c037dd215e70c8b7ec7741c","modified":1744119776205},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1744119776505},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1744119776512},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"6bd41add3a45e55d5e51eab5285a2d1a909d37f3","modified":1744119776318},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1744119776512},{"_id":"node_modules/hexo-theme-butterfly/scripts/common/postDesc.js","hash":"272613a71d16f0de6dac883be4839259f774be76","modified":1744119776046},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"e5e6c05a621483b3542f2884e8ba45e84b1e973a","modified":1744119776349},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"1d11e334b22dbbedcb0f751f9ee9789d4416605e","modified":1744119776326},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"039fc75f363d79669b0b2177d929cdff6f2ef7a4","modified":1744119775731},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"43f951b639038f3bc01deea03368d8dcf492cbb0","modified":1744119776385},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1744119775912},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"bd45e6fa935ace9cb54499b0491dacfb78ccc354","modified":1744119776361},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/comment.js","hash":"7b1b16e1e8e08245a345764616956be50487eb53","modified":1744119775886},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1744119775878},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"3e65b7bf6bccccbba7e15349f0a44f15c64c5b5e","modified":1744119776389},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/merge_config.js","hash":"10ffed853a935498f1f5da2c5b57200c957874a7","modified":1744119775995},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"b23108d29fff3e32384d8689c8bcd2ab306a1ae7","modified":1744119776025},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1744119776095},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"20a6ebf63439501a4b3fc81e7a2a2ea5d103bace","modified":1744119776051},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"bac639c404588ea62e601ef0bcd368c3bd0119af","modified":1744119776065},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/getArchiveLength.js","hash":"bf77635e920eaf52bceebc95f87c7c87a7ca8038","modified":1744119775902},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"3eb0bbb1288dc7b0ff82cc46ceb53bd666893416","modified":1744119775795},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"0cdf781a8c14d7b50d309e69f282ec7b178804bb","modified":1744119775823},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"00c5742ad1c75b3c5684d02ffc6a1921399e5376","modified":1744119775916},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"a07b586b510aa2df953102d998e84207acc34f9b","modified":1744119776006},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"2f44e1b3ccd170b256eae178299d6fa933a8d490","modified":1744119775870},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/series.js","hash":"45367c4ce827329867dbcc750ec125da9ccb2cfd","modified":1744119776060},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"950b7d0966429bf0f9e6c5e1161e50e545e320b4","modified":1744119776056},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/chartjs.js","hash":"195ba802d7e8406c155124a9c939a2318f82938b","modified":1744119775884},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"25eefe10189caf3910a0e5d5b2f2043ae9255531","modified":1744119775890},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"f02fb085a88a2c0c82aeffacc24e1b71c74bd7c0","modified":1744119775910},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"fa3d0a64f7fce4aff7928d4ddd95548978ba001c","modified":1744119775893},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"50d8d8fac5c5b6e26317028895d7d82a2cf46606","modified":1744119775998},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"cf0bc17d0180231167cc6aa8a00fc64f198cb9f9","modified":1744119775922},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1744119775999},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/score.js","hash":"f589fb6646bd17cf12d77a9b251dd614e1c8b899","modified":1744119776057},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/series.js","hash":"40bc9a065e3a1423e0e66f4911e00713ca9f5e9e","modified":1744119776062},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"176804f07567aa80f1ed95897a968a996b155dec","modified":1744119776072},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"3c486b149e28edd1a06843f05a5c355000991b82","modified":1744119776067},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"89c6c78d2db43b190055d5690741a79bab4f3e7e","modified":1744119775920},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1744119776477},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"d1eec577074ab7b262182885576135bf1896e12c","modified":1744119776495},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1744119775712},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1744119775696},{"_id":"node_modules/hexo-theme-butterfly/source/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1744119776181},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1744119775684},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"5a52047b8520f79864d5a4ee2379a29751aead23","modified":1744119775970},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"e792a435afee1f9491095084a00dc77e3522c1fd","modified":1744119776226},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"fdb5482d04a75bd79946ad1ed291d281d0e9362d","modified":1744119776087},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"48637ad8e405306772b93837f33400bde1055819","modified":1744119776091},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"9ea75b06f19bf356f340f4a3fc1bdc0713cfe445","modified":1744119776297},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"56a3c32de1a15627ff38c67f1131cdd6ec5ac924","modified":1744119776296},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"e93a36d3c29b5a02c7f26a23f96e1f84b063cbe8","modified":1744119776356},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1744119776325},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"1e1a69aa2cbda2e621c741b3802093244b3cc04e","modified":1744119776377},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"83ed05ef1e39f2ee70c3fba2cf96e488d8ffec66","modified":1744119776377},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"733184f88e3a586a5fcc9d193ad500556b6c8eed","modified":1744119776354},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"18b984ce184ea53d2dff5a03cc2d0d39d2ec3406","modified":1744119776355},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/structured_data.pug","hash":"1b83ae33961528f128596753fd05067c672d6bff","modified":1744119776391},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1744119776390},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"44331c9db74b281b5c5c41439d3407a9076df1a1","modified":1744119776330},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"e2d31e0f450ad42c47f7ee96375799342bf2f19b","modified":1744119776391},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"d76ce71ba106e350670c021a3dcae57547d01830","modified":1744119776331},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"7d799c4694adb6e265e3f4b975d7f7f6a7021a17","modified":1744119776366},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"a2f7d69ca7ec58f24fe7d4e04ae21d5b62b01567","modified":1744119776322},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"ef7afe0df7a3746744ac8185da7163b7406120ca","modified":1744119776254},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"9d2d539555bab495959b9df734ed5c43a9f9e5a9","modified":1744119776359},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/indexPostUI.pug","hash":"f3389fa9ae4fa32e3c16573286583bc3023e57ad","modified":1744119776347},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"efb40388e37cca0b5e7c3c66e811a42f8d32c910","modified":1744119776300},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"6b0fa5f048aca8e9cbe56978301af918cf7ac34a","modified":1744119776317},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/404.pug","hash":"15d32c511e4875066fcbe9cb84c3ada07b5a7c41","modified":1744119776189},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1744119776282},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/outdate-notice.pug","hash":"b7ce9484bc5c97ea6154f0b78fb9b8951fafedbd","modified":1744119776358},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"79ad31eb72a9e14007770b18a426406a25315b38","modified":1744119776396},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/shuoshuo.pug","hash":"b2423cfc57a5e3a0e1112ff7c18d5c5c720d89d5","modified":1744119776388},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"b96c232e5178d927987791d9ae386dd83679535a","modified":1744119776365},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"efe4f8019632b51c92c4f7628758538305e06e47","modified":1744119776364},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"ed79fef5b5025415ea12eaed970f3fe7f6ef9596","modified":1744119776238},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1744119776314},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"db92f25ff3fd061882f81bf74ca560ff66983a0c","modified":1744119776383},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"88f979a0b1a19eeb0db229247833bf9c6865c3b9","modified":1744119776375},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"236c3ce26dd76e80b04d457789475c42da5ac0c8","modified":1744119776393},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/umami_analytics.pug","hash":"bc35a1552d26ecdeeadbf06300078dbb5128a6e5","modified":1744119776402},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1744119776256},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1744119776261},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1744119776263},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1744119776265},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"1aba8aa7cd767dc96879d13a13b4c8ceb9023233","modified":1744119776264},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"d8753772889b5d0f4d15639ed6af5e91e53b1d03","modified":1744119776271},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1744119776266},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1744119776272},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1744119776275},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"1dd19a564320d248dbcee7f118a5b96c6466da65","modified":1744119776273},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1744119776277},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"fcddd80cdeb6aa81f342cd9f0102302f6ba087a8","modified":1744119776279},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"45f620cd87b9ef2aa9d1e024e697ed6b4eecff34","modified":1744119776344},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"a51edfd3e499e7d38c32241c40e8e4d371efca73","modified":1744119776494},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1744119776278},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"67062d597408068e4a59e95851e98fed34b745da","modified":1744119776466},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"4fcb8222b9548e22f7b76f12d33e3698240cbae0","modified":1744119776470},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"4cc02bcbaa4a1933a82a9ea57a603fe2d059fc77","modified":1744119776431},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"d7b988d8588207086670f39aa49fce442c429f7a","modified":1744119776452},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"d12340a7df4601b9a23f070e16645861aeb3bb0a","modified":1744119776456},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1744119776482},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"ba174889e770ae9f6683379b9eae9d8c94253080","modified":1744119776424},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1744119776432},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"094108f2a4e351a2fa496d6bd3e2388151416b3f","modified":1744119776459},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"ef8e8549fe7ad4b99793844a93b4a89f77f417d5","modified":1744119776487},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"7d7554573c005399bc8c2264a85896d2d51be1e1","modified":1744119776484},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"543eaf9c7df7e0db841e5946ee5f9082c3c46290","modified":1744119776486},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"d9cdf564a822a585e67fd5bac8573ba87eeb3743","modified":1744119776487},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"a0f5835f04358122e8b1d38dd3e8da09a1b5b431","modified":1744119776488},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"084dc4dfb41f55e237a9d6cf8c2f5dba729b83be","modified":1744119776490},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"0af7c8754f04bdd9a02a14d880774753bd2e35ee","modified":1744119776494},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"4c9849df9c68d892c7df0ca28123aeb0dc9dc424","modified":1744119776438},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"5abe5480d83ff8b452a780a484d50a44091475bf","modified":1744119776419},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"ad66212554468b7067590308ed4cf40524fea662","modified":1744119776487},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"205ccc7d0ec6ce1193b46bc0c9ce0385594581fb","modified":1744119776414},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"c4cda7b0c99015df29ce00fdfddd2f7679653754","modified":1744119776430},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"1f8d715faf3b91b53426e38195c0920afb3bfa1c","modified":1744119776451},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"992d192db7d1c96e995b85ed11c20c571d33fbad","modified":1744119776469},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"dcff804c4c237e1e908481b44c1ac4e39ac0da34","modified":1744119776433},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/shuoshuo.styl","hash":"79bb1d9a27822ed5675d1e52f5dbd0e2f5d5010a","modified":1744119776489},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"d8a8275a68a1421c4c09b604cf78bea16c1d0463","modified":1744119776417},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"7543bb688876a946538d66b991c71b94b5216277","modified":1744119776493},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"1f2b86df86df81c3a59377b29102314ffc73dfa6","modified":1744119776482},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"de8437a058a315d14d7e7034066f095b7b3ed4b4","modified":1744119776429},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"6c4cbdadd9a49029fe0c59e29808d873e5b6b6ee","modified":1744119776474},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"30d1f809efd252ed0233d96d4374efd2b01d2292","modified":1744119776457},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1744119776460},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"3be8d0a75e7cc96548667cae0cb6a474279bd0b5","modified":1744119776478},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"216f52fefc2274b542b549d8470503e6f1a308fb","modified":1744119776480},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/series.styl","hash":"0657169849bc4bf4d93b5492ade040c8f58c1901","modified":1744119776489},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"4929382bd60788d34752a66e2fe764ef797a72a0","modified":1744119776484},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"e846ddaef494d46cdfa2379deacfe74fa1cc5264","modified":1744119776494},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"d27dbccaf3de1c9158d19e4fd49a25953cb5778d","modified":1744119776460},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"3a88eedcb694da79e92581ce50cb1a430b1fb615","modified":1744119776492},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1744119775442},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"a2b783230a9143de69004cfc914d9f55e6fc1660","modified":1744119775941},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"febff991595504d8e850ced0b9cc090f02ed97f0","modified":1744119776199},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f0a90d8e39915a74b16ef22e851f179415cd7eaa","modified":1744119776333},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1744119776306},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"7119f2f2943de71999d3dd6ba5c60cde846f114b","modified":1744119775772},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1744119776337},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"cbfbcf34a24d21ba2b21cf9eedb76f4c3c563c5a","modified":1744119776316},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1744119776379},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1744119776243},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"b5db4203a1392385838c73549ddeae0a4be67eba","modified":1744119776399},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"7884883ec15792f7e54daacb3c62b851dde2b66a","modified":1744119776404},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"5b29badecbbe828112c001156023fc0566045cf6","modified":1744119776293},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1744119776408},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"24d094fd917947c0ca7492fa094328b1a183b873","modified":1744119776298},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"89c63a5f0c0ab6314de7158fbc8fcbc84997fc55","modified":1744119776245},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"62466b251052cae609b6369d4cb4b6a85320757d","modified":1744119776397},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"e8438941085def0591a72fc9b0d705dbf107f54f","modified":1744119776337},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"592b2251db6c1abeb8b0eebe3b2e6d9aa0dec445","modified":1744119776323},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f2ea5249b3e6670f6c8c77868f4f42c502e43830","modified":1744119776312},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"c81fa7d8a5cb96d1ae07bfa8c46b84a58161add1","modified":1744119776313},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"8af585e6d6f73ee57114eefad574dc6e8ea9f570","modified":1744119776315},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"58914c58a190e3bc0aa37cb581e77e442b563501","modified":1744119776324},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"db6713d2b90eb8183f86ac92c26761a8501c0ddb","modified":1744119776338},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"7a80231fc71822e503879383a2d9611edf1d72dd","modified":1744119776352},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1744119776348},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"84f7cfde00f929fa3dc40349bcab060ec68f1b9f","modified":1744119776380},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"53d99831f29aeb2e336ed1407d79590041f77002","modified":1744119776400},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"30a7d157890de69deab28baa47fb7bb28b040efd","modified":1744119776404},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"e2bf15357485cd502414b3b20f5b1f762a2fd014","modified":1744119776408},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/chartjs.pug","hash":"732eb1118ea1a73aa5c164d639097c614f8e9953","modified":1744119776291},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"b83db9fa64d42a0bfd97efb660e09be3f166a144","modified":1744119776349},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"ca2fc5928ca292f29fd8333c73733344994096fb","modified":1744119776355},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"db2f4fff80a1166476ea76ae004aa186df11bad3","modified":1744119776354},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"24f18b0c67803210d53abbf9c1d454c000b06eee","modified":1744119776405},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"af66d13204030d47537b9e31a6173e63589ce7ff","modified":1744119776338},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/common.pug","hash":"27fa75affebc6e84a487c62bceff783bde595256","modified":1744119776295},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"fa4b4194749d05f7249f365f2b89c0281057ce54","modified":1744119776306},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"72e2970b23570e308f8af5d8ba8e5e3321d01bbf","modified":1744119776324},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"187302dbc916852ff2fdf47061e272c061611dda","modified":1744119776249},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"a7c07dbc1e970a5b247091458e1ee9b144a3366d","modified":1744119776339},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"d2e12a9fc302a4efe52c90d44896fbd73e193a1f","modified":1744119776398},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"34edfebf0cace0852806be774910ccb0e0914650","modified":1744119776382},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d376ec17fb19fcdcf0d2ad71330190146d3af879","modified":1744119776407},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ec6c685080634ac46ffbea1b8f10313388888f43","modified":1744119776409},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"2622b4cf9189fa23e4a422aaf9ef272e4f2c6137","modified":1744119776354},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"f5ee1c9c8ffa4bca972d30f4de69268b8d47f052","modified":1744119776213},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"7f0ede1cd3fed2669c94a8e1b21bc0b183f310b8","modified":1744119776219},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"e51e896ccb13900de38dc81cf44dc789e2418a12","modified":1744119776343},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"efef352c1d122409575386bf3894dce8e87032e2","modified":1744119776387},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/docsearch.pug","hash":"013756ff3363344987cc00fc9bd833baf193c341","modified":1744119776313},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"f8557548d2ad8dd149c562193991c6c6cda02415","modified":1744119776341},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"de4bb5fc2dfca368b35e4c1109c92f7abc9e2245","modified":1744119776480},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"ef52ebf1e8e751a412f9456fdaeee7d88afd9a72","modified":1744119776471},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"1883c91d43bff10aae55122a21e0b064b6f5c9dd","modified":1744119776472},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"9f02598b5e4296aec6470639d4bac4c9ac46392e","modified":1744119776442},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"077ec530831be1d80e93da380406b9f5abd0918a","modified":1744119776450},{"_id":"source/_posts/0005-nestjs-pact/consumer-test-result.png","hash":"ef3ffc325a80823e3c322553bb9123c414a5de45","modified":1741425754842},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-cli-publish.png","hash":"43e5cd1f2f0f1431a1fd4f8040ad8121d7ad2a26","modified":1745155884174},{"_id":"node_modules/hexo-theme-butterfly/source/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1744119776165},{"_id":"source/images/avatar.png","hash":"0a474567541b578b72da028a732afeefc170897b","modified":1694352514017}],"Category":[{"name":"Backend","_id":"cm9tztuvn0007fqgx7lfvgylc"},{"name":"Frontend","_id":"cm9tztuvq000bfqgxgi510df9"},{"name":"NestJS","parent":"cm9tztuvn0007fqgx7lfvgylc","_id":"cm9tztuvt000gfqgx5bu87vsr"},{"name":"Web Component","parent":"cm9tztuvq000bfqgxgi510df9","_id":"cm9tztuvu000kfqgx5ur81yen"},{"name":"KrakenD","parent":"cm9tztuvn0007fqgx7lfvgylc","_id":"cm9tztuvv000qfqgxc2g8de9c"},{"name":"Advanced","parent":"cm9tztuvt000gfqgx5bu87vsr","_id":"cm9tztuvw000tfqgx86dg3x6e"},{"name":"Contract Testing","parent":"cm9tztuvt000gfqgx5bu87vsr","_id":"cm9tztuw1001ffqgxgxxi3wrs"}],"Data":[{"_id":"widget","data":{"bottom":[{"name":"推薦 Blog","icon":"fas fa-blog","html":"<div><a href=\"https://hcluo.blogspot.com/\" target=\"_blank\">hcLuo Blog</a></div><div><a href=\"https://blog.leochen.dev/\" target=\"_blank\">Leo's Coding Life</a></div>"}]}}],"Page":[{"layout":"false","_content":"\ngoogle-site-verification: googlead8647818dbace5f.html","source":"googlead8647818dbace5f.html","raw":"---\nlayout: false\n---\n\ngoogle-site-verification: googlead8647818dbace5f.html","date":"2025-03-05T13:39:21.490Z","updated":"2025-03-05T13:39:21.490Z","path":"googlead8647818dbace5f.html","title":"","comments":1,"_id":"cm9tztuva0000fqgx69q4g0pb","content":"\ngoogle-site-verification: googlead8647818dbace5f.html","excerpt":"","more":"\ngoogle-site-verification: googlead8647818dbace5f.html"},{"title":"關於我","date":"2023-09-09T08:19:22.000Z","_content":"\n<div style=\"display: flex; flex-direction: column; justify-content: center; align-items: center;\">\n  <div>\n    <img\n      src=\"/images/avatar.png\"\n      style=\"border-radius: 87.5px; max-width: 175px;\"\n    />\n  </div>\n  <div>我是 HAO，目前任職於台灣積體電路製造股份有限公司，擔任 Senior IT Engineer。</div>\n</div>\n\n## 工作經歷\n**Full Time**\n*  **TSMC IT Engineer** - 2022/07 ~\n    -  **Senior TSMC IT Engineer** - 2024/07 ~\n    -  **TSMC IT Engineer** - 2022/07 ~ 2024/06\n*  **Vertiv Taiwan Software Engineer** - 2021/02 ~ 2022/06\n*  **Perkd Taiwan Full-Stack Developer** - 2020/07 ~ 2021/02\n*  **Perkd Taiwan Front-End Intern** - 2019/07 ~ 2019/12\n\n**Special**\n*  **HiSKIO Lecturer** - 2021/10 ~2022/10\n\n## 專業技能\n\n**Front-End**\n1. HTML5 / CSS3 / JavaScript / TypeScript\n2. Angular / React Hook / jQuery\n3. Angular Material / BootStrap\n4. Webpack\n\n**Back-End**\n1. Node.js\n2. Express / NestJS\n3. MongoDB / mongoose\n4. AWS Lambda + API Gateway\n\n**Tools**\n1. Nx\n2. Docker\n\n**BlockChain**\n1. Smart Contract / Solidity\n2. Go-ethereum\n3. Truffle\n4. Ganache\n5. web3.js / ethjs\n\n## 成就\n\n* 【2016】[第 56 屆全國中小學科學展覽會電腦與資訊學科](https://twsf.ntsec.gov.tw/activity/race-1/56/pdf/052508.pdf) - **佳作**\n* 【2018】[2018 Ai 機器人自造黑客松 - 南台灣挑戰賽](https://www.nkust.edu.tw/p/406-1000-8840,r12.php) - **總冠軍**\n* 【2018】[U-start 創新創業計畫 - 製造業組](https://ustart.yda.gov.tw/p/405-1000-1359,c112.php?Lang=zh-tw) - **績優團隊**\n* 【2019】[第 11 屆 iT 邦幫忙鐵人賽 - Blockchain](https://ithelp.ithome.com.tw/users/20119338/ironman/2150) - **佳作**\n* 【2020】[第 12 屆 iT 邦幫忙鐵人賽 - Software Development](https://ithelp.ithome.com.tw/users/20119338/ironman/3008) - **佳作**\n* 【2021】[第 13 屆 iT 邦幫忙鐵人賽 - Modern Web](https://ithelp.ithome.com.tw/users/20119338/ironman/3880) - **佳作**\n* 【2022】[著作 - NestJS 基礎必學實務指南：使用強大且易擴展的 Node.js 框架打造網頁應用程式](https://www.tenlong.com.tw/products/9786263332935)\n* 【2024】[第 16 屆 iT 邦幫忙鐵人賽 - Software Development](https://ithelp.ithome.com.tw/users/20119338/ironman/7743) - **優選**\n\n## 演講\n\n* 【2024】[TSMC IT Meetup - 擁抱 Angular Signal](https://tsmcitcommunitymeetup.kktix.cc/events/tsmc-it-meetup-taipei-02)\n* 【2024】[Hello World Dev Conference - NestJS 與 gRPC：快速上手指南](https://hwdc.ithome.com.tw/2024/session-page/3226)","source":"about/index.md","raw":"---\ntitle: 關於我\ndate: 2023-09-09 16:19:22\n---\n\n<div style=\"display: flex; flex-direction: column; justify-content: center; align-items: center;\">\n  <div>\n    <img\n      src=\"/images/avatar.png\"\n      style=\"border-radius: 87.5px; max-width: 175px;\"\n    />\n  </div>\n  <div>我是 HAO，目前任職於台灣積體電路製造股份有限公司，擔任 Senior IT Engineer。</div>\n</div>\n\n## 工作經歷\n**Full Time**\n*  **TSMC IT Engineer** - 2022/07 ~\n    -  **Senior TSMC IT Engineer** - 2024/07 ~\n    -  **TSMC IT Engineer** - 2022/07 ~ 2024/06\n*  **Vertiv Taiwan Software Engineer** - 2021/02 ~ 2022/06\n*  **Perkd Taiwan Full-Stack Developer** - 2020/07 ~ 2021/02\n*  **Perkd Taiwan Front-End Intern** - 2019/07 ~ 2019/12\n\n**Special**\n*  **HiSKIO Lecturer** - 2021/10 ~2022/10\n\n## 專業技能\n\n**Front-End**\n1. HTML5 / CSS3 / JavaScript / TypeScript\n2. Angular / React Hook / jQuery\n3. Angular Material / BootStrap\n4. Webpack\n\n**Back-End**\n1. Node.js\n2. Express / NestJS\n3. MongoDB / mongoose\n4. AWS Lambda + API Gateway\n\n**Tools**\n1. Nx\n2. Docker\n\n**BlockChain**\n1. Smart Contract / Solidity\n2. Go-ethereum\n3. Truffle\n4. Ganache\n5. web3.js / ethjs\n\n## 成就\n\n* 【2016】[第 56 屆全國中小學科學展覽會電腦與資訊學科](https://twsf.ntsec.gov.tw/activity/race-1/56/pdf/052508.pdf) - **佳作**\n* 【2018】[2018 Ai 機器人自造黑客松 - 南台灣挑戰賽](https://www.nkust.edu.tw/p/406-1000-8840,r12.php) - **總冠軍**\n* 【2018】[U-start 創新創業計畫 - 製造業組](https://ustart.yda.gov.tw/p/405-1000-1359,c112.php?Lang=zh-tw) - **績優團隊**\n* 【2019】[第 11 屆 iT 邦幫忙鐵人賽 - Blockchain](https://ithelp.ithome.com.tw/users/20119338/ironman/2150) - **佳作**\n* 【2020】[第 12 屆 iT 邦幫忙鐵人賽 - Software Development](https://ithelp.ithome.com.tw/users/20119338/ironman/3008) - **佳作**\n* 【2021】[第 13 屆 iT 邦幫忙鐵人賽 - Modern Web](https://ithelp.ithome.com.tw/users/20119338/ironman/3880) - **佳作**\n* 【2022】[著作 - NestJS 基礎必學實務指南：使用強大且易擴展的 Node.js 框架打造網頁應用程式](https://www.tenlong.com.tw/products/9786263332935)\n* 【2024】[第 16 屆 iT 邦幫忙鐵人賽 - Software Development](https://ithelp.ithome.com.tw/users/20119338/ironman/7743) - **優選**\n\n## 演講\n\n* 【2024】[TSMC IT Meetup - 擁抱 Angular Signal](https://tsmcitcommunitymeetup.kktix.cc/events/tsmc-it-meetup-taipei-02)\n* 【2024】[Hello World Dev Conference - NestJS 與 gRPC：快速上手指南](https://hwdc.ithome.com.tw/2024/session-page/3226)","updated":"2025-01-11T14:16:11.927Z","path":"about/index.html","comments":1,"layout":"page","_id":"cm9tztuvj0002fqgxfcfn2ccw","content":"<div style=\"display: flex; flex-direction: column; justify-content: center; align-items: center;\">\n  <div>\n    <img\n      src=\"/images/avatar.png\"\n      style=\"border-radius: 87.5px; max-width: 175px;\"\n    />\n  </div>\n  <div>我是 HAO，目前任職於台灣積體電路製造股份有限公司，擔任 Senior IT Engineer。</div>\n</div>\n\n<h2 id=\"工作經歷\"><a href=\"#工作經歷\" class=\"headerlink\" title=\"工作經歷\"></a>工作經歷</h2><p><strong>Full Time</strong></p>\n<ul>\n<li><strong>TSMC IT Engineer</strong> - 2022&#x2F;07 ~<ul>\n<li><strong>Senior TSMC IT Engineer</strong> - 2024&#x2F;07 ~</li>\n<li><strong>TSMC IT Engineer</strong> - 2022&#x2F;07 ~ 2024&#x2F;06</li>\n</ul>\n</li>\n<li><strong>Vertiv Taiwan Software Engineer</strong> - 2021&#x2F;02 ~ 2022&#x2F;06</li>\n<li><strong>Perkd Taiwan Full-Stack Developer</strong> - 2020&#x2F;07 ~ 2021&#x2F;02</li>\n<li><strong>Perkd Taiwan Front-End Intern</strong> - 2019&#x2F;07 ~ 2019&#x2F;12</li>\n</ul>\n<p><strong>Special</strong></p>\n<ul>\n<li><strong>HiSKIO Lecturer</strong> - 2021&#x2F;10 ~2022&#x2F;10</li>\n</ul>\n<h2 id=\"專業技能\"><a href=\"#專業技能\" class=\"headerlink\" title=\"專業技能\"></a>專業技能</h2><p><strong>Front-End</strong></p>\n<ol>\n<li>HTML5 &#x2F; CSS3 &#x2F; JavaScript &#x2F; TypeScript</li>\n<li>Angular &#x2F; React Hook &#x2F; jQuery</li>\n<li>Angular Material &#x2F; BootStrap</li>\n<li>Webpack</li>\n</ol>\n<p><strong>Back-End</strong></p>\n<ol>\n<li>Node.js</li>\n<li>Express &#x2F; NestJS</li>\n<li>MongoDB &#x2F; mongoose</li>\n<li>AWS Lambda + API Gateway</li>\n</ol>\n<p><strong>Tools</strong></p>\n<ol>\n<li>Nx</li>\n<li>Docker</li>\n</ol>\n<p><strong>BlockChain</strong></p>\n<ol>\n<li>Smart Contract &#x2F; Solidity</li>\n<li>Go-ethereum</li>\n<li>Truffle</li>\n<li>Ganache</li>\n<li>web3.js &#x2F; ethjs</li>\n</ol>\n<h2 id=\"成就\"><a href=\"#成就\" class=\"headerlink\" title=\"成就\"></a>成就</h2><ul>\n<li>【2016】<a href=\"https://twsf.ntsec.gov.tw/activity/race-1/56/pdf/052508.pdf\">第 56 屆全國中小學科學展覽會電腦與資訊學科</a> - <strong>佳作</strong></li>\n<li>【2018】<a href=\"https://www.nkust.edu.tw/p/406-1000-8840,r12.php\">2018 Ai 機器人自造黑客松 - 南台灣挑戰賽</a> - <strong>總冠軍</strong></li>\n<li>【2018】<a href=\"https://ustart.yda.gov.tw/p/405-1000-1359,c112.php?Lang=zh-tw\">U-start 創新創業計畫 - 製造業組</a> - <strong>績優團隊</strong></li>\n<li>【2019】<a href=\"https://ithelp.ithome.com.tw/users/20119338/ironman/2150\">第 11 屆 iT 邦幫忙鐵人賽 - Blockchain</a> - <strong>佳作</strong></li>\n<li>【2020】<a href=\"https://ithelp.ithome.com.tw/users/20119338/ironman/3008\">第 12 屆 iT 邦幫忙鐵人賽 - Software Development</a> - <strong>佳作</strong></li>\n<li>【2021】<a href=\"https://ithelp.ithome.com.tw/users/20119338/ironman/3880\">第 13 屆 iT 邦幫忙鐵人賽 - Modern Web</a> - <strong>佳作</strong></li>\n<li>【2022】<a href=\"https://www.tenlong.com.tw/products/9786263332935\">著作 - NestJS 基礎必學實務指南：使用強大且易擴展的 Node.js 框架打造網頁應用程式</a></li>\n<li>【2024】<a href=\"https://ithelp.ithome.com.tw/users/20119338/ironman/7743\">第 16 屆 iT 邦幫忙鐵人賽 - Software Development</a> - <strong>優選</strong></li>\n</ul>\n<h2 id=\"演講\"><a href=\"#演講\" class=\"headerlink\" title=\"演講\"></a>演講</h2><ul>\n<li>【2024】<a href=\"https://tsmcitcommunitymeetup.kktix.cc/events/tsmc-it-meetup-taipei-02\">TSMC IT Meetup - 擁抱 Angular Signal</a></li>\n<li>【2024】<a href=\"https://hwdc.ithome.com.tw/2024/session-page/3226\">Hello World Dev Conference - NestJS 與 gRPC：快速上手指南</a></li>\n</ul>\n","excerpt":"","more":"<div style=\"display: flex; flex-direction: column; justify-content: center; align-items: center;\">\n  <div>\n    <img\n      src=\"/images/avatar.png\"\n      style=\"border-radius: 87.5px; max-width: 175px;\"\n    />\n  </div>\n  <div>我是 HAO，目前任職於台灣積體電路製造股份有限公司，擔任 Senior IT Engineer。</div>\n</div>\n\n<h2 id=\"工作經歷\"><a href=\"#工作經歷\" class=\"headerlink\" title=\"工作經歷\"></a>工作經歷</h2><p><strong>Full Time</strong></p>\n<ul>\n<li><strong>TSMC IT Engineer</strong> - 2022&#x2F;07 ~<ul>\n<li><strong>Senior TSMC IT Engineer</strong> - 2024&#x2F;07 ~</li>\n<li><strong>TSMC IT Engineer</strong> - 2022&#x2F;07 ~ 2024&#x2F;06</li>\n</ul>\n</li>\n<li><strong>Vertiv Taiwan Software Engineer</strong> - 2021&#x2F;02 ~ 2022&#x2F;06</li>\n<li><strong>Perkd Taiwan Full-Stack Developer</strong> - 2020&#x2F;07 ~ 2021&#x2F;02</li>\n<li><strong>Perkd Taiwan Front-End Intern</strong> - 2019&#x2F;07 ~ 2019&#x2F;12</li>\n</ul>\n<p><strong>Special</strong></p>\n<ul>\n<li><strong>HiSKIO Lecturer</strong> - 2021&#x2F;10 ~2022&#x2F;10</li>\n</ul>\n<h2 id=\"專業技能\"><a href=\"#專業技能\" class=\"headerlink\" title=\"專業技能\"></a>專業技能</h2><p><strong>Front-End</strong></p>\n<ol>\n<li>HTML5 &#x2F; CSS3 &#x2F; JavaScript &#x2F; TypeScript</li>\n<li>Angular &#x2F; React Hook &#x2F; jQuery</li>\n<li>Angular Material &#x2F; BootStrap</li>\n<li>Webpack</li>\n</ol>\n<p><strong>Back-End</strong></p>\n<ol>\n<li>Node.js</li>\n<li>Express &#x2F; NestJS</li>\n<li>MongoDB &#x2F; mongoose</li>\n<li>AWS Lambda + API Gateway</li>\n</ol>\n<p><strong>Tools</strong></p>\n<ol>\n<li>Nx</li>\n<li>Docker</li>\n</ol>\n<p><strong>BlockChain</strong></p>\n<ol>\n<li>Smart Contract &#x2F; Solidity</li>\n<li>Go-ethereum</li>\n<li>Truffle</li>\n<li>Ganache</li>\n<li>web3.js &#x2F; ethjs</li>\n</ol>\n<h2 id=\"成就\"><a href=\"#成就\" class=\"headerlink\" title=\"成就\"></a>成就</h2><ul>\n<li>【2016】<a href=\"https://twsf.ntsec.gov.tw/activity/race-1/56/pdf/052508.pdf\">第 56 屆全國中小學科學展覽會電腦與資訊學科</a> - <strong>佳作</strong></li>\n<li>【2018】<a href=\"https://www.nkust.edu.tw/p/406-1000-8840,r12.php\">2018 Ai 機器人自造黑客松 - 南台灣挑戰賽</a> - <strong>總冠軍</strong></li>\n<li>【2018】<a href=\"https://ustart.yda.gov.tw/p/405-1000-1359,c112.php?Lang=zh-tw\">U-start 創新創業計畫 - 製造業組</a> - <strong>績優團隊</strong></li>\n<li>【2019】<a href=\"https://ithelp.ithome.com.tw/users/20119338/ironman/2150\">第 11 屆 iT 邦幫忙鐵人賽 - Blockchain</a> - <strong>佳作</strong></li>\n<li>【2020】<a href=\"https://ithelp.ithome.com.tw/users/20119338/ironman/3008\">第 12 屆 iT 邦幫忙鐵人賽 - Software Development</a> - <strong>佳作</strong></li>\n<li>【2021】<a href=\"https://ithelp.ithome.com.tw/users/20119338/ironman/3880\">第 13 屆 iT 邦幫忙鐵人賽 - Modern Web</a> - <strong>佳作</strong></li>\n<li>【2022】<a href=\"https://www.tenlong.com.tw/products/9786263332935\">著作 - NestJS 基礎必學實務指南：使用強大且易擴展的 Node.js 框架打造網頁應用程式</a></li>\n<li>【2024】<a href=\"https://ithelp.ithome.com.tw/users/20119338/ironman/7743\">第 16 屆 iT 邦幫忙鐵人賽 - Software Development</a> - <strong>優選</strong></li>\n</ul>\n<h2 id=\"演講\"><a href=\"#演講\" class=\"headerlink\" title=\"演講\"></a>演講</h2><ul>\n<li>【2024】<a href=\"https://tsmcitcommunitymeetup.kktix.cc/events/tsmc-it-meetup-taipei-02\">TSMC IT Meetup - 擁抱 Angular Signal</a></li>\n<li>【2024】<a href=\"https://hwdc.ithome.com.tw/2024/session-page/3226\">Hello World Dev Conference - NestJS 與 gRPC：快速上手指南</a></li>\n</ul>\n"},{"title":"標籤","date":"2023-09-09T09:20:38.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 標籤\ndate: 2023-09-09 17:20:38\ntype: \"tags\"\n---\n","updated":"2023-09-09T09:22:04.021Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cm9tztuvm0005fqgx0j7qee1n","content":"","excerpt":"","more":""},{"title":"分類","date":"2023-09-09T09:21:14.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分類\ndate: 2023-09-09 17:21:14\ntype: \"categories\"\n---\n","updated":"2023-09-09T09:21:57.517Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cm9tztuvo0008fqgx9hpuhdml","content":"","excerpt":"","more":""}],"Post":[{"title":"你可能不知道的 NestJS 隱藏技巧：Discovery Module","date":"2023-09-17T09:35:00.000Z","_content":"\n在某些應用場景下，可能會需要去遍歷封裝於 **模組（Module）** 內的元件，比如：找出帶有特定 **裝飾器（Decorator）** 的元件，甚至是元件底下的方法，來預先處理一些事情，最典型的案例就是 `EventEmitterModule`，當某個事件觸發時，會呼叫帶有特定裝飾器的方法。\n\n> **NOTE**：關於 `EventEmitterModule` 可以參考[官方文件](https://docs.nestjs.com/techniques/events)的說明。\n\n下方是官方 `EventEmitterModule` 的範例，透過 `EventEmitter2` 發送 `order.created` 事件時，會呼叫帶有 `@OnEvent` 裝飾器且值為 `order.created` 的方法：\n\n```typescript\nthis.eventEmitter.emit(\n  'order.created',\n  new OrderCreatedEvent({\n    orderId: 1,\n    payload: {},\n  }),\n);\n```\n\n```typescript\n// ...\n@Injectable()\nexport class OrderListener {\n  // ...\n  @OnEvent('order.created')\n  handleOrderCreatedEvent(payload: OrderCreatedEvent) {\n    // handle and process \"OrderCreatedEvent\" event\n  }\n}\n```\n\n那麼 `EventEmitterModule` 是如何做到這件事情的呢？它是透過一個叫 `DiscoveryModule` 的模組來找出所有元件底下含有 `@OnEvent` 裝飾器的方法，並根據帶入的值，來決定該方法在哪個事件下會被觸發。\n\n> **NOTE**：`DiscoveryModule` 並沒有收錄在 NestJS 官方文件中。\n\n## 深入 Discovery Module\n\n> **NOTE**：以下範例採用 NestJS 10 來撰寫。\n\n`DiscoveryModule` 是一個 NestJS 內建的模組，無須安裝套件，使用方式如下：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { DiscoveryModule } from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n  imports: [DiscoveryModule],\n  // ...\n})\nexport class AppModule {}\n```\n\n引入模組後，可以透過 `DiscoveryService` 來取得封裝於模組底下的 Controller 或 Provider：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { DiscoveryModule, DiscoveryService } from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n  imports: [DiscoveryModule],\n  // ...\n})\nexport class AppModule implements OnModuleInit {\n  constructor(\n    private readonly discoveryService: DiscoveryService\n  ) {}\n\n  onModuleInit() {\n    // 遍歷所有模組，以取得所有 Controller\n    const controllers = this.discoveryService.getControllers();\n    // 遍歷所有模組，以取得所有 Provider\n    const providers = this.discoveryService.getProviders();\n  }\n}\n```\n\n這裡需特別注意，取得的 **不是** Controller、Provider 本身，而是一個型別為 `InstanceWrapper` 的 Wrapper，若要拿到它們的本身的 **實例（Instance）**，只需要透過 `instance` 屬性即可取得，如下所示：\n\n```typescript\n// 將 instance 從 `InstanceWrapper` 取出\nconst instances = this.discoveryService.getControllers().map(({ instance }) => instance);\n```\n\n### 限縮遍歷範圍\n\n如果想要限制遍歷的模組範圍，`getControllers` 跟 `getProviders` 有提供相關參數，透過指定 `include` 來決定要遍歷哪些模組：\n\n```typescript\nimport { Module, OnModuleInit } from '@nestjs/common';\nimport { DiscoveryModule, DiscoveryService } from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n  imports: [TodoModule, DiscoveryModule],\n  // ...\n})\nexport class AppModule implements OnModuleInit {\n  constructor(\n    private readonly discoveryService: DiscoveryService\n  ) {}\n\n  onModuleInit() {\n    // 遍歷 `TodoModule`底下的元件，以取得底下的所有 Provider\n    const providers = this.discoveryService.getProviders({\n      include: [TodoModule],\n    });\n    // 遍歷 `TodoModule`底下的元件，以取得底下的所有 Controller\n    const controllers = this.discoveryService.getControllers({\n      include: [TodoModule],\n    });\n  }\n}\n```\n\n### 過濾別名 Provider 的技巧\n\n由於 `getProviders` 會拿到所有 Provider，所有裡面會含有 Alias Provider，在某些情境下有可能會導致相同的東西被處理一次以上，所以在預處理前，要先進行過濾：\n\n```typescript\nimport { Module, OnModuleInit } from '@nestjs/common';\nimport { DiscoveryModule, DiscoveryService } from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n  imports: [DiscoveryModule],\n  // ...\n})\nexport class AppModule implements OnModuleInit {\n  constructor(\n    private readonly discoveryService: DiscoveryService,\n    private readonly metadataScanner: MetadataScanner\n  ) {}\n\n  onModuleInit() {\n    const providers = this.discoveryService.getProviders();\n    const controllers = this.discoveryService.getControllers();\n    [...providers, ...controllers]\n      // 根據 `instance` 是否存在以及 `isAlias` 為 `false` 來過濾 Alias Provider\n      .filter((wrapper) => wrapper.instance && !wrapper.isAlias)\n      .forEach((wrapper) => {\n        // do something\n      });\n  }\n}\n```\n\n## 與 Metadata Scanner 共舞\n\n現在知道要如何透過 `DiscoveryModule` 遍歷所有元件了，那有什麼方法可以取得元件底下所有的方法呢？NestJS 有提供一個叫 `MetadataScanner` 的 Provider，讓我們可以去掃描元件下的所有方法，使用方式如下：\n\n```typescript\nimport { Module, OnModuleInit } from '@nestjs/common';\nimport { MetadataScanner } from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n})\nexport class AppModule implements OnModuleInit {\n  constructor(\n    private readonly metadataScanner: MetadataScanner\n  ) {}\n\n  onModuleInit() {\n    const instance = new Component();\n    // 取得元件底下的所有方法名稱\n    const methodNames = this.metadataScanner.getAllMethodNames(instance);\n  }\n}\n```\n\n那麼加上 `DiscoveryModule`，就可以遍歷所有元件底下的方法名稱了：\n\n```typescript\nimport { Module, OnModuleInit } from '@nestjs/common';\nimport {\n  DiscoveryModule,\n  DiscoveryService,\n  MetadataScanner\n} from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n  imports: [DiscoveryModule],\n  // ...\n})\nexport class AppModule implements OnModuleInit {\n  constructor(\n    private readonly discoveryService: DiscoveryService,\n    private readonly metadataScanner: MetadataScanner\n  ) {}\n\n  onModuleInit() {\n    const providers = this.discoveryService.getProviders();\n    const controllers = this.discoveryService.getControllers();\n\n    [...providers, ...controllers]\n      .filter((wrapper) => wrapper.instance && !wrapper.isAlias)\n      .forEach((wrapper) => {\n        const { instance } = wrapper;\n        const methodNames = this.metadataScanner.getAllMethodNames(instance);\n      });\n  }\n}\n```\n\n### 搭配 Reflector 打出連續技\n\n假設現在需要抓取所有元件下帶有 `HelloWorld` 裝飾器的方法，可以運用 `DiscoveryModule` 先遍歷所有的元件，再透過 `MetadataScanner` 掃出每個元件下的方法名稱，最後再使用 `Reflector` 篩選出最終結果。\n\n假設現在有一個 `@HelloWorld` 裝飾器：\n\n```typescript\nimport { SetMetadata } from '@nestjs/common';\n\nexport const HELLO_WORLD_KEY = 'custom:hello-word';\n\nexport const HelloWorld = () => SetMetadata(HELLO_WORLD_KEY, 'Hello World');\n```\n\n並且只在 `TodoModule` 底下的 `TodoController` 中使用：\n\n```typescript\nimport { Controller, Get } from '@nestjs/common';\n// ...\n\n@Controller('todos')\nexport class TodoController {\n  @HelloWorld()\n  @Get()\n  getTodos() {\n    return [];\n  }\n}\n```\n\n這時可以運用 `Reflector` 的 `get` 方法，來判斷元件底下的方法是否有使用 `@HelloWorld` 裝飾器：\n\n```typescript\nimport { Module, OnModuleInit } from '@nestjs/common';\nimport {\n  DiscoveryModule,\n  DiscoveryService,\n  MetadataScanner,\n  Reflector,\n} from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n  imports: [TodoModule, DiscoveryModule],\n  // ...\n})\nexport class AppModule implements OnModuleInit {\n  constructor(\n    private readonly discoveryService: DiscoveryService,\n    private readonly metadataScanner: MetadataScanner,\n    private readonly reflector: Reflector,\n  ) {}\n\n  onModuleInit() {\n    const providers = this.discoveryService.getProviders();\n    const controllers = this.discoveryService.getControllers();\n    \n    [...providers, ...controllers]\n      .filter((wrapper) => wrapper.instance && !wrapper.isAlias)\n      .forEach((wrapper) => {\n        const { instance } = wrapper;\n        const methodNames = this.metadataScanner.getAllMethodNames(instance);\n        methodNames\n          .filter(\n            (methodName) =>\n              this.reflector.get<string>(\n                HELLO_WORLD_KEY,\n                instance[methodName],\n              ) === 'Hello World',\n          )\n          .forEach((methodName) => {\n            console.log(methodName); // 'getTodos'\n          });\n      });\n  }\n}\n```\n\n## 結論\n\n`DiscoveryModule` 是一個蠻好用的內建模組，尤其是針對一些事件驅動的情境特別適合，比如說：使用第三方的 SDK，它收到某個事件時可以呼叫我們帶有特定裝飾器的方法等。\n\n## 參考資料\n\n- [EventEmitterModule](https://github.com/nestjs/event-emitter/tree/master)\n","source":"_posts/0002-nestjs-discovery-module.md","raw":"---\ntitle: 你可能不知道的 NestJS 隱藏技巧：Discovery Module\ndate: 2023-09-17 17:35:00\ntags:\n  - Backend\n  - NestJS\ncategories:\n  - ['Backend', 'NestJS', 'Advanced']\n---\n\n在某些應用場景下，可能會需要去遍歷封裝於 **模組（Module）** 內的元件，比如：找出帶有特定 **裝飾器（Decorator）** 的元件，甚至是元件底下的方法，來預先處理一些事情，最典型的案例就是 `EventEmitterModule`，當某個事件觸發時，會呼叫帶有特定裝飾器的方法。\n\n> **NOTE**：關於 `EventEmitterModule` 可以參考[官方文件](https://docs.nestjs.com/techniques/events)的說明。\n\n下方是官方 `EventEmitterModule` 的範例，透過 `EventEmitter2` 發送 `order.created` 事件時，會呼叫帶有 `@OnEvent` 裝飾器且值為 `order.created` 的方法：\n\n```typescript\nthis.eventEmitter.emit(\n  'order.created',\n  new OrderCreatedEvent({\n    orderId: 1,\n    payload: {},\n  }),\n);\n```\n\n```typescript\n// ...\n@Injectable()\nexport class OrderListener {\n  // ...\n  @OnEvent('order.created')\n  handleOrderCreatedEvent(payload: OrderCreatedEvent) {\n    // handle and process \"OrderCreatedEvent\" event\n  }\n}\n```\n\n那麼 `EventEmitterModule` 是如何做到這件事情的呢？它是透過一個叫 `DiscoveryModule` 的模組來找出所有元件底下含有 `@OnEvent` 裝飾器的方法，並根據帶入的值，來決定該方法在哪個事件下會被觸發。\n\n> **NOTE**：`DiscoveryModule` 並沒有收錄在 NestJS 官方文件中。\n\n## 深入 Discovery Module\n\n> **NOTE**：以下範例採用 NestJS 10 來撰寫。\n\n`DiscoveryModule` 是一個 NestJS 內建的模組，無須安裝套件，使用方式如下：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { DiscoveryModule } from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n  imports: [DiscoveryModule],\n  // ...\n})\nexport class AppModule {}\n```\n\n引入模組後，可以透過 `DiscoveryService` 來取得封裝於模組底下的 Controller 或 Provider：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { DiscoveryModule, DiscoveryService } from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n  imports: [DiscoveryModule],\n  // ...\n})\nexport class AppModule implements OnModuleInit {\n  constructor(\n    private readonly discoveryService: DiscoveryService\n  ) {}\n\n  onModuleInit() {\n    // 遍歷所有模組，以取得所有 Controller\n    const controllers = this.discoveryService.getControllers();\n    // 遍歷所有模組，以取得所有 Provider\n    const providers = this.discoveryService.getProviders();\n  }\n}\n```\n\n這裡需特別注意，取得的 **不是** Controller、Provider 本身，而是一個型別為 `InstanceWrapper` 的 Wrapper，若要拿到它們的本身的 **實例（Instance）**，只需要透過 `instance` 屬性即可取得，如下所示：\n\n```typescript\n// 將 instance 從 `InstanceWrapper` 取出\nconst instances = this.discoveryService.getControllers().map(({ instance }) => instance);\n```\n\n### 限縮遍歷範圍\n\n如果想要限制遍歷的模組範圍，`getControllers` 跟 `getProviders` 有提供相關參數，透過指定 `include` 來決定要遍歷哪些模組：\n\n```typescript\nimport { Module, OnModuleInit } from '@nestjs/common';\nimport { DiscoveryModule, DiscoveryService } from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n  imports: [TodoModule, DiscoveryModule],\n  // ...\n})\nexport class AppModule implements OnModuleInit {\n  constructor(\n    private readonly discoveryService: DiscoveryService\n  ) {}\n\n  onModuleInit() {\n    // 遍歷 `TodoModule`底下的元件，以取得底下的所有 Provider\n    const providers = this.discoveryService.getProviders({\n      include: [TodoModule],\n    });\n    // 遍歷 `TodoModule`底下的元件，以取得底下的所有 Controller\n    const controllers = this.discoveryService.getControllers({\n      include: [TodoModule],\n    });\n  }\n}\n```\n\n### 過濾別名 Provider 的技巧\n\n由於 `getProviders` 會拿到所有 Provider，所有裡面會含有 Alias Provider，在某些情境下有可能會導致相同的東西被處理一次以上，所以在預處理前，要先進行過濾：\n\n```typescript\nimport { Module, OnModuleInit } from '@nestjs/common';\nimport { DiscoveryModule, DiscoveryService } from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n  imports: [DiscoveryModule],\n  // ...\n})\nexport class AppModule implements OnModuleInit {\n  constructor(\n    private readonly discoveryService: DiscoveryService,\n    private readonly metadataScanner: MetadataScanner\n  ) {}\n\n  onModuleInit() {\n    const providers = this.discoveryService.getProviders();\n    const controllers = this.discoveryService.getControllers();\n    [...providers, ...controllers]\n      // 根據 `instance` 是否存在以及 `isAlias` 為 `false` 來過濾 Alias Provider\n      .filter((wrapper) => wrapper.instance && !wrapper.isAlias)\n      .forEach((wrapper) => {\n        // do something\n      });\n  }\n}\n```\n\n## 與 Metadata Scanner 共舞\n\n現在知道要如何透過 `DiscoveryModule` 遍歷所有元件了，那有什麼方法可以取得元件底下所有的方法呢？NestJS 有提供一個叫 `MetadataScanner` 的 Provider，讓我們可以去掃描元件下的所有方法，使用方式如下：\n\n```typescript\nimport { Module, OnModuleInit } from '@nestjs/common';\nimport { MetadataScanner } from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n})\nexport class AppModule implements OnModuleInit {\n  constructor(\n    private readonly metadataScanner: MetadataScanner\n  ) {}\n\n  onModuleInit() {\n    const instance = new Component();\n    // 取得元件底下的所有方法名稱\n    const methodNames = this.metadataScanner.getAllMethodNames(instance);\n  }\n}\n```\n\n那麼加上 `DiscoveryModule`，就可以遍歷所有元件底下的方法名稱了：\n\n```typescript\nimport { Module, OnModuleInit } from '@nestjs/common';\nimport {\n  DiscoveryModule,\n  DiscoveryService,\n  MetadataScanner\n} from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n  imports: [DiscoveryModule],\n  // ...\n})\nexport class AppModule implements OnModuleInit {\n  constructor(\n    private readonly discoveryService: DiscoveryService,\n    private readonly metadataScanner: MetadataScanner\n  ) {}\n\n  onModuleInit() {\n    const providers = this.discoveryService.getProviders();\n    const controllers = this.discoveryService.getControllers();\n\n    [...providers, ...controllers]\n      .filter((wrapper) => wrapper.instance && !wrapper.isAlias)\n      .forEach((wrapper) => {\n        const { instance } = wrapper;\n        const methodNames = this.metadataScanner.getAllMethodNames(instance);\n      });\n  }\n}\n```\n\n### 搭配 Reflector 打出連續技\n\n假設現在需要抓取所有元件下帶有 `HelloWorld` 裝飾器的方法，可以運用 `DiscoveryModule` 先遍歷所有的元件，再透過 `MetadataScanner` 掃出每個元件下的方法名稱，最後再使用 `Reflector` 篩選出最終結果。\n\n假設現在有一個 `@HelloWorld` 裝飾器：\n\n```typescript\nimport { SetMetadata } from '@nestjs/common';\n\nexport const HELLO_WORLD_KEY = 'custom:hello-word';\n\nexport const HelloWorld = () => SetMetadata(HELLO_WORLD_KEY, 'Hello World');\n```\n\n並且只在 `TodoModule` 底下的 `TodoController` 中使用：\n\n```typescript\nimport { Controller, Get } from '@nestjs/common';\n// ...\n\n@Controller('todos')\nexport class TodoController {\n  @HelloWorld()\n  @Get()\n  getTodos() {\n    return [];\n  }\n}\n```\n\n這時可以運用 `Reflector` 的 `get` 方法，來判斷元件底下的方法是否有使用 `@HelloWorld` 裝飾器：\n\n```typescript\nimport { Module, OnModuleInit } from '@nestjs/common';\nimport {\n  DiscoveryModule,\n  DiscoveryService,\n  MetadataScanner,\n  Reflector,\n} from '@nestjs/core';\n// ...\n\n@Module({\n  // ...\n  imports: [TodoModule, DiscoveryModule],\n  // ...\n})\nexport class AppModule implements OnModuleInit {\n  constructor(\n    private readonly discoveryService: DiscoveryService,\n    private readonly metadataScanner: MetadataScanner,\n    private readonly reflector: Reflector,\n  ) {}\n\n  onModuleInit() {\n    const providers = this.discoveryService.getProviders();\n    const controllers = this.discoveryService.getControllers();\n    \n    [...providers, ...controllers]\n      .filter((wrapper) => wrapper.instance && !wrapper.isAlias)\n      .forEach((wrapper) => {\n        const { instance } = wrapper;\n        const methodNames = this.metadataScanner.getAllMethodNames(instance);\n        methodNames\n          .filter(\n            (methodName) =>\n              this.reflector.get<string>(\n                HELLO_WORLD_KEY,\n                instance[methodName],\n              ) === 'Hello World',\n          )\n          .forEach((methodName) => {\n            console.log(methodName); // 'getTodos'\n          });\n      });\n  }\n}\n```\n\n## 結論\n\n`DiscoveryModule` 是一個蠻好用的內建模組，尤其是針對一些事件驅動的情境特別適合，比如說：使用第三方的 SDK，它收到某個事件時可以呼叫我們帶有特定裝飾器的方法等。\n\n## 參考資料\n\n- [EventEmitterModule](https://github.com/nestjs/event-emitter/tree/master)\n","slug":"0002-nestjs-discovery-module","published":1,"updated":"2023-09-17T09:42:22.596Z","comments":1,"layout":"post","photos":[],"_id":"cm9tztuvf0001fqgxgz64g437","content":"<p>在某些應用場景下，可能會需要去遍歷封裝於 <strong>模組（Module）</strong> 內的元件，比如：找出帶有特定 <strong>裝飾器（Decorator）</strong> 的元件，甚至是元件底下的方法，來預先處理一些事情，最典型的案例就是 <code>EventEmitterModule</code>，當某個事件觸發時，會呼叫帶有特定裝飾器的方法。</p>\n<blockquote>\n<p><strong>NOTE</strong>：關於 <code>EventEmitterModule</code> 可以參考<a href=\"https://docs.nestjs.com/techniques/events\">官方文件</a>的說明。</p>\n</blockquote>\n<p>下方是官方 <code>EventEmitterModule</code> 的範例，透過 <code>EventEmitter2</code> 發送 <code>order.created</code> 事件時，會呼叫帶有 <code>@OnEvent</code> 裝飾器且值為 <code>order.created</code> 的方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">eventEmitter</span>.<span class=\"title function_\">emit</span>(</span><br><span class=\"line\">  <span class=\"string\">&#x27;order.created&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">OrderCreatedEvent</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">orderId</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">payload</span>: &#123;&#125;,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderListener</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"meta\">@OnEvent</span>(<span class=\"string\">&#x27;order.created&#x27;</span>)</span><br><span class=\"line\">  <span class=\"title function_\">handleOrderCreatedEvent</span>(<span class=\"params\"><span class=\"attr\">payload</span>: <span class=\"title class_\">OrderCreatedEvent</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// handle and process &quot;OrderCreatedEvent&quot; event</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那麼 <code>EventEmitterModule</code> 是如何做到這件事情的呢？它是透過一個叫 <code>DiscoveryModule</code> 的模組來找出所有元件底下含有 <code>@OnEvent</code> 裝飾器的方法，並根據帶入的值，來決定該方法在哪個事件下會被觸發。</p>\n<blockquote>\n<p><strong>NOTE</strong>：<code>DiscoveryModule</code> 並沒有收錄在 NestJS 官方文件中。</p>\n</blockquote>\n<h2 id=\"深入-Discovery-Module\"><a href=\"#深入-Discovery-Module\" class=\"headerlink\" title=\"深入 Discovery Module\"></a>深入 Discovery Module</h2><blockquote>\n<p><strong>NOTE</strong>：以下範例採用 NestJS 10 來撰寫。</p>\n</blockquote>\n<p><code>DiscoveryModule</code> 是一個 NestJS 內建的模組，無須安裝套件，使用方式如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">DiscoveryModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">DiscoveryModule</span>],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>引入模組後，可以透過 <code>DiscoveryService</code> 來取得封裝於模組底下的 Controller 或 Provider：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">DiscoveryModule</span>, <span class=\"title class_\">DiscoveryService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">DiscoveryModule</span>],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnModuleInit</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">discoveryService</span>: <span class=\"title class_\">DiscoveryService</span></span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onModuleInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍歷所有模組，以取得所有 Controller</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> controllers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getControllers</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 遍歷所有模組，以取得所有 Provider</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> providers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getProviders</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這裡需特別注意，取得的 <strong>不是</strong> Controller、Provider 本身，而是一個型別為 <code>InstanceWrapper</code> 的 Wrapper，若要拿到它們的本身的 <strong>實例（Instance）</strong>，只需要透過 <code>instance</code> 屬性即可取得，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 將 instance 從 `InstanceWrapper` 取出</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> instances = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getControllers</span>().<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">&#123; instance &#125;</span>) =&gt;</span> instance);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"限縮遍歷範圍\"><a href=\"#限縮遍歷範圍\" class=\"headerlink\" title=\"限縮遍歷範圍\"></a>限縮遍歷範圍</h3><p>如果想要限制遍歷的模組範圍，<code>getControllers</code> 跟 <code>getProviders</code> 有提供相關參數，透過指定 <code>include</code> 來決定要遍歷哪些模組：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span>, <span class=\"title class_\">OnModuleInit</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">DiscoveryModule</span>, <span class=\"title class_\">DiscoveryService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">TodoModule</span>, <span class=\"title class_\">DiscoveryModule</span>],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnModuleInit</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">discoveryService</span>: <span class=\"title class_\">DiscoveryService</span></span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onModuleInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍歷 `TodoModule`底下的元件，以取得底下的所有 Provider</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> providers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getProviders</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">include</span>: [<span class=\"title class_\">TodoModule</span>],</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 遍歷 `TodoModule`底下的元件，以取得底下的所有 Controller</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> controllers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getControllers</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">include</span>: [<span class=\"title class_\">TodoModule</span>],</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"過濾別名-Provider-的技巧\"><a href=\"#過濾別名-Provider-的技巧\" class=\"headerlink\" title=\"過濾別名 Provider 的技巧\"></a>過濾別名 Provider 的技巧</h3><p>由於 <code>getProviders</code> 會拿到所有 Provider，所有裡面會含有 Alias Provider，在某些情境下有可能會導致相同的東西被處理一次以上，所以在預處理前，要先進行過濾：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span>, <span class=\"title class_\">OnModuleInit</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">DiscoveryModule</span>, <span class=\"title class_\">DiscoveryService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">DiscoveryModule</span>],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnModuleInit</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">discoveryService</span>: <span class=\"title class_\">DiscoveryService</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">metadataScanner</span>: <span class=\"title class_\">MetadataScanner</span></span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onModuleInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> providers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getProviders</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> controllers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getControllers</span>();</span><br><span class=\"line\">    [...providers, ...controllers]</span><br><span class=\"line\">      <span class=\"comment\">// 根據 `instance` 是否存在以及 `isAlias` 為 `false` 來過濾 Alias Provider</span></span><br><span class=\"line\">      .<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">wrapper</span>) =&gt;</span> wrapper.<span class=\"property\">instance</span> &amp;&amp; !wrapper.<span class=\"property\">isAlias</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">wrapper</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"與-Metadata-Scanner-共舞\"><a href=\"#與-Metadata-Scanner-共舞\" class=\"headerlink\" title=\"與 Metadata Scanner 共舞\"></a>與 Metadata Scanner 共舞</h2><p>現在知道要如何透過 <code>DiscoveryModule</code> 遍歷所有元件了，那有什麼方法可以取得元件底下所有的方法呢？NestJS 有提供一個叫 <code>MetadataScanner</code> 的 Provider，讓我們可以去掃描元件下的所有方法，使用方式如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span>, <span class=\"title class_\">OnModuleInit</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">MetadataScanner</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnModuleInit</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">metadataScanner</span>: <span class=\"title class_\">MetadataScanner</span></span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onModuleInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Component</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 取得元件底下的所有方法名稱</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> methodNames = <span class=\"variable language_\">this</span>.<span class=\"property\">metadataScanner</span>.<span class=\"title function_\">getAllMethodNames</span>(instance);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那麼加上 <code>DiscoveryModule</code>，就可以遍歷所有元件底下的方法名稱了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span>, <span class=\"title class_\">OnModuleInit</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">DiscoveryModule</span>,</span><br><span class=\"line\">  <span class=\"title class_\">DiscoveryService</span>,</span><br><span class=\"line\">  <span class=\"title class_\">MetadataScanner</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">DiscoveryModule</span>],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnModuleInit</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">discoveryService</span>: <span class=\"title class_\">DiscoveryService</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">metadataScanner</span>: <span class=\"title class_\">MetadataScanner</span></span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onModuleInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> providers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getProviders</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> controllers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getControllers</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    [...providers, ...controllers]</span><br><span class=\"line\">      .<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">wrapper</span>) =&gt;</span> wrapper.<span class=\"property\">instance</span> &amp;&amp; !wrapper.<span class=\"property\">isAlias</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">wrapper</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; instance &#125; = wrapper;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> methodNames = <span class=\"variable language_\">this</span>.<span class=\"property\">metadataScanner</span>.<span class=\"title function_\">getAllMethodNames</span>(instance);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"搭配-Reflector-打出連續技\"><a href=\"#搭配-Reflector-打出連續技\" class=\"headerlink\" title=\"搭配 Reflector 打出連續技\"></a>搭配 Reflector 打出連續技</h3><p>假設現在需要抓取所有元件下帶有 <code>HelloWorld</code> 裝飾器的方法，可以運用 <code>DiscoveryModule</code> 先遍歷所有的元件，再透過 <code>MetadataScanner</code> 掃出每個元件下的方法名稱，最後再使用 <code>Reflector</code> 篩選出最終結果。</p>\n<p>假設現在有一個 <code>@HelloWorld</code> 裝飾器：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">SetMetadata</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">HELLO_WORLD_KEY</span> = <span class=\"string\">&#x27;custom:hello-word&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">HelloWorld</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title class_\">SetMetadata</span>(<span class=\"variable constant_\">HELLO_WORLD_KEY</span>, <span class=\"string\">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>並且只在 <code>TodoModule</code> 底下的 <code>TodoController</code> 中使用：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Controller</span>, <span class=\"title class_\">Get</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Controller</span>(<span class=\"string\">&#x27;todos&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TodoController</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@HelloWorld</span>()</span><br><span class=\"line\">  <span class=\"meta\">@Get</span>()</span><br><span class=\"line\">  <span class=\"title function_\">getTodos</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這時可以運用 <code>Reflector</code> 的 <code>get</code> 方法，來判斷元件底下的方法是否有使用 <code>@HelloWorld</code> 裝飾器：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span>, <span class=\"title class_\">OnModuleInit</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">DiscoveryModule</span>,</span><br><span class=\"line\">  <span class=\"title class_\">DiscoveryService</span>,</span><br><span class=\"line\">  <span class=\"title class_\">MetadataScanner</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Reflector</span>,</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">TodoModule</span>, <span class=\"title class_\">DiscoveryModule</span>],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnModuleInit</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">discoveryService</span>: <span class=\"title class_\">DiscoveryService</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">metadataScanner</span>: <span class=\"title class_\">MetadataScanner</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">reflector</span>: <span class=\"title class_\">Reflector</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onModuleInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> providers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getProviders</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> controllers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getControllers</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    [...providers, ...controllers]</span><br><span class=\"line\">      .<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">wrapper</span>) =&gt;</span> wrapper.<span class=\"property\">instance</span> &amp;&amp; !wrapper.<span class=\"property\">isAlias</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">wrapper</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; instance &#125; = wrapper;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> methodNames = <span class=\"variable language_\">this</span>.<span class=\"property\">metadataScanner</span>.<span class=\"title function_\">getAllMethodNames</span>(instance);</span><br><span class=\"line\">        methodNames</span><br><span class=\"line\">          .<span class=\"title function_\">filter</span>(</span><br><span class=\"line\">            <span class=\"function\">(<span class=\"params\">methodName</span>) =&gt;</span></span><br><span class=\"line\">              <span class=\"variable language_\">this</span>.<span class=\"property\">reflector</span>.<span class=\"property\">get</span>&lt;<span class=\"built_in\">string</span>&gt;(</span><br><span class=\"line\">                <span class=\"variable constant_\">HELLO_WORLD_KEY</span>,</span><br><span class=\"line\">                instance[methodName],</span><br><span class=\"line\">              ) === <span class=\"string\">&#x27;Hello World&#x27;</span>,</span><br><span class=\"line\">          )</span><br><span class=\"line\">          .<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">methodName</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(methodName); <span class=\"comment\">// &#x27;getTodos&#x27;</span></span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p><code>DiscoveryModule</code> 是一個蠻好用的內建模組，尤其是針對一些事件驅動的情境特別適合，比如說：使用第三方的 SDK，它收到某個事件時可以呼叫我們帶有特定裝飾器的方法等。</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://github.com/nestjs/event-emitter/tree/master\">EventEmitterModule</a></li>\n</ul>\n","excerpt":"","more":"<p>在某些應用場景下，可能會需要去遍歷封裝於 <strong>模組（Module）</strong> 內的元件，比如：找出帶有特定 <strong>裝飾器（Decorator）</strong> 的元件，甚至是元件底下的方法，來預先處理一些事情，最典型的案例就是 <code>EventEmitterModule</code>，當某個事件觸發時，會呼叫帶有特定裝飾器的方法。</p>\n<blockquote>\n<p><strong>NOTE</strong>：關於 <code>EventEmitterModule</code> 可以參考<a href=\"https://docs.nestjs.com/techniques/events\">官方文件</a>的說明。</p>\n</blockquote>\n<p>下方是官方 <code>EventEmitterModule</code> 的範例，透過 <code>EventEmitter2</code> 發送 <code>order.created</code> 事件時，會呼叫帶有 <code>@OnEvent</code> 裝飾器且值為 <code>order.created</code> 的方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">eventEmitter</span>.<span class=\"title function_\">emit</span>(</span><br><span class=\"line\">  <span class=\"string\">&#x27;order.created&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">OrderCreatedEvent</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">orderId</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">payload</span>: &#123;&#125;,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderListener</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"meta\">@OnEvent</span>(<span class=\"string\">&#x27;order.created&#x27;</span>)</span><br><span class=\"line\">  <span class=\"title function_\">handleOrderCreatedEvent</span>(<span class=\"params\"><span class=\"attr\">payload</span>: <span class=\"title class_\">OrderCreatedEvent</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// handle and process &quot;OrderCreatedEvent&quot; event</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那麼 <code>EventEmitterModule</code> 是如何做到這件事情的呢？它是透過一個叫 <code>DiscoveryModule</code> 的模組來找出所有元件底下含有 <code>@OnEvent</code> 裝飾器的方法，並根據帶入的值，來決定該方法在哪個事件下會被觸發。</p>\n<blockquote>\n<p><strong>NOTE</strong>：<code>DiscoveryModule</code> 並沒有收錄在 NestJS 官方文件中。</p>\n</blockquote>\n<h2 id=\"深入-Discovery-Module\"><a href=\"#深入-Discovery-Module\" class=\"headerlink\" title=\"深入 Discovery Module\"></a>深入 Discovery Module</h2><blockquote>\n<p><strong>NOTE</strong>：以下範例採用 NestJS 10 來撰寫。</p>\n</blockquote>\n<p><code>DiscoveryModule</code> 是一個 NestJS 內建的模組，無須安裝套件，使用方式如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">DiscoveryModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">DiscoveryModule</span>],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>引入模組後，可以透過 <code>DiscoveryService</code> 來取得封裝於模組底下的 Controller 或 Provider：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">DiscoveryModule</span>, <span class=\"title class_\">DiscoveryService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">DiscoveryModule</span>],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnModuleInit</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">discoveryService</span>: <span class=\"title class_\">DiscoveryService</span></span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onModuleInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍歷所有模組，以取得所有 Controller</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> controllers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getControllers</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 遍歷所有模組，以取得所有 Provider</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> providers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getProviders</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這裡需特別注意，取得的 <strong>不是</strong> Controller、Provider 本身，而是一個型別為 <code>InstanceWrapper</code> 的 Wrapper，若要拿到它們的本身的 <strong>實例（Instance）</strong>，只需要透過 <code>instance</code> 屬性即可取得，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 將 instance 從 `InstanceWrapper` 取出</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> instances = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getControllers</span>().<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">&#123; instance &#125;</span>) =&gt;</span> instance);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"限縮遍歷範圍\"><a href=\"#限縮遍歷範圍\" class=\"headerlink\" title=\"限縮遍歷範圍\"></a>限縮遍歷範圍</h3><p>如果想要限制遍歷的模組範圍，<code>getControllers</code> 跟 <code>getProviders</code> 有提供相關參數，透過指定 <code>include</code> 來決定要遍歷哪些模組：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span>, <span class=\"title class_\">OnModuleInit</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">DiscoveryModule</span>, <span class=\"title class_\">DiscoveryService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">TodoModule</span>, <span class=\"title class_\">DiscoveryModule</span>],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnModuleInit</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">discoveryService</span>: <span class=\"title class_\">DiscoveryService</span></span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onModuleInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍歷 `TodoModule`底下的元件，以取得底下的所有 Provider</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> providers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getProviders</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">include</span>: [<span class=\"title class_\">TodoModule</span>],</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 遍歷 `TodoModule`底下的元件，以取得底下的所有 Controller</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> controllers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getControllers</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">include</span>: [<span class=\"title class_\">TodoModule</span>],</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"過濾別名-Provider-的技巧\"><a href=\"#過濾別名-Provider-的技巧\" class=\"headerlink\" title=\"過濾別名 Provider 的技巧\"></a>過濾別名 Provider 的技巧</h3><p>由於 <code>getProviders</code> 會拿到所有 Provider，所有裡面會含有 Alias Provider，在某些情境下有可能會導致相同的東西被處理一次以上，所以在預處理前，要先進行過濾：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span>, <span class=\"title class_\">OnModuleInit</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">DiscoveryModule</span>, <span class=\"title class_\">DiscoveryService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">DiscoveryModule</span>],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnModuleInit</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">discoveryService</span>: <span class=\"title class_\">DiscoveryService</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">metadataScanner</span>: <span class=\"title class_\">MetadataScanner</span></span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onModuleInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> providers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getProviders</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> controllers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getControllers</span>();</span><br><span class=\"line\">    [...providers, ...controllers]</span><br><span class=\"line\">      <span class=\"comment\">// 根據 `instance` 是否存在以及 `isAlias` 為 `false` 來過濾 Alias Provider</span></span><br><span class=\"line\">      .<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">wrapper</span>) =&gt;</span> wrapper.<span class=\"property\">instance</span> &amp;&amp; !wrapper.<span class=\"property\">isAlias</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">wrapper</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"與-Metadata-Scanner-共舞\"><a href=\"#與-Metadata-Scanner-共舞\" class=\"headerlink\" title=\"與 Metadata Scanner 共舞\"></a>與 Metadata Scanner 共舞</h2><p>現在知道要如何透過 <code>DiscoveryModule</code> 遍歷所有元件了，那有什麼方法可以取得元件底下所有的方法呢？NestJS 有提供一個叫 <code>MetadataScanner</code> 的 Provider，讓我們可以去掃描元件下的所有方法，使用方式如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span>, <span class=\"title class_\">OnModuleInit</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">MetadataScanner</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnModuleInit</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">metadataScanner</span>: <span class=\"title class_\">MetadataScanner</span></span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onModuleInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Component</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 取得元件底下的所有方法名稱</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> methodNames = <span class=\"variable language_\">this</span>.<span class=\"property\">metadataScanner</span>.<span class=\"title function_\">getAllMethodNames</span>(instance);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那麼加上 <code>DiscoveryModule</code>，就可以遍歷所有元件底下的方法名稱了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span>, <span class=\"title class_\">OnModuleInit</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">DiscoveryModule</span>,</span><br><span class=\"line\">  <span class=\"title class_\">DiscoveryService</span>,</span><br><span class=\"line\">  <span class=\"title class_\">MetadataScanner</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">DiscoveryModule</span>],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnModuleInit</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">discoveryService</span>: <span class=\"title class_\">DiscoveryService</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">metadataScanner</span>: <span class=\"title class_\">MetadataScanner</span></span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onModuleInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> providers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getProviders</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> controllers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getControllers</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    [...providers, ...controllers]</span><br><span class=\"line\">      .<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">wrapper</span>) =&gt;</span> wrapper.<span class=\"property\">instance</span> &amp;&amp; !wrapper.<span class=\"property\">isAlias</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">wrapper</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; instance &#125; = wrapper;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> methodNames = <span class=\"variable language_\">this</span>.<span class=\"property\">metadataScanner</span>.<span class=\"title function_\">getAllMethodNames</span>(instance);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"搭配-Reflector-打出連續技\"><a href=\"#搭配-Reflector-打出連續技\" class=\"headerlink\" title=\"搭配 Reflector 打出連續技\"></a>搭配 Reflector 打出連續技</h3><p>假設現在需要抓取所有元件下帶有 <code>HelloWorld</code> 裝飾器的方法，可以運用 <code>DiscoveryModule</code> 先遍歷所有的元件，再透過 <code>MetadataScanner</code> 掃出每個元件下的方法名稱，最後再使用 <code>Reflector</code> 篩選出最終結果。</p>\n<p>假設現在有一個 <code>@HelloWorld</code> 裝飾器：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">SetMetadata</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">HELLO_WORLD_KEY</span> = <span class=\"string\">&#x27;custom:hello-word&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">HelloWorld</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title class_\">SetMetadata</span>(<span class=\"variable constant_\">HELLO_WORLD_KEY</span>, <span class=\"string\">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>並且只在 <code>TodoModule</code> 底下的 <code>TodoController</code> 中使用：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Controller</span>, <span class=\"title class_\">Get</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Controller</span>(<span class=\"string\">&#x27;todos&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TodoController</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@HelloWorld</span>()</span><br><span class=\"line\">  <span class=\"meta\">@Get</span>()</span><br><span class=\"line\">  <span class=\"title function_\">getTodos</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這時可以運用 <code>Reflector</code> 的 <code>get</code> 方法，來判斷元件底下的方法是否有使用 <code>@HelloWorld</code> 裝飾器：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span>, <span class=\"title class_\">OnModuleInit</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">DiscoveryModule</span>,</span><br><span class=\"line\">  <span class=\"title class_\">DiscoveryService</span>,</span><br><span class=\"line\">  <span class=\"title class_\">MetadataScanner</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Reflector</span>,</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">TodoModule</span>, <span class=\"title class_\">DiscoveryModule</span>],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnModuleInit</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">discoveryService</span>: <span class=\"title class_\">DiscoveryService</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">metadataScanner</span>: <span class=\"title class_\">MetadataScanner</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">reflector</span>: <span class=\"title class_\">Reflector</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onModuleInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> providers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getProviders</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> controllers = <span class=\"variable language_\">this</span>.<span class=\"property\">discoveryService</span>.<span class=\"title function_\">getControllers</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    [...providers, ...controllers]</span><br><span class=\"line\">      .<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">wrapper</span>) =&gt;</span> wrapper.<span class=\"property\">instance</span> &amp;&amp; !wrapper.<span class=\"property\">isAlias</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">wrapper</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; instance &#125; = wrapper;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> methodNames = <span class=\"variable language_\">this</span>.<span class=\"property\">metadataScanner</span>.<span class=\"title function_\">getAllMethodNames</span>(instance);</span><br><span class=\"line\">        methodNames</span><br><span class=\"line\">          .<span class=\"title function_\">filter</span>(</span><br><span class=\"line\">            <span class=\"function\">(<span class=\"params\">methodName</span>) =&gt;</span></span><br><span class=\"line\">              <span class=\"variable language_\">this</span>.<span class=\"property\">reflector</span>.<span class=\"property\">get</span>&lt;<span class=\"built_in\">string</span>&gt;(</span><br><span class=\"line\">                <span class=\"variable constant_\">HELLO_WORLD_KEY</span>,</span><br><span class=\"line\">                instance[methodName],</span><br><span class=\"line\">              ) === <span class=\"string\">&#x27;Hello World&#x27;</span>,</span><br><span class=\"line\">          )</span><br><span class=\"line\">          .<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">methodName</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(methodName); <span class=\"comment\">// &#x27;getTodos&#x27;</span></span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p><code>DiscoveryModule</code> 是一個蠻好用的內建模組，尤其是針對一些事件驅動的情境特別適合，比如說：使用第三方的 SDK，它收到某個事件時可以呼叫我們帶有特定裝飾器的方法等。</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://github.com/nestjs/event-emitter/tree/master\">EventEmitterModule</a></li>\n</ul>\n"},{"title":"動態載入 Web Component","date":"2023-09-10T12:47:00.000Z","_content":"\n## 什麼是 Web Component？\n\nWeb Component 是一個封裝自定義元件的技術，讓我們可以輕易地在不同應用程式中重用這些被封裝的元件，\n不僅如此，Web Component 不限定應用程式使用的框架或函式庫，不論今天是 Angular 或 React，甚至是 Vanilla JavaScript 都能夠輕鬆使用。\n\n> **INFO**：關於 Web Component 的詳細資訊可以參考 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components)。\n\n\n## 為什麼需要 Web Component？\n\nWeb Component 的問世，可以實現較理想的 **微前端（Micro Frontend）** 概念，在過去，會以 iframe 的形式將其他團隊開發的元件、頁面嵌入至自己的系統內來實現微前端，但這樣的做法會有很多的限制，比如：跨域、生命週期等。\n\n透過 Web Component 則可以避免這些問題，因為概念上就是將其他團隊開發的元件程式碼嵌入並串接至自己的系統裡。\n\n> **NOTE**：微前端也可以用 Module Federation 技術來實作，有興趣的話，可以參考[相關文件](https://webpack.js.org/concepts/module-federation/)。\n\n## 動態載入 Web Component\n\n目前常見的 Web Component 套用方式是將該元件推至 registry，提供給其他開發者安裝，甚至會針對不同的前端框架進行封裝，進而讓使用各種框架的開發者都可以用更貼近框架的做法來使用這些元件。\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"web-component-for-framework.png\"\n  alt=\"Web Component For Framework\"\n/>\n\n在某些情境下，我們可能會希望以 **動態（Dynamic）** 的方式將 Web Component 載入至自己的系統內使用，甚至能夠永遠使用最新版的元件，在這種較極端的情境下，就要實作一套機制來達到動態載入的效果。\n\n### 流程設計\n\n以下是一個很簡單的實現流程：\n\n1. Web Component 編譯後的 Chunk 掛在 CDN 上\n2. 應用程式透過 API 或設定檔取得 Web Component 的 url\n3. 透過 Loader 將 Chunk 載入\n4. 使用 Web Component\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"web-component-dynamic-loader.png\"\n  alt=\"Web Component Dynamic Loader\"\n/>\n\n### 實作\n\n根據流程設計可以得知，動態載入 Web Component 的關鍵點在於取得 Web Component Chunk 的 url 並透過某種 Loader 來將該 Chunk 載入，這裡 **僅會針對這段進行實作，其餘細節將會省略**。\n\n> **NOTE**：以下實作會以 Angular 16 當作範例。\n\n為了簡化實作範疇，這裡採用設定檔的方式來設定 Web Component Chunk 的 url，Web Component 的 Chunk 也會放在 `assets` 資料夾內，以下是設定檔 `config.json` 的內容：\n```json\n{\n  \"webComponents\": [\n    {\n      \"id\": \"rainbow-block\",\n      \"source\": \"assets/webComponents/rainbow-block.js\"\n    }\n  ]\n}\n```\n設定檔內定義了 `webComponents`欄位告訴應用程式有哪些 Web Component 需要載入，資料結構為陣列，裡面每個元素會定義 `id` 與 `source` 來註記該 Web Component Chunk 的 `id` 與 url。\n\n設置完 `config.json` 後，在專案內建立 `web-component-dynamic-loader.service.ts` 來實現動態載入 Web Component：\n```typescript\n// ...\n@Injectable({ providedIn: 'root' })\nexport class WebComponentDynamicLoaderService {\n  // 注入 document\n  private readonly _document = inject(DOCUMENT);\n\n  load(id: string, source: string) {\n    const script = this._document.createElement('script');\n\n    // 如果相同的 Web Component Chunk 已經載入，則不須做任何事\n    if (this._document.getElementById(id)) {\n      return of(null);\n    }\n\n    script.src = source;\n    script.id = id;\n\n    this._document.head.appendChild(script);\n\n    // 聽 script 的 onload 事件\n    return fromEvent<null>(script, 'load').pipe(\n      map(() => null),\n      take(1)\n    );\n  }\n}\n```\n\n實作 `ConfigStore` 存放 `config.json` 的內容：\n```typescript\n// ...\nexport interface Config {\n  webComponents: { id: string; source: string }[];\n}\n\nconst isNotNull = <T>(config: T | null): config is NonNullable<T> =>\n  config !== null;\n\n@Injectable({ providedIn: 'root' })\nexport class ConfigStore {\n  private readonly _config$ = new BehaviorSubject<Config | null>(null);\n  readonly config$ = this._config$.pipe(filter(isNotNull));\n\n  private readonly httpClient = inject(HttpClient);\n\n  // 用於 APP_INITIALIZER\n  loadConfig() {\n    return () => {\n      return this.httpClient.get<Config>('assets/config.json').pipe(\n        tap((config) => {\n          this._config$.next(config);\n        })\n      );\n    };\n  }\n}\n```\n\n接著，在 `app.config.ts` 透過 `APP_INITIALIZER` 取得 `config.json` 的內容，並在此載入 Web Component：\n```typescript\n// ...\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    {\n      provide: APP_INITIALIZER,\n      useFactory: (configStore: ConfigStore) => {\n        // 載入 config.json 並存入 ConfigStore 裡\n        return configStore.loadConfig();\n      },\n      deps: [ConfigStore],\n      multi: true,\n    },\n    {\n      provide: APP_INITIALIZER,\n      useFactory: (\n        configStore: ConfigStore,\n        loader: WebComponentDynamicLoaderService\n      ) => {\n        return () => {\n          return configStore.config$.pipe(\n            take(1),\n            // 當 config.json 內容載入後，會根據設定內容來載入 Web Component Chunk\n            concatMap((config) => from(config.webComponents)),\n            mergeMap(({ id, source }) => loader.load(id, source)),\n            toArray()\n          );\n        };\n      },\n      deps: [ConfigStore, WebComponentDynamicLoaderService],\n      multi: true,\n    },\n    // ...\n  ],\n};\n```\n如此一來，便可以用動態的方式將 Web Component 載入。\n\n> **NOTE**：實作結果可以 clone [這個專案](https://github.com/hao0731/angular-dynamic-load-web-component)玩玩看。","source":"_posts/0001-dynamic-load-web-component.md","raw":"---\ntitle: 動態載入 Web Component\ndate: 2023-09-10 20:47:00\ntags:\n  - Frontend\n  - Angular\n  - Web Component\ncategories:\n  - ['Frontend', 'Web Component']\n---\n\n## 什麼是 Web Component？\n\nWeb Component 是一個封裝自定義元件的技術，讓我們可以輕易地在不同應用程式中重用這些被封裝的元件，\n不僅如此，Web Component 不限定應用程式使用的框架或函式庫，不論今天是 Angular 或 React，甚至是 Vanilla JavaScript 都能夠輕鬆使用。\n\n> **INFO**：關於 Web Component 的詳細資訊可以參考 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components)。\n\n\n## 為什麼需要 Web Component？\n\nWeb Component 的問世，可以實現較理想的 **微前端（Micro Frontend）** 概念，在過去，會以 iframe 的形式將其他團隊開發的元件、頁面嵌入至自己的系統內來實現微前端，但這樣的做法會有很多的限制，比如：跨域、生命週期等。\n\n透過 Web Component 則可以避免這些問題，因為概念上就是將其他團隊開發的元件程式碼嵌入並串接至自己的系統裡。\n\n> **NOTE**：微前端也可以用 Module Federation 技術來實作，有興趣的話，可以參考[相關文件](https://webpack.js.org/concepts/module-federation/)。\n\n## 動態載入 Web Component\n\n目前常見的 Web Component 套用方式是將該元件推至 registry，提供給其他開發者安裝，甚至會針對不同的前端框架進行封裝，進而讓使用各種框架的開發者都可以用更貼近框架的做法來使用這些元件。\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"web-component-for-framework.png\"\n  alt=\"Web Component For Framework\"\n/>\n\n在某些情境下，我們可能會希望以 **動態（Dynamic）** 的方式將 Web Component 載入至自己的系統內使用，甚至能夠永遠使用最新版的元件，在這種較極端的情境下，就要實作一套機制來達到動態載入的效果。\n\n### 流程設計\n\n以下是一個很簡單的實現流程：\n\n1. Web Component 編譯後的 Chunk 掛在 CDN 上\n2. 應用程式透過 API 或設定檔取得 Web Component 的 url\n3. 透過 Loader 將 Chunk 載入\n4. 使用 Web Component\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"web-component-dynamic-loader.png\"\n  alt=\"Web Component Dynamic Loader\"\n/>\n\n### 實作\n\n根據流程設計可以得知，動態載入 Web Component 的關鍵點在於取得 Web Component Chunk 的 url 並透過某種 Loader 來將該 Chunk 載入，這裡 **僅會針對這段進行實作，其餘細節將會省略**。\n\n> **NOTE**：以下實作會以 Angular 16 當作範例。\n\n為了簡化實作範疇，這裡採用設定檔的方式來設定 Web Component Chunk 的 url，Web Component 的 Chunk 也會放在 `assets` 資料夾內，以下是設定檔 `config.json` 的內容：\n```json\n{\n  \"webComponents\": [\n    {\n      \"id\": \"rainbow-block\",\n      \"source\": \"assets/webComponents/rainbow-block.js\"\n    }\n  ]\n}\n```\n設定檔內定義了 `webComponents`欄位告訴應用程式有哪些 Web Component 需要載入，資料結構為陣列，裡面每個元素會定義 `id` 與 `source` 來註記該 Web Component Chunk 的 `id` 與 url。\n\n設置完 `config.json` 後，在專案內建立 `web-component-dynamic-loader.service.ts` 來實現動態載入 Web Component：\n```typescript\n// ...\n@Injectable({ providedIn: 'root' })\nexport class WebComponentDynamicLoaderService {\n  // 注入 document\n  private readonly _document = inject(DOCUMENT);\n\n  load(id: string, source: string) {\n    const script = this._document.createElement('script');\n\n    // 如果相同的 Web Component Chunk 已經載入，則不須做任何事\n    if (this._document.getElementById(id)) {\n      return of(null);\n    }\n\n    script.src = source;\n    script.id = id;\n\n    this._document.head.appendChild(script);\n\n    // 聽 script 的 onload 事件\n    return fromEvent<null>(script, 'load').pipe(\n      map(() => null),\n      take(1)\n    );\n  }\n}\n```\n\n實作 `ConfigStore` 存放 `config.json` 的內容：\n```typescript\n// ...\nexport interface Config {\n  webComponents: { id: string; source: string }[];\n}\n\nconst isNotNull = <T>(config: T | null): config is NonNullable<T> =>\n  config !== null;\n\n@Injectable({ providedIn: 'root' })\nexport class ConfigStore {\n  private readonly _config$ = new BehaviorSubject<Config | null>(null);\n  readonly config$ = this._config$.pipe(filter(isNotNull));\n\n  private readonly httpClient = inject(HttpClient);\n\n  // 用於 APP_INITIALIZER\n  loadConfig() {\n    return () => {\n      return this.httpClient.get<Config>('assets/config.json').pipe(\n        tap((config) => {\n          this._config$.next(config);\n        })\n      );\n    };\n  }\n}\n```\n\n接著，在 `app.config.ts` 透過 `APP_INITIALIZER` 取得 `config.json` 的內容，並在此載入 Web Component：\n```typescript\n// ...\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    {\n      provide: APP_INITIALIZER,\n      useFactory: (configStore: ConfigStore) => {\n        // 載入 config.json 並存入 ConfigStore 裡\n        return configStore.loadConfig();\n      },\n      deps: [ConfigStore],\n      multi: true,\n    },\n    {\n      provide: APP_INITIALIZER,\n      useFactory: (\n        configStore: ConfigStore,\n        loader: WebComponentDynamicLoaderService\n      ) => {\n        return () => {\n          return configStore.config$.pipe(\n            take(1),\n            // 當 config.json 內容載入後，會根據設定內容來載入 Web Component Chunk\n            concatMap((config) => from(config.webComponents)),\n            mergeMap(({ id, source }) => loader.load(id, source)),\n            toArray()\n          );\n        };\n      },\n      deps: [ConfigStore, WebComponentDynamicLoaderService],\n      multi: true,\n    },\n    // ...\n  ],\n};\n```\n如此一來，便可以用動態的方式將 Web Component 載入。\n\n> **NOTE**：實作結果可以 clone [這個專案](https://github.com/hao0731/angular-dynamic-load-web-component)玩玩看。","slug":"0001-dynamic-load-web-component","published":1,"updated":"2023-09-10T12:47:59.398Z","comments":1,"layout":"post","photos":[],"_id":"cm9tztuvj0003fqgx1oan4apl","content":"<h2 id=\"什麼是-Web-Component？\"><a href=\"#什麼是-Web-Component？\" class=\"headerlink\" title=\"什麼是 Web Component？\"></a>什麼是 Web Component？</h2><p>Web Component 是一個封裝自定義元件的技術，讓我們可以輕易地在不同應用程式中重用這些被封裝的元件，<br>不僅如此，Web Component 不限定應用程式使用的框架或函式庫，不論今天是 Angular 或 React，甚至是 Vanilla JavaScript 都能夠輕鬆使用。</p>\n<blockquote>\n<p><strong>INFO</strong>：關於 Web Component 的詳細資訊可以參考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components\">MDN</a>。</p>\n</blockquote>\n<h2 id=\"為什麼需要-Web-Component？\"><a href=\"#為什麼需要-Web-Component？\" class=\"headerlink\" title=\"為什麼需要 Web Component？\"></a>為什麼需要 Web Component？</h2><p>Web Component 的問世，可以實現較理想的 <strong>微前端（Micro Frontend）</strong> 概念，在過去，會以 iframe 的形式將其他團隊開發的元件、頁面嵌入至自己的系統內來實現微前端，但這樣的做法會有很多的限制，比如：跨域、生命週期等。</p>\n<p>透過 Web Component 則可以避免這些問題，因為概念上就是將其他團隊開發的元件程式碼嵌入並串接至自己的系統裡。</p>\n<blockquote>\n<p><strong>NOTE</strong>：微前端也可以用 Module Federation 技術來實作，有興趣的話，可以參考<a href=\"https://webpack.js.org/concepts/module-federation/\">相關文件</a>。</p>\n</blockquote>\n<h2 id=\"動態載入-Web-Component\"><a href=\"#動態載入-Web-Component\" class=\"headerlink\" title=\"動態載入 Web Component\"></a>動態載入 Web Component</h2><p>目前常見的 Web Component 套用方式是將該元件推至 registry，提供給其他開發者安裝，甚至會針對不同的前端框架進行封裝，進而讓使用各種框架的開發者都可以用更貼近框架的做法來使用這些元件。</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"web-component-for-framework.png\"\n  alt=\"Web Component For Framework\"\n/></p>\n<p>在某些情境下，我們可能會希望以 <strong>動態（Dynamic）</strong> 的方式將 Web Component 載入至自己的系統內使用，甚至能夠永遠使用最新版的元件，在這種較極端的情境下，就要實作一套機制來達到動態載入的效果。</p>\n<h3 id=\"流程設計\"><a href=\"#流程設計\" class=\"headerlink\" title=\"流程設計\"></a>流程設計</h3><p>以下是一個很簡單的實現流程：</p>\n<ol>\n<li>Web Component 編譯後的 Chunk 掛在 CDN 上</li>\n<li>應用程式透過 API 或設定檔取得 Web Component 的 url</li>\n<li>透過 Loader 將 Chunk 載入</li>\n<li>使用 Web Component</li>\n</ol>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"web-component-dynamic-loader.png\"\n  alt=\"Web Component Dynamic Loader\"\n/></p>\n<h3 id=\"實作\"><a href=\"#實作\" class=\"headerlink\" title=\"實作\"></a>實作</h3><p>根據流程設計可以得知，動態載入 Web Component 的關鍵點在於取得 Web Component Chunk 的 url 並透過某種 Loader 來將該 Chunk 載入，這裡 <strong>僅會針對這段進行實作，其餘細節將會省略</strong>。</p>\n<blockquote>\n<p><strong>NOTE</strong>：以下實作會以 Angular 16 當作範例。</p>\n</blockquote>\n<p>為了簡化實作範疇，這裡採用設定檔的方式來設定 Web Component Chunk 的 url，Web Component 的 Chunk 也會放在 <code>assets</code> 資料夾內，以下是設定檔 <code>config.json</code> 的內容：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;webComponents&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;rainbow-block&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;source&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;assets/webComponents/rainbow-block.js&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>設定檔內定義了 <code>webComponents</code>欄位告訴應用程式有哪些 Web Component 需要載入，資料結構為陣列，裡面每個元素會定義 <code>id</code> 與 <code>source</code> 來註記該 Web Component Chunk 的 <code>id</code> 與 url。</p>\n<p>設置完 <code>config.json</code> 後，在專案內建立 <code>web-component-dynamic-loader.service.ts</code> 來實現動態載入 Web Component：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>(&#123; <span class=\"attr\">providedIn</span>: <span class=\"string\">&#x27;root&#x27;</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebComponentDynamicLoaderService</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 注入 document</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> _document = <span class=\"title function_\">inject</span>(<span class=\"variable constant_\">DOCUMENT</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">load</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">source</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> script = <span class=\"variable language_\">this</span>.<span class=\"property\">_document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;script&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果相同的 Web Component Chunk 已經載入，則不須做任何事</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">_document</span>.<span class=\"title function_\">getElementById</span>(id)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    script.<span class=\"property\">src</span> = source;</span><br><span class=\"line\">    script.<span class=\"property\">id</span> = id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_document</span>.<span class=\"property\">head</span>.<span class=\"title function_\">appendChild</span>(script);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 聽 script 的 onload 事件</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fromEvent&lt;<span class=\"literal\">null</span>&gt;(script, <span class=\"string\">&#x27;load&#x27;</span>).<span class=\"title function_\">pipe</span>(</span><br><span class=\"line\">      <span class=\"title function_\">map</span>(<span class=\"function\">() =&gt;</span> <span class=\"literal\">null</span>),</span><br><span class=\"line\">      <span class=\"title function_\">take</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>實作 <code>ConfigStore</code> 存放 <code>config.json</code> 的內容：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Config</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">webComponents</span>: &#123; <span class=\"attr\">id</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">source</span>: <span class=\"built_in\">string</span> &#125;[];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isNotNull = &lt;T&gt;(<span class=\"attr\">config</span>: T | <span class=\"literal\">null</span>): config is <span class=\"title class_\">NonNullable</span>&lt;T&gt; =&gt;</span><br><span class=\"line\">  config !== <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>(&#123; <span class=\"attr\">providedIn</span>: <span class=\"string\">&#x27;root&#x27;</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConfigStore</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> _config$ = <span class=\"keyword\">new</span> <span class=\"title class_\">BehaviorSubject</span>&lt;<span class=\"title class_\">Config</span> | <span class=\"literal\">null</span>&gt;(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> config$ = <span class=\"variable language_\">this</span>.<span class=\"property\">_config$</span>.<span class=\"title function_\">pipe</span>(<span class=\"title function_\">filter</span>(isNotNull));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> httpClient = <span class=\"title function_\">inject</span>(<span class=\"title class_\">HttpClient</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 用於 APP_INITIALIZER</span></span><br><span class=\"line\">  <span class=\"title function_\">loadConfig</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">httpClient</span>.<span class=\"property\">get</span>&lt;<span class=\"title class_\">Config</span>&gt;(<span class=\"string\">&#x27;assets/config.json&#x27;</span>).<span class=\"title function_\">pipe</span>(</span><br><span class=\"line\">        <span class=\"title function_\">tap</span>(<span class=\"function\">(<span class=\"params\">config</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">_config$</span>.<span class=\"title function_\">next</span>(config);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接著，在 <code>app.config.ts</code> 透過 <code>APP_INITIALIZER</code> 取得 <code>config.json</code> 的內容，並在此載入 Web Component：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">appConfig</span>: <span class=\"title class_\">ApplicationConfig</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">provide</span>: <span class=\"variable constant_\">APP_INITIALIZER</span>,</span><br><span class=\"line\">      <span class=\"attr\">useFactory</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">configStore</span>: <span class=\"title class_\">ConfigStore</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 載入 config.json 並存入 ConfigStore 裡</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> configStore.<span class=\"title function_\">loadConfig</span>();</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">deps</span>: [<span class=\"title class_\">ConfigStore</span>],</span><br><span class=\"line\">      <span class=\"attr\">multi</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">provide</span>: <span class=\"variable constant_\">APP_INITIALIZER</span>,</span><br><span class=\"line\">      <span class=\"attr\">useFactory</span>: <span class=\"function\">(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"attr\">configStore</span>: <span class=\"title class_\">ConfigStore</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"attr\">loader</span>: <span class=\"title class_\">WebComponentDynamicLoaderService</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      </span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> configStore.<span class=\"property\">config$</span>.<span class=\"title function_\">pipe</span>(</span><br><span class=\"line\">            <span class=\"title function_\">take</span>(<span class=\"number\">1</span>),</span><br><span class=\"line\">            <span class=\"comment\">// 當 config.json 內容載入後，會根據設定內容來載入 Web Component Chunk</span></span><br><span class=\"line\">            <span class=\"title function_\">concatMap</span>(<span class=\"function\">(<span class=\"params\">config</span>) =&gt;</span> <span class=\"title function_\">from</span>(config.<span class=\"property\">webComponents</span>)),</span><br><span class=\"line\">            <span class=\"title function_\">mergeMap</span>(<span class=\"function\">(<span class=\"params\">&#123; id, source &#125;</span>) =&gt;</span> loader.<span class=\"title function_\">load</span>(id, source)),</span><br><span class=\"line\">            <span class=\"title function_\">toArray</span>()</span><br><span class=\"line\">          );</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">deps</span>: [<span class=\"title class_\">ConfigStore</span>, <span class=\"title class_\">WebComponentDynamicLoaderService</span>],</span><br><span class=\"line\">      <span class=\"attr\">multi</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如此一來，便可以用動態的方式將 Web Component 載入。</p>\n<blockquote>\n<p><strong>NOTE</strong>：實作結果可以 clone <a href=\"https://github.com/hao0731/angular-dynamic-load-web-component\">這個專案</a>玩玩看。</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"什麼是-Web-Component？\"><a href=\"#什麼是-Web-Component？\" class=\"headerlink\" title=\"什麼是 Web Component？\"></a>什麼是 Web Component？</h2><p>Web Component 是一個封裝自定義元件的技術，讓我們可以輕易地在不同應用程式中重用這些被封裝的元件，<br>不僅如此，Web Component 不限定應用程式使用的框架或函式庫，不論今天是 Angular 或 React，甚至是 Vanilla JavaScript 都能夠輕鬆使用。</p>\n<blockquote>\n<p><strong>INFO</strong>：關於 Web Component 的詳細資訊可以參考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components\">MDN</a>。</p>\n</blockquote>\n<h2 id=\"為什麼需要-Web-Component？\"><a href=\"#為什麼需要-Web-Component？\" class=\"headerlink\" title=\"為什麼需要 Web Component？\"></a>為什麼需要 Web Component？</h2><p>Web Component 的問世，可以實現較理想的 <strong>微前端（Micro Frontend）</strong> 概念，在過去，會以 iframe 的形式將其他團隊開發的元件、頁面嵌入至自己的系統內來實現微前端，但這樣的做法會有很多的限制，比如：跨域、生命週期等。</p>\n<p>透過 Web Component 則可以避免這些問題，因為概念上就是將其他團隊開發的元件程式碼嵌入並串接至自己的系統裡。</p>\n<blockquote>\n<p><strong>NOTE</strong>：微前端也可以用 Module Federation 技術來實作，有興趣的話，可以參考<a href=\"https://webpack.js.org/concepts/module-federation/\">相關文件</a>。</p>\n</blockquote>\n<h2 id=\"動態載入-Web-Component\"><a href=\"#動態載入-Web-Component\" class=\"headerlink\" title=\"動態載入 Web Component\"></a>動態載入 Web Component</h2><p>目前常見的 Web Component 套用方式是將該元件推至 registry，提供給其他開發者安裝，甚至會針對不同的前端框架進行封裝，進而讓使用各種框架的開發者都可以用更貼近框架的做法來使用這些元件。</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"web-component-for-framework.png\"\n  alt=\"Web Component For Framework\"\n/></p>\n<p>在某些情境下，我們可能會希望以 <strong>動態（Dynamic）</strong> 的方式將 Web Component 載入至自己的系統內使用，甚至能夠永遠使用最新版的元件，在這種較極端的情境下，就要實作一套機制來達到動態載入的效果。</p>\n<h3 id=\"流程設計\"><a href=\"#流程設計\" class=\"headerlink\" title=\"流程設計\"></a>流程設計</h3><p>以下是一個很簡單的實現流程：</p>\n<ol>\n<li>Web Component 編譯後的 Chunk 掛在 CDN 上</li>\n<li>應用程式透過 API 或設定檔取得 Web Component 的 url</li>\n<li>透過 Loader 將 Chunk 載入</li>\n<li>使用 Web Component</li>\n</ol>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"web-component-dynamic-loader.png\"\n  alt=\"Web Component Dynamic Loader\"\n/></p>\n<h3 id=\"實作\"><a href=\"#實作\" class=\"headerlink\" title=\"實作\"></a>實作</h3><p>根據流程設計可以得知，動態載入 Web Component 的關鍵點在於取得 Web Component Chunk 的 url 並透過某種 Loader 來將該 Chunk 載入，這裡 <strong>僅會針對這段進行實作，其餘細節將會省略</strong>。</p>\n<blockquote>\n<p><strong>NOTE</strong>：以下實作會以 Angular 16 當作範例。</p>\n</blockquote>\n<p>為了簡化實作範疇，這裡採用設定檔的方式來設定 Web Component Chunk 的 url，Web Component 的 Chunk 也會放在 <code>assets</code> 資料夾內，以下是設定檔 <code>config.json</code> 的內容：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;webComponents&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;rainbow-block&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;source&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;assets/webComponents/rainbow-block.js&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>設定檔內定義了 <code>webComponents</code>欄位告訴應用程式有哪些 Web Component 需要載入，資料結構為陣列，裡面每個元素會定義 <code>id</code> 與 <code>source</code> 來註記該 Web Component Chunk 的 <code>id</code> 與 url。</p>\n<p>設置完 <code>config.json</code> 後，在專案內建立 <code>web-component-dynamic-loader.service.ts</code> 來實現動態載入 Web Component：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>(&#123; <span class=\"attr\">providedIn</span>: <span class=\"string\">&#x27;root&#x27;</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebComponentDynamicLoaderService</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 注入 document</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> _document = <span class=\"title function_\">inject</span>(<span class=\"variable constant_\">DOCUMENT</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">load</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">source</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> script = <span class=\"variable language_\">this</span>.<span class=\"property\">_document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;script&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果相同的 Web Component Chunk 已經載入，則不須做任何事</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">_document</span>.<span class=\"title function_\">getElementById</span>(id)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    script.<span class=\"property\">src</span> = source;</span><br><span class=\"line\">    script.<span class=\"property\">id</span> = id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_document</span>.<span class=\"property\">head</span>.<span class=\"title function_\">appendChild</span>(script);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 聽 script 的 onload 事件</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fromEvent&lt;<span class=\"literal\">null</span>&gt;(script, <span class=\"string\">&#x27;load&#x27;</span>).<span class=\"title function_\">pipe</span>(</span><br><span class=\"line\">      <span class=\"title function_\">map</span>(<span class=\"function\">() =&gt;</span> <span class=\"literal\">null</span>),</span><br><span class=\"line\">      <span class=\"title function_\">take</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>實作 <code>ConfigStore</code> 存放 <code>config.json</code> 的內容：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Config</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">webComponents</span>: &#123; <span class=\"attr\">id</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">source</span>: <span class=\"built_in\">string</span> &#125;[];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isNotNull = &lt;T&gt;(<span class=\"attr\">config</span>: T | <span class=\"literal\">null</span>): config is <span class=\"title class_\">NonNullable</span>&lt;T&gt; =&gt;</span><br><span class=\"line\">  config !== <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>(&#123; <span class=\"attr\">providedIn</span>: <span class=\"string\">&#x27;root&#x27;</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConfigStore</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> _config$ = <span class=\"keyword\">new</span> <span class=\"title class_\">BehaviorSubject</span>&lt;<span class=\"title class_\">Config</span> | <span class=\"literal\">null</span>&gt;(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> config$ = <span class=\"variable language_\">this</span>.<span class=\"property\">_config$</span>.<span class=\"title function_\">pipe</span>(<span class=\"title function_\">filter</span>(isNotNull));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> httpClient = <span class=\"title function_\">inject</span>(<span class=\"title class_\">HttpClient</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 用於 APP_INITIALIZER</span></span><br><span class=\"line\">  <span class=\"title function_\">loadConfig</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">httpClient</span>.<span class=\"property\">get</span>&lt;<span class=\"title class_\">Config</span>&gt;(<span class=\"string\">&#x27;assets/config.json&#x27;</span>).<span class=\"title function_\">pipe</span>(</span><br><span class=\"line\">        <span class=\"title function_\">tap</span>(<span class=\"function\">(<span class=\"params\">config</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">_config$</span>.<span class=\"title function_\">next</span>(config);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接著，在 <code>app.config.ts</code> 透過 <code>APP_INITIALIZER</code> 取得 <code>config.json</code> 的內容，並在此載入 Web Component：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">appConfig</span>: <span class=\"title class_\">ApplicationConfig</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">provide</span>: <span class=\"variable constant_\">APP_INITIALIZER</span>,</span><br><span class=\"line\">      <span class=\"attr\">useFactory</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">configStore</span>: <span class=\"title class_\">ConfigStore</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 載入 config.json 並存入 ConfigStore 裡</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> configStore.<span class=\"title function_\">loadConfig</span>();</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">deps</span>: [<span class=\"title class_\">ConfigStore</span>],</span><br><span class=\"line\">      <span class=\"attr\">multi</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">provide</span>: <span class=\"variable constant_\">APP_INITIALIZER</span>,</span><br><span class=\"line\">      <span class=\"attr\">useFactory</span>: <span class=\"function\">(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"attr\">configStore</span>: <span class=\"title class_\">ConfigStore</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"attr\">loader</span>: <span class=\"title class_\">WebComponentDynamicLoaderService</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      </span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> configStore.<span class=\"property\">config$</span>.<span class=\"title function_\">pipe</span>(</span><br><span class=\"line\">            <span class=\"title function_\">take</span>(<span class=\"number\">1</span>),</span><br><span class=\"line\">            <span class=\"comment\">// 當 config.json 內容載入後，會根據設定內容來載入 Web Component Chunk</span></span><br><span class=\"line\">            <span class=\"title function_\">concatMap</span>(<span class=\"function\">(<span class=\"params\">config</span>) =&gt;</span> <span class=\"title function_\">from</span>(config.<span class=\"property\">webComponents</span>)),</span><br><span class=\"line\">            <span class=\"title function_\">mergeMap</span>(<span class=\"function\">(<span class=\"params\">&#123; id, source &#125;</span>) =&gt;</span> loader.<span class=\"title function_\">load</span>(id, source)),</span><br><span class=\"line\">            <span class=\"title function_\">toArray</span>()</span><br><span class=\"line\">          );</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">deps</span>: [<span class=\"title class_\">ConfigStore</span>, <span class=\"title class_\">WebComponentDynamicLoaderService</span>],</span><br><span class=\"line\">      <span class=\"attr\">multi</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如此一來，便可以用動態的方式將 Web Component 載入。</p>\n<blockquote>\n<p><strong>NOTE</strong>：實作結果可以 clone <a href=\"https://github.com/hao0731/angular-dynamic-load-web-component\">這個專案</a>玩玩看。</p>\n</blockquote>\n"},{"title":"KrakenD 簡介","date":"2025-01-11T11:00:00.000Z","_content":"\n## 什麼是 KrakenD？\n\n[KrakenD](https://www.krakend.io/) 是一套開源、可擴充、高效能的 **API Gateway**，使用 [Golang](https://go.dev/) 所撰寫，透過 JSON 設定檔即可聚合多個微服務到單一 Endpoint，並能夠運用內建或社群提供的 **中介軟體(Middleware)** 來擴展其功能，自動完成部分繁重的工作，如：**聚合(Aggregate)**、**轉換(Transform)**、**過濾(Filter)**、**解碼(Decode)**、**節流(Throttle)**、**身份驗證(Authenticate)** 等。\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"krakend-flow.png\"\n  alt=\"KrakenD Flow Concept\"\n/>\n\n[圖片來源](https://www.krakend.io/docs/overview/)\n\n## 安裝 KrakenD\n\nKrakenD 有提供多種安裝方式，其中 Docker Image 的方式是最快、最容易的。透過下方指令即可將 KrakenD 的 Docker Image 從 Docker Hub 下載下來：\n\n```bash\n$ docker pull devopsfaith/krakend\n```\n\n使用下方指令即可快速啟動 KrakenD：\n\n```bash\n$ docker run -p 8080:8080 devopsfaith/krakend\n```\n\n啟動後，可以透過 `GET` 方法存取 [http://localhost:8080/__health](http://localhost:8080/__health) 來取得 KrakenD 的健康狀態，如果有收到下方回應就表示啟動成功：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"health-check-result.png\"\n  alt=\"Health Check Result\"\n/>\n\n這時可能會有些疑問，前面提到 KrakenD 是透過 JSON 設定檔來建立 Endpoint 的，但剛剛的步驟中沒有撰寫到任何的 JSON 卻可以順利啟動 KrakenD？原因是 KrakenD 預設狀況下會去讀取 `/etc/krakend` 路徑下的 `krakend.json`，當我們沒有透過 [Docker Volume](https://docs.docker.com/engine/storage/volumes/) 的方式將實體主機上檔案 mapping 到 container 內部時，預設會使用最基礎的 `krakend.json` 來啟動 KrakenD。\n\n## 認識 KrakenD 指令\n\n上述快速啟動 KrakenD 的方式，其實是該 Image 預設會執行 KrakenD 的 `run` 指令，那麼我們要如何完整的使用 KrakenD 所提供的指令與參數呢？我們可以透過下方指令執行 `help` 來查看 KrakenD 提供了哪些指令與參數：\n\n```bash\n$ docker run --rm -it devopsfaith/krakend help\n```\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"krakend-help.png\"\n  alt=\"KrakenD Help\"\n/>\n\n從上圖可以看到共有以下幾個指令：\n\n* `audit`：檢查設定檔是否存在安全性風險。\n* `check`：檢查設定檔的格式、屬性等是合法的。\n* `check-plugin`：如果有自訂 **插件(Plugin)** 的話，可以透過這個指令來檢查是否與 KrakenD 相容。\n* `help`：查看 KrakenD 提供了哪些指令與參數。\n* `run`：啟動服務。\n* `test-plugin`：測試 Plugin 是否能夠被 KrakenD 載入。\n* `version`：顯示 KrakenD 版本以及編譯時使用的 Glibc 與 Golang 版本。\n\n> **NOTE**：上述指令中，大部分都需要更深入了解 KrakenD 才能理解其用途，之後介紹到相對應的功能時，會做更詳細的說明。\n\n## 認識設定檔\n\n前面有提到 KrakenD 會需要 `krakend.json` 才能啟動，這個設定檔最簡單的設置如下：\n\n```json\n{\n  \"version\": 3\n}\n```\n\n`version` 表示 **設定檔的版本**，與 KrakenD 版本不同，但每個設定檔版本都有 KrakenD 支援的版本區間：\n\n* `3`：目前最新版本，只要 KrakenD 在 `v2.0` 以上就可以使用。\n* `2`：在 2022 時棄用，KrakenD 版本在 `v0.4` 到 `v1.4.1` 時使用。\n* `1`：在 2016 時棄用，KrakenD 版本在 `v0.3.9` 以下時使用。\n\n實務上，我們不會只有一個 `version` 在設定檔內，這樣啟動後的 KrakenD 也沒有發揮 API Gateway 的功能。一個設定檔的主要結構如下：\n\n```json\n{\n  \"$schema\": \"https://www.krakend.io/schema/v2.8/krakend.json\",\n  \"version\": 3,\n  \"endpoints\": [],\n  \"extra_config\": {}\n}\n```\n\n上方可以看到多了三個屬性：\n\n* `$schema`：套用 KrakenD 提供的 JSON Schema，這樣可以與編輯器做整合，在撰寫該設定檔時，能夠有更多的提示訊息。此項目雖然不是必要的，但非常建議添加。\n* `endpoints`：定義 API 的設定。\n* `extra_config`：擴展 KrakenD 的元件設定。\n\n### endpoints 基礎介紹\n\n`endpoints` 可說是 KrakenD 最重要的設定，因為它會用來定義 KrakenD 要提供哪些 API 給使用者以及該 API 背後對應的服務是哪些。`endpoints` 內每個物件都是一個 API 的定義，下方是一個代理 Todo API 的設定：\n\n```json\n{\n  // ...\n  \"endpoints\": [\n    {\n      \"endpoint\": \"/api/todos\",\n      \"output_encoding\": \"no-op\",\n      \"backend\": [\n        {\n          \"host\": [\"https://jsonplaceholder.typicode.com\"],\n          \"url_pattern\": \"/todos\",\n          \"method\": \"GET\",\n          \"encoding\": \"no-op\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n上方的設定表示會代理 `https://jsonplaceholder.typicode.com/todos` 這個 API，使用者只需要用 `GET` 方法存取 [http://localhost:8080/api/todos](http://localhost:8080/api/todos) 即可獲得該 API 的結果。\n\n### extra_config 基礎介紹\n\n`extra_config` 主要是負責針對各式 Plugin 進行設定，每個 Plugin 都會有一個獨一無二的 **命名空間(Namespace)**，KrakenD 會在啟動時註冊 Plugin 並從 `extra_config` 找出對應名稱的設定，再將該設定內容傳遞給 Plugin。下方是擴展 Log 的 `extra_config` 設定：\n\n```json\n{\n  // ...\n    \"extra_config\": {\n      \"telemetry/logging\": {\n        \"level\": \"WARNING\",\n        \"prefix\": \"[KRAKEND]\",\n        \"stdout\": true\n      }\n  }\n}\n```\n\n> **NOTE**：有關 `telemetry/logging` 的介紹後續有機會再跟大家分享。\n\n`extra_config` 不僅可以出現在設定檔的根層級，也可以出現在其他層級，放的層級越深，作用的範圍就越小，而實際放置位置取決於 Plugin 的用途與性質。下方是 `extra_config` 可以設置的層級：\n\n* `service`：服務層級，也就是與 `endpoints` 相同層級的位置。這個層級會影響整個 KrakenD 以及所有請求。\n* `endpoint`：Endpoint 層級，指的是 `endpoints` 中的物件。影響範圍僅限於該 API Endpoint。\n* `backend`：Backend 層級，指的是 `backends` 中的物件。影響範圍僅限於該 Backend。\n\n## 小品練習\n\n首先，建立一個資料夾 `src` 並同時在該資料夾下新增 `krakend.json`：\n\n```json\n{\n  \"$schema\": \"https://www.krakend.io/schema/v2.8/krakend.json\",\n  \"version\": 3,\n  \"endpoints\": [\n    {\n      \"endpoint\": \"/api/todos\",\n      \"output_encoding\": \"no-op\",\n      \"backend\": [\n        {\n          \"host\": [\"https://jsonplaceholder.typicode.com\"],\n          \"url_pattern\": \"/todos\",\n          \"method\": \"GET\",\n          \"encoding\": \"no-op\"\n        }\n      ]\n    }\n  ],\n  \"extra_config\": {\n    \"telemetry/logging\": {\n      \"level\": \"WARNING\",\n      \"prefix\": \"[KRAKEND]\",\n      \"stdout\": true\n    }\n  }\n}\n```\n\n接著，透過下方指令以 Docker Volume 的方式將 `src` 資料夾 mapping 至 `/etc/krakend`，同時透過 `-c` 參數指定使用 `krakend.json` 作為設定檔：\n\n```bash\n$ docker run -p 8080:8080 -v $PWD/src:/etc/krakend devopsfaith/krakend run -c krakend.json\n```\n\n透過 Postman 以 `GET` 方法存取 [http://localhost:8080/api/todos](http://localhost:8080/api/todos)，可以順利拿到來自 `https://jsonplaceholder.typicode.com/todos` 的資料：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"krakend-result.png\"\n  alt=\"KrakenD Result\"\n/>\n\n## 結論\n\n今天簡單介紹了 KrakenD 以及啟動的方式，對於設定檔也有了初步的了解。後續會再針對設定檔的細節做更詳細的解說。","source":"_posts/0003-what-is-krakend.md","raw":"---\ntitle: KrakenD 簡介\ndate: 2025-01-11 19:00:00\ntags:\n  - Backend\n  - APIGateway\n  - KrakenD\ncategories:\n  - ['Backend', 'KrakenD']\n---\n\n## 什麼是 KrakenD？\n\n[KrakenD](https://www.krakend.io/) 是一套開源、可擴充、高效能的 **API Gateway**，使用 [Golang](https://go.dev/) 所撰寫，透過 JSON 設定檔即可聚合多個微服務到單一 Endpoint，並能夠運用內建或社群提供的 **中介軟體(Middleware)** 來擴展其功能，自動完成部分繁重的工作，如：**聚合(Aggregate)**、**轉換(Transform)**、**過濾(Filter)**、**解碼(Decode)**、**節流(Throttle)**、**身份驗證(Authenticate)** 等。\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"krakend-flow.png\"\n  alt=\"KrakenD Flow Concept\"\n/>\n\n[圖片來源](https://www.krakend.io/docs/overview/)\n\n## 安裝 KrakenD\n\nKrakenD 有提供多種安裝方式，其中 Docker Image 的方式是最快、最容易的。透過下方指令即可將 KrakenD 的 Docker Image 從 Docker Hub 下載下來：\n\n```bash\n$ docker pull devopsfaith/krakend\n```\n\n使用下方指令即可快速啟動 KrakenD：\n\n```bash\n$ docker run -p 8080:8080 devopsfaith/krakend\n```\n\n啟動後，可以透過 `GET` 方法存取 [http://localhost:8080/__health](http://localhost:8080/__health) 來取得 KrakenD 的健康狀態，如果有收到下方回應就表示啟動成功：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"health-check-result.png\"\n  alt=\"Health Check Result\"\n/>\n\n這時可能會有些疑問，前面提到 KrakenD 是透過 JSON 設定檔來建立 Endpoint 的，但剛剛的步驟中沒有撰寫到任何的 JSON 卻可以順利啟動 KrakenD？原因是 KrakenD 預設狀況下會去讀取 `/etc/krakend` 路徑下的 `krakend.json`，當我們沒有透過 [Docker Volume](https://docs.docker.com/engine/storage/volumes/) 的方式將實體主機上檔案 mapping 到 container 內部時，預設會使用最基礎的 `krakend.json` 來啟動 KrakenD。\n\n## 認識 KrakenD 指令\n\n上述快速啟動 KrakenD 的方式，其實是該 Image 預設會執行 KrakenD 的 `run` 指令，那麼我們要如何完整的使用 KrakenD 所提供的指令與參數呢？我們可以透過下方指令執行 `help` 來查看 KrakenD 提供了哪些指令與參數：\n\n```bash\n$ docker run --rm -it devopsfaith/krakend help\n```\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"krakend-help.png\"\n  alt=\"KrakenD Help\"\n/>\n\n從上圖可以看到共有以下幾個指令：\n\n* `audit`：檢查設定檔是否存在安全性風險。\n* `check`：檢查設定檔的格式、屬性等是合法的。\n* `check-plugin`：如果有自訂 **插件(Plugin)** 的話，可以透過這個指令來檢查是否與 KrakenD 相容。\n* `help`：查看 KrakenD 提供了哪些指令與參數。\n* `run`：啟動服務。\n* `test-plugin`：測試 Plugin 是否能夠被 KrakenD 載入。\n* `version`：顯示 KrakenD 版本以及編譯時使用的 Glibc 與 Golang 版本。\n\n> **NOTE**：上述指令中，大部分都需要更深入了解 KrakenD 才能理解其用途，之後介紹到相對應的功能時，會做更詳細的說明。\n\n## 認識設定檔\n\n前面有提到 KrakenD 會需要 `krakend.json` 才能啟動，這個設定檔最簡單的設置如下：\n\n```json\n{\n  \"version\": 3\n}\n```\n\n`version` 表示 **設定檔的版本**，與 KrakenD 版本不同，但每個設定檔版本都有 KrakenD 支援的版本區間：\n\n* `3`：目前最新版本，只要 KrakenD 在 `v2.0` 以上就可以使用。\n* `2`：在 2022 時棄用，KrakenD 版本在 `v0.4` 到 `v1.4.1` 時使用。\n* `1`：在 2016 時棄用，KrakenD 版本在 `v0.3.9` 以下時使用。\n\n實務上，我們不會只有一個 `version` 在設定檔內，這樣啟動後的 KrakenD 也沒有發揮 API Gateway 的功能。一個設定檔的主要結構如下：\n\n```json\n{\n  \"$schema\": \"https://www.krakend.io/schema/v2.8/krakend.json\",\n  \"version\": 3,\n  \"endpoints\": [],\n  \"extra_config\": {}\n}\n```\n\n上方可以看到多了三個屬性：\n\n* `$schema`：套用 KrakenD 提供的 JSON Schema，這樣可以與編輯器做整合，在撰寫該設定檔時，能夠有更多的提示訊息。此項目雖然不是必要的，但非常建議添加。\n* `endpoints`：定義 API 的設定。\n* `extra_config`：擴展 KrakenD 的元件設定。\n\n### endpoints 基礎介紹\n\n`endpoints` 可說是 KrakenD 最重要的設定，因為它會用來定義 KrakenD 要提供哪些 API 給使用者以及該 API 背後對應的服務是哪些。`endpoints` 內每個物件都是一個 API 的定義，下方是一個代理 Todo API 的設定：\n\n```json\n{\n  // ...\n  \"endpoints\": [\n    {\n      \"endpoint\": \"/api/todos\",\n      \"output_encoding\": \"no-op\",\n      \"backend\": [\n        {\n          \"host\": [\"https://jsonplaceholder.typicode.com\"],\n          \"url_pattern\": \"/todos\",\n          \"method\": \"GET\",\n          \"encoding\": \"no-op\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n上方的設定表示會代理 `https://jsonplaceholder.typicode.com/todos` 這個 API，使用者只需要用 `GET` 方法存取 [http://localhost:8080/api/todos](http://localhost:8080/api/todos) 即可獲得該 API 的結果。\n\n### extra_config 基礎介紹\n\n`extra_config` 主要是負責針對各式 Plugin 進行設定，每個 Plugin 都會有一個獨一無二的 **命名空間(Namespace)**，KrakenD 會在啟動時註冊 Plugin 並從 `extra_config` 找出對應名稱的設定，再將該設定內容傳遞給 Plugin。下方是擴展 Log 的 `extra_config` 設定：\n\n```json\n{\n  // ...\n    \"extra_config\": {\n      \"telemetry/logging\": {\n        \"level\": \"WARNING\",\n        \"prefix\": \"[KRAKEND]\",\n        \"stdout\": true\n      }\n  }\n}\n```\n\n> **NOTE**：有關 `telemetry/logging` 的介紹後續有機會再跟大家分享。\n\n`extra_config` 不僅可以出現在設定檔的根層級，也可以出現在其他層級，放的層級越深，作用的範圍就越小，而實際放置位置取決於 Plugin 的用途與性質。下方是 `extra_config` 可以設置的層級：\n\n* `service`：服務層級，也就是與 `endpoints` 相同層級的位置。這個層級會影響整個 KrakenD 以及所有請求。\n* `endpoint`：Endpoint 層級，指的是 `endpoints` 中的物件。影響範圍僅限於該 API Endpoint。\n* `backend`：Backend 層級，指的是 `backends` 中的物件。影響範圍僅限於該 Backend。\n\n## 小品練習\n\n首先，建立一個資料夾 `src` 並同時在該資料夾下新增 `krakend.json`：\n\n```json\n{\n  \"$schema\": \"https://www.krakend.io/schema/v2.8/krakend.json\",\n  \"version\": 3,\n  \"endpoints\": [\n    {\n      \"endpoint\": \"/api/todos\",\n      \"output_encoding\": \"no-op\",\n      \"backend\": [\n        {\n          \"host\": [\"https://jsonplaceholder.typicode.com\"],\n          \"url_pattern\": \"/todos\",\n          \"method\": \"GET\",\n          \"encoding\": \"no-op\"\n        }\n      ]\n    }\n  ],\n  \"extra_config\": {\n    \"telemetry/logging\": {\n      \"level\": \"WARNING\",\n      \"prefix\": \"[KRAKEND]\",\n      \"stdout\": true\n    }\n  }\n}\n```\n\n接著，透過下方指令以 Docker Volume 的方式將 `src` 資料夾 mapping 至 `/etc/krakend`，同時透過 `-c` 參數指定使用 `krakend.json` 作為設定檔：\n\n```bash\n$ docker run -p 8080:8080 -v $PWD/src:/etc/krakend devopsfaith/krakend run -c krakend.json\n```\n\n透過 Postman 以 `GET` 方法存取 [http://localhost:8080/api/todos](http://localhost:8080/api/todos)，可以順利拿到來自 `https://jsonplaceholder.typicode.com/todos` 的資料：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"krakend-result.png\"\n  alt=\"KrakenD Result\"\n/>\n\n## 結論\n\n今天簡單介紹了 KrakenD 以及啟動的方式，對於設定檔也有了初步的了解。後續會再針對設定檔的細節做更詳細的解說。","slug":"0003-what-is-krakend","published":1,"updated":"2025-01-11T11:40:13.352Z","comments":1,"layout":"post","photos":[],"_id":"cm9tztuvn0006fqgxdrg05uhh","content":"<h2 id=\"什麼是-KrakenD？\"><a href=\"#什麼是-KrakenD？\" class=\"headerlink\" title=\"什麼是 KrakenD？\"></a>什麼是 KrakenD？</h2><p><a href=\"https://www.krakend.io/\">KrakenD</a> 是一套開源、可擴充、高效能的 <strong>API Gateway</strong>，使用 <a href=\"https://go.dev/\">Golang</a> 所撰寫，透過 JSON 設定檔即可聚合多個微服務到單一 Endpoint，並能夠運用內建或社群提供的 <strong>中介軟體(Middleware)</strong> 來擴展其功能，自動完成部分繁重的工作，如：<strong>聚合(Aggregate)</strong>、<strong>轉換(Transform)</strong>、<strong>過濾(Filter)</strong>、<strong>解碼(Decode)</strong>、<strong>節流(Throttle)</strong>、<strong>身份驗證(Authenticate)</strong> 等。</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"krakend-flow.png\"\n  alt=\"KrakenD Flow Concept\"\n/></p>\n<p><a href=\"https://www.krakend.io/docs/overview/\">圖片來源</a></p>\n<h2 id=\"安裝-KrakenD\"><a href=\"#安裝-KrakenD\" class=\"headerlink\" title=\"安裝 KrakenD\"></a>安裝 KrakenD</h2><p>KrakenD 有提供多種安裝方式，其中 Docker Image 的方式是最快、最容易的。透過下方指令即可將 KrakenD 的 Docker Image 從 Docker Hub 下載下來：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull devopsfaith/krakend</span><br></pre></td></tr></table></figure>\n\n<p>使用下方指令即可快速啟動 KrakenD：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -p 8080:8080 devopsfaith/krakend</span><br></pre></td></tr></table></figure>\n\n<p>啟動後，可以透過 <code>GET</code> 方法存取 <a href=\"http://localhost:8080/__health\">http://localhost:8080/__health</a> 來取得 KrakenD 的健康狀態，如果有收到下方回應就表示啟動成功：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"health-check-result.png\"\n  alt=\"Health Check Result\"\n/></p>\n<p>這時可能會有些疑問，前面提到 KrakenD 是透過 JSON 設定檔來建立 Endpoint 的，但剛剛的步驟中沒有撰寫到任何的 JSON 卻可以順利啟動 KrakenD？原因是 KrakenD 預設狀況下會去讀取 <code>/etc/krakend</code> 路徑下的 <code>krakend.json</code>，當我們沒有透過 <a href=\"https://docs.docker.com/engine/storage/volumes/\">Docker Volume</a> 的方式將實體主機上檔案 mapping 到 container 內部時，預設會使用最基礎的 <code>krakend.json</code> 來啟動 KrakenD。</p>\n<h2 id=\"認識-KrakenD-指令\"><a href=\"#認識-KrakenD-指令\" class=\"headerlink\" title=\"認識 KrakenD 指令\"></a>認識 KrakenD 指令</h2><p>上述快速啟動 KrakenD 的方式，其實是該 Image 預設會執行 KrakenD 的 <code>run</code> 指令，那麼我們要如何完整的使用 KrakenD 所提供的指令與參數呢？我們可以透過下方指令執行 <code>help</code> 來查看 KrakenD 提供了哪些指令與參數：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --<span class=\"built_in\">rm</span> -it devopsfaith/krakend <span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"krakend-help.png\"\n  alt=\"KrakenD Help\"\n/></p>\n<p>從上圖可以看到共有以下幾個指令：</p>\n<ul>\n<li><code>audit</code>：檢查設定檔是否存在安全性風險。</li>\n<li><code>check</code>：檢查設定檔的格式、屬性等是合法的。</li>\n<li><code>check-plugin</code>：如果有自訂 <strong>插件(Plugin)</strong> 的話，可以透過這個指令來檢查是否與 KrakenD 相容。</li>\n<li><code>help</code>：查看 KrakenD 提供了哪些指令與參數。</li>\n<li><code>run</code>：啟動服務。</li>\n<li><code>test-plugin</code>：測試 Plugin 是否能夠被 KrakenD 載入。</li>\n<li><code>version</code>：顯示 KrakenD 版本以及編譯時使用的 Glibc 與 Golang 版本。</li>\n</ul>\n<blockquote>\n<p><strong>NOTE</strong>：上述指令中，大部分都需要更深入了解 KrakenD 才能理解其用途，之後介紹到相對應的功能時，會做更詳細的說明。</p>\n</blockquote>\n<h2 id=\"認識設定檔\"><a href=\"#認識設定檔\" class=\"headerlink\" title=\"認識設定檔\"></a>認識設定檔</h2><p>前面有提到 KrakenD 會需要 <code>krakend.json</code> 才能啟動，這個設定檔最簡單的設置如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>version</code> 表示 <strong>設定檔的版本</strong>，與 KrakenD 版本不同，但每個設定檔版本都有 KrakenD 支援的版本區間：</p>\n<ul>\n<li><code>3</code>：目前最新版本，只要 KrakenD 在 <code>v2.0</code> 以上就可以使用。</li>\n<li><code>2</code>：在 2022 時棄用，KrakenD 版本在 <code>v0.4</code> 到 <code>v1.4.1</code> 時使用。</li>\n<li><code>1</code>：在 2016 時棄用，KrakenD 版本在 <code>v0.3.9</code> 以下時使用。</li>\n</ul>\n<p>實務上，我們不會只有一個 <code>version</code> 在設定檔內，這樣啟動後的 KrakenD 也沒有發揮 API Gateway 的功能。一個設定檔的主要結構如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;$schema&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://www.krakend.io/schema/v2.8/krakend.json&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;endpoints&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;extra_config&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上方可以看到多了三個屬性：</p>\n<ul>\n<li><code>$schema</code>：套用 KrakenD 提供的 JSON Schema，這樣可以與編輯器做整合，在撰寫該設定檔時，能夠有更多的提示訊息。此項目雖然不是必要的，但非常建議添加。</li>\n<li><code>endpoints</code>：定義 API 的設定。</li>\n<li><code>extra_config</code>：擴展 KrakenD 的元件設定。</li>\n</ul>\n<h3 id=\"endpoints-基礎介紹\"><a href=\"#endpoints-基礎介紹\" class=\"headerlink\" title=\"endpoints 基礎介紹\"></a>endpoints 基礎介紹</h3><p><code>endpoints</code> 可說是 KrakenD 最重要的設定，因為它會用來定義 KrakenD 要提供哪些 API 給使用者以及該 API 背後對應的服務是哪些。<code>endpoints</code> 內每個物件都是一個 API 的定義，下方是一個代理 Todo API 的設定：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;endpoints&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;endpoint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/api/todos&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;output_encoding&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;no-op&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;backend&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;host&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;https://jsonplaceholder.typicode.com&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;url_pattern&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/todos&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;method&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;GET&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;encoding&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;no-op&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">      <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上方的設定表示會代理 <code>https://jsonplaceholder.typicode.com/todos</code> 這個 API，使用者只需要用 <code>GET</code> 方法存取 <a href=\"http://localhost:8080/api/todos\">http://localhost:8080/api/todos</a> 即可獲得該 API 的結果。</p>\n<h3 id=\"extra-config-基礎介紹\"><a href=\"#extra-config-基礎介紹\" class=\"headerlink\" title=\"extra_config 基礎介紹\"></a>extra_config 基礎介紹</h3><p><code>extra_config</code> 主要是負責針對各式 Plugin 進行設定，每個 Plugin 都會有一個獨一無二的 <strong>命名空間(Namespace)</strong>，KrakenD 會在啟動時註冊 Plugin 並從 <code>extra_config</code> 找出對應名稱的設定，再將該設定內容傳遞給 Plugin。下方是擴展 Log 的 <code>extra_config</code> 設定：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;extra_config&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;telemetry/logging&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;level&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;WARNING&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;prefix&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;[KRAKEND]&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;stdout&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>NOTE</strong>：有關 <code>telemetry/logging</code> 的介紹後續有機會再跟大家分享。</p>\n</blockquote>\n<p><code>extra_config</code> 不僅可以出現在設定檔的根層級，也可以出現在其他層級，放的層級越深，作用的範圍就越小，而實際放置位置取決於 Plugin 的用途與性質。下方是 <code>extra_config</code> 可以設置的層級：</p>\n<ul>\n<li><code>service</code>：服務層級，也就是與 <code>endpoints</code> 相同層級的位置。這個層級會影響整個 KrakenD 以及所有請求。</li>\n<li><code>endpoint</code>：Endpoint 層級，指的是 <code>endpoints</code> 中的物件。影響範圍僅限於該 API Endpoint。</li>\n<li><code>backend</code>：Backend 層級，指的是 <code>backends</code> 中的物件。影響範圍僅限於該 Backend。</li>\n</ul>\n<h2 id=\"小品練習\"><a href=\"#小品練習\" class=\"headerlink\" title=\"小品練習\"></a>小品練習</h2><p>首先，建立一個資料夾 <code>src</code> 並同時在該資料夾下新增 <code>krakend.json</code>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;$schema&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://www.krakend.io/schema/v2.8/krakend.json&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;endpoints&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;endpoint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/api/todos&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;output_encoding&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;no-op&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;backend&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;host&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;https://jsonplaceholder.typicode.com&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;url_pattern&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/todos&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;method&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;GET&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;encoding&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;no-op&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">      <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;extra_config&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;telemetry/logging&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;level&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;WARNING&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;prefix&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;[KRAKEND]&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;stdout&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>接著，透過下方指令以 Docker Volume 的方式將 <code>src</code> 資料夾 mapping 至 <code>/etc/krakend</code>，同時透過 <code>-c</code> 參數指定使用 <code>krakend.json</code> 作為設定檔：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -p 8080:8080 -v <span class=\"variable\">$PWD</span>/src:/etc/krakend devopsfaith/krakend run -c krakend.json</span><br></pre></td></tr></table></figure>\n\n<p>透過 Postman 以 <code>GET</code> 方法存取 <a href=\"http://localhost:8080/api/todos\">http://localhost:8080/api/todos</a>，可以順利拿到來自 <code>https://jsonplaceholder.typicode.com/todos</code> 的資料：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"krakend-result.png\"\n  alt=\"KrakenD Result\"\n/></p>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>今天簡單介紹了 KrakenD 以及啟動的方式，對於設定檔也有了初步的了解。後續會再針對設定檔的細節做更詳細的解說。</p>\n","excerpt":"","more":"<h2 id=\"什麼是-KrakenD？\"><a href=\"#什麼是-KrakenD？\" class=\"headerlink\" title=\"什麼是 KrakenD？\"></a>什麼是 KrakenD？</h2><p><a href=\"https://www.krakend.io/\">KrakenD</a> 是一套開源、可擴充、高效能的 <strong>API Gateway</strong>，使用 <a href=\"https://go.dev/\">Golang</a> 所撰寫，透過 JSON 設定檔即可聚合多個微服務到單一 Endpoint，並能夠運用內建或社群提供的 <strong>中介軟體(Middleware)</strong> 來擴展其功能，自動完成部分繁重的工作，如：<strong>聚合(Aggregate)</strong>、<strong>轉換(Transform)</strong>、<strong>過濾(Filter)</strong>、<strong>解碼(Decode)</strong>、<strong>節流(Throttle)</strong>、<strong>身份驗證(Authenticate)</strong> 等。</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"krakend-flow.png\"\n  alt=\"KrakenD Flow Concept\"\n/></p>\n<p><a href=\"https://www.krakend.io/docs/overview/\">圖片來源</a></p>\n<h2 id=\"安裝-KrakenD\"><a href=\"#安裝-KrakenD\" class=\"headerlink\" title=\"安裝 KrakenD\"></a>安裝 KrakenD</h2><p>KrakenD 有提供多種安裝方式，其中 Docker Image 的方式是最快、最容易的。透過下方指令即可將 KrakenD 的 Docker Image 從 Docker Hub 下載下來：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull devopsfaith/krakend</span><br></pre></td></tr></table></figure>\n\n<p>使用下方指令即可快速啟動 KrakenD：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -p 8080:8080 devopsfaith/krakend</span><br></pre></td></tr></table></figure>\n\n<p>啟動後，可以透過 <code>GET</code> 方法存取 <a href=\"http://localhost:8080/__health\">http://localhost:8080/__health</a> 來取得 KrakenD 的健康狀態，如果有收到下方回應就表示啟動成功：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"health-check-result.png\"\n  alt=\"Health Check Result\"\n/></p>\n<p>這時可能會有些疑問，前面提到 KrakenD 是透過 JSON 設定檔來建立 Endpoint 的，但剛剛的步驟中沒有撰寫到任何的 JSON 卻可以順利啟動 KrakenD？原因是 KrakenD 預設狀況下會去讀取 <code>/etc/krakend</code> 路徑下的 <code>krakend.json</code>，當我們沒有透過 <a href=\"https://docs.docker.com/engine/storage/volumes/\">Docker Volume</a> 的方式將實體主機上檔案 mapping 到 container 內部時，預設會使用最基礎的 <code>krakend.json</code> 來啟動 KrakenD。</p>\n<h2 id=\"認識-KrakenD-指令\"><a href=\"#認識-KrakenD-指令\" class=\"headerlink\" title=\"認識 KrakenD 指令\"></a>認識 KrakenD 指令</h2><p>上述快速啟動 KrakenD 的方式，其實是該 Image 預設會執行 KrakenD 的 <code>run</code> 指令，那麼我們要如何完整的使用 KrakenD 所提供的指令與參數呢？我們可以透過下方指令執行 <code>help</code> 來查看 KrakenD 提供了哪些指令與參數：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --<span class=\"built_in\">rm</span> -it devopsfaith/krakend <span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"krakend-help.png\"\n  alt=\"KrakenD Help\"\n/></p>\n<p>從上圖可以看到共有以下幾個指令：</p>\n<ul>\n<li><code>audit</code>：檢查設定檔是否存在安全性風險。</li>\n<li><code>check</code>：檢查設定檔的格式、屬性等是合法的。</li>\n<li><code>check-plugin</code>：如果有自訂 <strong>插件(Plugin)</strong> 的話，可以透過這個指令來檢查是否與 KrakenD 相容。</li>\n<li><code>help</code>：查看 KrakenD 提供了哪些指令與參數。</li>\n<li><code>run</code>：啟動服務。</li>\n<li><code>test-plugin</code>：測試 Plugin 是否能夠被 KrakenD 載入。</li>\n<li><code>version</code>：顯示 KrakenD 版本以及編譯時使用的 Glibc 與 Golang 版本。</li>\n</ul>\n<blockquote>\n<p><strong>NOTE</strong>：上述指令中，大部分都需要更深入了解 KrakenD 才能理解其用途，之後介紹到相對應的功能時，會做更詳細的說明。</p>\n</blockquote>\n<h2 id=\"認識設定檔\"><a href=\"#認識設定檔\" class=\"headerlink\" title=\"認識設定檔\"></a>認識設定檔</h2><p>前面有提到 KrakenD 會需要 <code>krakend.json</code> 才能啟動，這個設定檔最簡單的設置如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>version</code> 表示 <strong>設定檔的版本</strong>，與 KrakenD 版本不同，但每個設定檔版本都有 KrakenD 支援的版本區間：</p>\n<ul>\n<li><code>3</code>：目前最新版本，只要 KrakenD 在 <code>v2.0</code> 以上就可以使用。</li>\n<li><code>2</code>：在 2022 時棄用，KrakenD 版本在 <code>v0.4</code> 到 <code>v1.4.1</code> 時使用。</li>\n<li><code>1</code>：在 2016 時棄用，KrakenD 版本在 <code>v0.3.9</code> 以下時使用。</li>\n</ul>\n<p>實務上，我們不會只有一個 <code>version</code> 在設定檔內，這樣啟動後的 KrakenD 也沒有發揮 API Gateway 的功能。一個設定檔的主要結構如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;$schema&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://www.krakend.io/schema/v2.8/krakend.json&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;endpoints&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;extra_config&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上方可以看到多了三個屬性：</p>\n<ul>\n<li><code>$schema</code>：套用 KrakenD 提供的 JSON Schema，這樣可以與編輯器做整合，在撰寫該設定檔時，能夠有更多的提示訊息。此項目雖然不是必要的，但非常建議添加。</li>\n<li><code>endpoints</code>：定義 API 的設定。</li>\n<li><code>extra_config</code>：擴展 KrakenD 的元件設定。</li>\n</ul>\n<h3 id=\"endpoints-基礎介紹\"><a href=\"#endpoints-基礎介紹\" class=\"headerlink\" title=\"endpoints 基礎介紹\"></a>endpoints 基礎介紹</h3><p><code>endpoints</code> 可說是 KrakenD 最重要的設定，因為它會用來定義 KrakenD 要提供哪些 API 給使用者以及該 API 背後對應的服務是哪些。<code>endpoints</code> 內每個物件都是一個 API 的定義，下方是一個代理 Todo API 的設定：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;endpoints&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;endpoint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/api/todos&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;output_encoding&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;no-op&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;backend&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;host&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;https://jsonplaceholder.typicode.com&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;url_pattern&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/todos&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;method&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;GET&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;encoding&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;no-op&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">      <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上方的設定表示會代理 <code>https://jsonplaceholder.typicode.com/todos</code> 這個 API，使用者只需要用 <code>GET</code> 方法存取 <a href=\"http://localhost:8080/api/todos\">http://localhost:8080/api/todos</a> 即可獲得該 API 的結果。</p>\n<h3 id=\"extra-config-基礎介紹\"><a href=\"#extra-config-基礎介紹\" class=\"headerlink\" title=\"extra_config 基礎介紹\"></a>extra_config 基礎介紹</h3><p><code>extra_config</code> 主要是負責針對各式 Plugin 進行設定，每個 Plugin 都會有一個獨一無二的 <strong>命名空間(Namespace)</strong>，KrakenD 會在啟動時註冊 Plugin 並從 <code>extra_config</code> 找出對應名稱的設定，再將該設定內容傳遞給 Plugin。下方是擴展 Log 的 <code>extra_config</code> 設定：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;extra_config&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;telemetry/logging&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;level&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;WARNING&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;prefix&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;[KRAKEND]&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;stdout&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>NOTE</strong>：有關 <code>telemetry/logging</code> 的介紹後續有機會再跟大家分享。</p>\n</blockquote>\n<p><code>extra_config</code> 不僅可以出現在設定檔的根層級，也可以出現在其他層級，放的層級越深，作用的範圍就越小，而實際放置位置取決於 Plugin 的用途與性質。下方是 <code>extra_config</code> 可以設置的層級：</p>\n<ul>\n<li><code>service</code>：服務層級，也就是與 <code>endpoints</code> 相同層級的位置。這個層級會影響整個 KrakenD 以及所有請求。</li>\n<li><code>endpoint</code>：Endpoint 層級，指的是 <code>endpoints</code> 中的物件。影響範圍僅限於該 API Endpoint。</li>\n<li><code>backend</code>：Backend 層級，指的是 <code>backends</code> 中的物件。影響範圍僅限於該 Backend。</li>\n</ul>\n<h2 id=\"小品練習\"><a href=\"#小品練習\" class=\"headerlink\" title=\"小品練習\"></a>小品練習</h2><p>首先，建立一個資料夾 <code>src</code> 並同時在該資料夾下新增 <code>krakend.json</code>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;$schema&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://www.krakend.io/schema/v2.8/krakend.json&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;endpoints&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;endpoint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/api/todos&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;output_encoding&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;no-op&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;backend&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;host&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;https://jsonplaceholder.typicode.com&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;url_pattern&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/todos&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;method&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;GET&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;encoding&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;no-op&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">      <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;extra_config&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;telemetry/logging&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;level&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;WARNING&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;prefix&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;[KRAKEND]&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;stdout&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>接著，透過下方指令以 Docker Volume 的方式將 <code>src</code> 資料夾 mapping 至 <code>/etc/krakend</code>，同時透過 <code>-c</code> 參數指定使用 <code>krakend.json</code> 作為設定檔：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -p 8080:8080 -v <span class=\"variable\">$PWD</span>/src:/etc/krakend devopsfaith/krakend run -c krakend.json</span><br></pre></td></tr></table></figure>\n\n<p>透過 Postman 以 <code>GET</code> 方法存取 <a href=\"http://localhost:8080/api/todos\">http://localhost:8080/api/todos</a>，可以順利拿到來自 <code>https://jsonplaceholder.typicode.com/todos</code> 的資料：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"krakend-result.png\"\n  alt=\"KrakenD Result\"\n/></p>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>今天簡單介紹了 KrakenD 以及啟動的方式，對於設定檔也有了初步的了解。後續會再針對設定檔的細節做更詳細的解說。</p>\n"},{"title":"在 NestJS 使用 Valkey 實現 Cache","date":"2025-02-23T10:28:00.000Z","_content":"\n## 什麼是 Valkey？\n\n在 2024 年時，Redis 官方宣佈要針對 License 進行異動，對於託管 Redis 的雲端服務供應商將不能免費使用 Redis，像是：AWS、Google Cloud Platform 等平台。因此，社群 fork 了 Redis 並建立開源的替代品 - [Valkey](https://valkey.io/)。它是一個高效的鍵值儲存系統，可以用來實現 **快取(Cache)**、**訊息佇列(Message Queue)** 等功能，在運行方面，同樣也支援 **獨立運作模式(Standalone)** 與 **叢集運作模式(Cluster)** 。\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"valkey-logo.png\"\n  alt=\"Valkey logo\"\n/>\n\n[圖片來源](https://valkey.io/)\n\n> **補充**：對於 Redis 異動的內容，可以參考 Will 保哥[翻譯後的版本](https://gist.github.com/doggy8088/879f873e268df735049674481ebd4060)。\n\n## 架設 Valkey\n\n官方有提供 Binary 與 Docker 兩種方式，這裡我們使用 Docker 來進行架設。透過下方指令將 Valkey 的 Docker Image 從 DockerHub 下載下來：\n\n```bash\n$ docker pull valkey/valkey:8.0.2\n```\n\n> **補充**：這裡指定版本為 `8.0.2`，若有需要可以自行換成所需的版本號。\n\n在啟動 Valkey 之前，需要先準備可以操作 Valkey 的環境，所以這裡先建立一個 Valkey 使用的 Docker Network：\n\n```bash\n$ docker network create valkey-example\n```\n\n建立完畢後，透過下方指令進行架設：\n\n```bash\n$ docker run --name valkey -p 6379:6379 --network valkey-example -d valkey/valkey:8.0.2\n```\n\n## 操作 Valkey\n\nValkey 提供的 Docker Image 本身帶有 [Valkey CLI](https://valkey.io/topics/cli/) 的功能，透過下方指令即可快速啟動 CLI：\n\n```bash\n$ docker run -it --rm --network valkey-example valkey/valkey:8.0.2 valkey-cli -h valkey -p 6379\n```\n\n> **補充**：指令中的 `--network` 要跟 Valkey 架設時使用的 Docker Network 相同，以範例來說，就是先前建立的 `valkey-example`，而指令中使用的 `-h` 是 Valkey CLI 指定連線的 Hostname，以範例來說，我們架設的 Valkey Hostname 為 `valkey`，而 `-p` 代表的是 Valkey 架設時使用的 Port，以範例來說就是 `6379`。\n\n啟動成功會看到下方畫面：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"serve-valkey-cli.png\"\n  alt=\"Valkey CLI\"\n/>\n\n來試試 Valkey 的 `SET`，與 Redis 的 `SET` 相同，會以 **字串(String)** 的形式進行保存。透過下方指令建立 Key 為 `demo`、Value 為 `Hello, World` 的資料，並設定 **過期時間(Expire time)** 為 `5` 秒：\n\n```bash\n$ SET demo \"Hello, World\" EX 5\n```\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"valkey-set-command.png\"\n  alt=\"Valkey SET command\"\n/>\n\n執行完畢後，在 `5` 秒內透過 `GET` 指令取出 Key 為 `demo` 的值，會得到 `Hello, World`。下方為相關指令：\n\n```bash\n$ GET demo\n```\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"valkey-get-command.png\"\n  alt=\"Valkey GET command\"\n/>\n\n過了 `5` 秒再次執行 `GET` 指令，會得到 `(nil)`：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"valkey-get-expired-value.png\"\n  alt=\"Valkey get expired value\"\n/>\n\n## 整合 NestJS Cache\n\nNestJS 針對 Cache 機制實作了 `CacheModule`，該 Module 封裝了 [cache-manager](https://www.npmjs.com/package/cache-manager)，目的是要讓發者可以輕易地實現 Cache 機制，甚至可以用 **相同介面操作不同 Cache 媒介** ，如：In-memory 的 Cache、Redis、Valkey 等。\n\nNestJS 11 版之後，告別第 `5` 版的 `cache-manager`，轉為使用第 `6` 版的 `cache-manager`，從這版開始底層使用了 [Keyv](https://keyv.org/) 這個套件，來強化 **相同介面操作不同 Cache 媒介** 的特性，也因此從 NestJS 11 開始，可以運用 Keyv 提供的套件來快速轉換 Cache 媒介，十分強大！\n\n### 前置作業\n\n要使用 `CacheModule` 需要安裝下列依賴套件：\n\n```bash\n$ npm install @nestjs/cache-manager cache-manager\n```\n\n如前面所述，我們可以運用 Keyv 提供的套件來快速轉換 Cache 媒介，以我們現在的情境來說，可以安裝 Keyv 提供的 [@keyv/valkey](https://keyv.org/docs/storage-adapters/valkey/)：\n\n```bash\n$ npm install @keyv/valkey\n```\n\n### 用 CacheModule 操作 Valkey\n\n在 NestJS 專案中，於 `AppModule` 匯入 `CacheModule`，並使用 `register` 方法來註冊，這裡指定 `stores` 為 `ValkeyKeyv` 的實例：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { CacheModule } from '@nestjs/cache-manager';\nimport ValkeyKeyv from '@keyv/valkey';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n\n@Module({\n  imports: [\n    CacheModule.register({\n      stores: [\n        new ValkeyKeyv('redis://localhost:6379')\n      ],\n    }),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n```\n\n接著，調整 `AppController` 的內容，注入 `Cache` 並調整 `getHello` 方法，透過 `Cache` 的 `get` 方法取得 Key 為 `random` 的值，如果存在就回傳；反之，產生一組隨機字串，並透過 `Cache` 的 `set` 方法執行 Valkey 的 `SET`，Key 為 `random`、Value 為產生的隨機字串，同時設定 TTL 為 `10` 秒，最後再將結果回傳：\n\n```typescript\nimport { Controller, Get } from '@nestjs/common';\nimport { Cache } from '@nestjs/cache-manager';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly cache: Cache) {}\n\n  @Get()\n  async getHello() {\n    const cacheKey = 'random';\n    const value = await this.cache.get<string>(cacheKey);\n    if (value !== null) {\n      return { value };\n    }\n    const randomValue = Math.random().toString(36).substring(7);\n    const milliSeconds = 10 * 1000;\n    await this.cache.set(cacheKey, randomValue, milliSeconds);\n    return { value: randomValue };\n  }\n}\n```\n\n> **補充**：官方文件注入 `Cache` 的方式是透過 `@Inject` 裝飾器注入 Token 為 `CACHE_MANAGER` 的 Provider，該 Provider 的型別為 `cache-manager` 提供的 `Cache` 類，但其實 NestJS 在 `@nestjs/cache-manager` 有實現 `Cache` 類，該類的介面與 `cache-manager` 的 `Cache` 相同，用來當作上述 Provider 的 Alias Provider。上方範例使用的是 Alias Provider，可以簡化注入的程式碼。\n\n啟動 NestJS 專案後，透過 `[GET]` 方法存取 [http://localhost:3000](http://localhost:3000) 即可嘗試看看在 NestJS 使用 Valkey 當 Cache 的效果哦！\n\n## 體驗轉換 Cache 媒介\n\n假如現在有一個 NestJS 的專案要從 Redis 轉成 Valkey，理論上只需要將 `CacheModule` 的 `stores` 進行替換即可。這邊來實際模擬一下，首先，撰寫下方 `docker-compose.yml` 來快速啟動 Redis 與 Valkey：\n\n```yaml\nversion: '3.7'\nservices:\n  redis:\n    image: redis:7.4.2\n    container_name: redis\n    ports:\n      - \"6379:6379\"\n  valkey:\n    image: valkey/valkey:8.0.2\n    container_name: valkey\n    ports:\n      - \"6380:6379\"\n```\n\n透過下方指令將上述服務啟動：\n\n```bash\n$ docker compose -p nestjs-valkey-example -f docker-compose.yml up -d\n```\n\n啟動後來調整一下 NestJS 專案，現在要將 Cache 媒介轉換成 Redis，這裡可以安裝 [@keyv/redis](https://keyv.org/docs/storage-adapters/redis/) 來達到此效果：\n\n```bash\n$ npm install @keyv/redis\n```\n\n安裝完畢後，調整 `AppModule` 的內容，將 `stores` 內的 `ValkeyKeyv` 註解掉，換成 `RedisKeyv`：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { CacheModule } from '@nestjs/cache-manager';\nimport RedisKeyv from '@keyv/redis';\n// import ValkeyKeyv from '@keyv/valkey';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n\n@Module({\n  imports: [\n    CacheModule.register({\n      stores: [\n        new RedisKeyv('redis://localhost:6379'),\n        // new ValkeyKeyv('redis://localhost:6380')\n      ],\n    }),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n```\n\n這樣就完成轉換了，可以透過 `[GET]` 方法存取 [http://localhost:3000](http://localhost:3000) 來試試看效果。如果要切換回 Valkey 就將 `stores` 改成使用 `ValkeyKeyv` 即可：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { CacheModule } from '@nestjs/cache-manager';\n// import RedisKeyv from '@keyv/redis';\nimport ValkeyKeyv from '@keyv/valkey';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n\n@Module({\n  imports: [\n    CacheModule.register({\n      stores: [\n        // new RedisKeyv('redis://localhost:6379'),\n        new ValkeyKeyv('redis://localhost:6380')\n      ],\n    }),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n```\n\n## 結論\n\n我們可以看到 Valkey 作為 Redis 的開源替代方案，目前在使用體驗上與 Redis 十分相似甚至有相同之處，讓開發者可以大幅降低轉換成本。另外，由於 NestJS 內建的 `CacheModule` 採用了 `Keyv` 作為底層實作，使我們能夠透過簡單的設定，快速在不同的 Cache 媒介之間切換，提升開發的靈活性。","source":"_posts/0004-nestjs-valkey.md","raw":"---\ntitle: 在 NestJS 使用 Valkey 實現 Cache\ndate: 2025-02-23 18:28:00\ntags:\n  - Backend\n  - NestJS\n  - Cache\n  - Valkey\ncategories:\n  - ['Backend', 'NestJS']\n---\n\n## 什麼是 Valkey？\n\n在 2024 年時，Redis 官方宣佈要針對 License 進行異動，對於託管 Redis 的雲端服務供應商將不能免費使用 Redis，像是：AWS、Google Cloud Platform 等平台。因此，社群 fork 了 Redis 並建立開源的替代品 - [Valkey](https://valkey.io/)。它是一個高效的鍵值儲存系統，可以用來實現 **快取(Cache)**、**訊息佇列(Message Queue)** 等功能，在運行方面，同樣也支援 **獨立運作模式(Standalone)** 與 **叢集運作模式(Cluster)** 。\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"valkey-logo.png\"\n  alt=\"Valkey logo\"\n/>\n\n[圖片來源](https://valkey.io/)\n\n> **補充**：對於 Redis 異動的內容，可以參考 Will 保哥[翻譯後的版本](https://gist.github.com/doggy8088/879f873e268df735049674481ebd4060)。\n\n## 架設 Valkey\n\n官方有提供 Binary 與 Docker 兩種方式，這裡我們使用 Docker 來進行架設。透過下方指令將 Valkey 的 Docker Image 從 DockerHub 下載下來：\n\n```bash\n$ docker pull valkey/valkey:8.0.2\n```\n\n> **補充**：這裡指定版本為 `8.0.2`，若有需要可以自行換成所需的版本號。\n\n在啟動 Valkey 之前，需要先準備可以操作 Valkey 的環境，所以這裡先建立一個 Valkey 使用的 Docker Network：\n\n```bash\n$ docker network create valkey-example\n```\n\n建立完畢後，透過下方指令進行架設：\n\n```bash\n$ docker run --name valkey -p 6379:6379 --network valkey-example -d valkey/valkey:8.0.2\n```\n\n## 操作 Valkey\n\nValkey 提供的 Docker Image 本身帶有 [Valkey CLI](https://valkey.io/topics/cli/) 的功能，透過下方指令即可快速啟動 CLI：\n\n```bash\n$ docker run -it --rm --network valkey-example valkey/valkey:8.0.2 valkey-cli -h valkey -p 6379\n```\n\n> **補充**：指令中的 `--network` 要跟 Valkey 架設時使用的 Docker Network 相同，以範例來說，就是先前建立的 `valkey-example`，而指令中使用的 `-h` 是 Valkey CLI 指定連線的 Hostname，以範例來說，我們架設的 Valkey Hostname 為 `valkey`，而 `-p` 代表的是 Valkey 架設時使用的 Port，以範例來說就是 `6379`。\n\n啟動成功會看到下方畫面：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"serve-valkey-cli.png\"\n  alt=\"Valkey CLI\"\n/>\n\n來試試 Valkey 的 `SET`，與 Redis 的 `SET` 相同，會以 **字串(String)** 的形式進行保存。透過下方指令建立 Key 為 `demo`、Value 為 `Hello, World` 的資料，並設定 **過期時間(Expire time)** 為 `5` 秒：\n\n```bash\n$ SET demo \"Hello, World\" EX 5\n```\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"valkey-set-command.png\"\n  alt=\"Valkey SET command\"\n/>\n\n執行完畢後，在 `5` 秒內透過 `GET` 指令取出 Key 為 `demo` 的值，會得到 `Hello, World`。下方為相關指令：\n\n```bash\n$ GET demo\n```\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"valkey-get-command.png\"\n  alt=\"Valkey GET command\"\n/>\n\n過了 `5` 秒再次執行 `GET` 指令，會得到 `(nil)`：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"valkey-get-expired-value.png\"\n  alt=\"Valkey get expired value\"\n/>\n\n## 整合 NestJS Cache\n\nNestJS 針對 Cache 機制實作了 `CacheModule`，該 Module 封裝了 [cache-manager](https://www.npmjs.com/package/cache-manager)，目的是要讓發者可以輕易地實現 Cache 機制，甚至可以用 **相同介面操作不同 Cache 媒介** ，如：In-memory 的 Cache、Redis、Valkey 等。\n\nNestJS 11 版之後，告別第 `5` 版的 `cache-manager`，轉為使用第 `6` 版的 `cache-manager`，從這版開始底層使用了 [Keyv](https://keyv.org/) 這個套件，來強化 **相同介面操作不同 Cache 媒介** 的特性，也因此從 NestJS 11 開始，可以運用 Keyv 提供的套件來快速轉換 Cache 媒介，十分強大！\n\n### 前置作業\n\n要使用 `CacheModule` 需要安裝下列依賴套件：\n\n```bash\n$ npm install @nestjs/cache-manager cache-manager\n```\n\n如前面所述，我們可以運用 Keyv 提供的套件來快速轉換 Cache 媒介，以我們現在的情境來說，可以安裝 Keyv 提供的 [@keyv/valkey](https://keyv.org/docs/storage-adapters/valkey/)：\n\n```bash\n$ npm install @keyv/valkey\n```\n\n### 用 CacheModule 操作 Valkey\n\n在 NestJS 專案中，於 `AppModule` 匯入 `CacheModule`，並使用 `register` 方法來註冊，這裡指定 `stores` 為 `ValkeyKeyv` 的實例：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { CacheModule } from '@nestjs/cache-manager';\nimport ValkeyKeyv from '@keyv/valkey';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n\n@Module({\n  imports: [\n    CacheModule.register({\n      stores: [\n        new ValkeyKeyv('redis://localhost:6379')\n      ],\n    }),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n```\n\n接著，調整 `AppController` 的內容，注入 `Cache` 並調整 `getHello` 方法，透過 `Cache` 的 `get` 方法取得 Key 為 `random` 的值，如果存在就回傳；反之，產生一組隨機字串，並透過 `Cache` 的 `set` 方法執行 Valkey 的 `SET`，Key 為 `random`、Value 為產生的隨機字串，同時設定 TTL 為 `10` 秒，最後再將結果回傳：\n\n```typescript\nimport { Controller, Get } from '@nestjs/common';\nimport { Cache } from '@nestjs/cache-manager';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly cache: Cache) {}\n\n  @Get()\n  async getHello() {\n    const cacheKey = 'random';\n    const value = await this.cache.get<string>(cacheKey);\n    if (value !== null) {\n      return { value };\n    }\n    const randomValue = Math.random().toString(36).substring(7);\n    const milliSeconds = 10 * 1000;\n    await this.cache.set(cacheKey, randomValue, milliSeconds);\n    return { value: randomValue };\n  }\n}\n```\n\n> **補充**：官方文件注入 `Cache` 的方式是透過 `@Inject` 裝飾器注入 Token 為 `CACHE_MANAGER` 的 Provider，該 Provider 的型別為 `cache-manager` 提供的 `Cache` 類，但其實 NestJS 在 `@nestjs/cache-manager` 有實現 `Cache` 類，該類的介面與 `cache-manager` 的 `Cache` 相同，用來當作上述 Provider 的 Alias Provider。上方範例使用的是 Alias Provider，可以簡化注入的程式碼。\n\n啟動 NestJS 專案後，透過 `[GET]` 方法存取 [http://localhost:3000](http://localhost:3000) 即可嘗試看看在 NestJS 使用 Valkey 當 Cache 的效果哦！\n\n## 體驗轉換 Cache 媒介\n\n假如現在有一個 NestJS 的專案要從 Redis 轉成 Valkey，理論上只需要將 `CacheModule` 的 `stores` 進行替換即可。這邊來實際模擬一下，首先，撰寫下方 `docker-compose.yml` 來快速啟動 Redis 與 Valkey：\n\n```yaml\nversion: '3.7'\nservices:\n  redis:\n    image: redis:7.4.2\n    container_name: redis\n    ports:\n      - \"6379:6379\"\n  valkey:\n    image: valkey/valkey:8.0.2\n    container_name: valkey\n    ports:\n      - \"6380:6379\"\n```\n\n透過下方指令將上述服務啟動：\n\n```bash\n$ docker compose -p nestjs-valkey-example -f docker-compose.yml up -d\n```\n\n啟動後來調整一下 NestJS 專案，現在要將 Cache 媒介轉換成 Redis，這裡可以安裝 [@keyv/redis](https://keyv.org/docs/storage-adapters/redis/) 來達到此效果：\n\n```bash\n$ npm install @keyv/redis\n```\n\n安裝完畢後，調整 `AppModule` 的內容，將 `stores` 內的 `ValkeyKeyv` 註解掉，換成 `RedisKeyv`：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { CacheModule } from '@nestjs/cache-manager';\nimport RedisKeyv from '@keyv/redis';\n// import ValkeyKeyv from '@keyv/valkey';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n\n@Module({\n  imports: [\n    CacheModule.register({\n      stores: [\n        new RedisKeyv('redis://localhost:6379'),\n        // new ValkeyKeyv('redis://localhost:6380')\n      ],\n    }),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n```\n\n這樣就完成轉換了，可以透過 `[GET]` 方法存取 [http://localhost:3000](http://localhost:3000) 來試試看效果。如果要切換回 Valkey 就將 `stores` 改成使用 `ValkeyKeyv` 即可：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { CacheModule } from '@nestjs/cache-manager';\n// import RedisKeyv from '@keyv/redis';\nimport ValkeyKeyv from '@keyv/valkey';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n\n@Module({\n  imports: [\n    CacheModule.register({\n      stores: [\n        // new RedisKeyv('redis://localhost:6379'),\n        new ValkeyKeyv('redis://localhost:6380')\n      ],\n    }),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n```\n\n## 結論\n\n我們可以看到 Valkey 作為 Redis 的開源替代方案，目前在使用體驗上與 Redis 十分相似甚至有相同之處，讓開發者可以大幅降低轉換成本。另外，由於 NestJS 內建的 `CacheModule` 採用了 `Keyv` 作為底層實作，使我們能夠透過簡單的設定，快速在不同的 Cache 媒介之間切換，提升開發的靈活性。","slug":"0004-nestjs-valkey","published":1,"updated":"2025-02-23T10:29:01.062Z","comments":1,"layout":"post","photos":[],"_id":"cm9tztuvp0009fqgx1gi5f55b","content":"<h2 id=\"什麼是-Valkey？\"><a href=\"#什麼是-Valkey？\" class=\"headerlink\" title=\"什麼是 Valkey？\"></a>什麼是 Valkey？</h2><p>在 2024 年時，Redis 官方宣佈要針對 License 進行異動，對於託管 Redis 的雲端服務供應商將不能免費使用 Redis，像是：AWS、Google Cloud Platform 等平台。因此，社群 fork 了 Redis 並建立開源的替代品 - <a href=\"https://valkey.io/\">Valkey</a>。它是一個高效的鍵值儲存系統，可以用來實現 <strong>快取(Cache)</strong>、<strong>訊息佇列(Message Queue)</strong> 等功能，在運行方面，同樣也支援 <strong>獨立運作模式(Standalone)</strong> 與 <strong>叢集運作模式(Cluster)</strong> 。</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"valkey-logo.png\"\n  alt=\"Valkey logo\"\n/></p>\n<p><a href=\"https://valkey.io/\">圖片來源</a></p>\n<blockquote>\n<p><strong>補充</strong>：對於 Redis 異動的內容，可以參考 Will 保哥<a href=\"https://gist.github.com/doggy8088/879f873e268df735049674481ebd4060\">翻譯後的版本</a>。</p>\n</blockquote>\n<h2 id=\"架設-Valkey\"><a href=\"#架設-Valkey\" class=\"headerlink\" title=\"架設 Valkey\"></a>架設 Valkey</h2><p>官方有提供 Binary 與 Docker 兩種方式，這裡我們使用 Docker 來進行架設。透過下方指令將 Valkey 的 Docker Image 從 DockerHub 下載下來：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull valkey/valkey:8.0.2</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>補充</strong>：這裡指定版本為 <code>8.0.2</code>，若有需要可以自行換成所需的版本號。</p>\n</blockquote>\n<p>在啟動 Valkey 之前，需要先準備可以操作 Valkey 的環境，所以這裡先建立一個 Valkey 使用的 Docker Network：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker network create valkey-example</span><br></pre></td></tr></table></figure>\n\n<p>建立完畢後，透過下方指令進行架設：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name valkey -p 6379:6379 --network valkey-example -d valkey/valkey:8.0.2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作-Valkey\"><a href=\"#操作-Valkey\" class=\"headerlink\" title=\"操作 Valkey\"></a>操作 Valkey</h2><p>Valkey 提供的 Docker Image 本身帶有 <a href=\"https://valkey.io/topics/cli/\">Valkey CLI</a> 的功能，透過下方指令即可快速啟動 CLI：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -it --<span class=\"built_in\">rm</span> --network valkey-example valkey/valkey:8.0.2 valkey-cli -h valkey -p 6379</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>補充</strong>：指令中的 <code>--network</code> 要跟 Valkey 架設時使用的 Docker Network 相同，以範例來說，就是先前建立的 <code>valkey-example</code>，而指令中使用的 <code>-h</code> 是 Valkey CLI 指定連線的 Hostname，以範例來說，我們架設的 Valkey Hostname 為 <code>valkey</code>，而 <code>-p</code> 代表的是 Valkey 架設時使用的 Port，以範例來說就是 <code>6379</code>。</p>\n</blockquote>\n<p>啟動成功會看到下方畫面：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"serve-valkey-cli.png\"\n  alt=\"Valkey CLI\"\n/></p>\n<p>來試試 Valkey 的 <code>SET</code>，與 Redis 的 <code>SET</code> 相同，會以 <strong>字串(String)</strong> 的形式進行保存。透過下方指令建立 Key 為 <code>demo</code>、Value 為 <code>Hello, World</code> 的資料，並設定 <strong>過期時間(Expire time)</strong> 為 <code>5</code> 秒：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ SET demo <span class=\"string\">&quot;Hello, World&quot;</span> EX 5</span><br></pre></td></tr></table></figure>\n\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"valkey-set-command.png\"\n  alt=\"Valkey SET command\"\n/></p>\n<p>執行完畢後，在 <code>5</code> 秒內透過 <code>GET</code> 指令取出 Key 為 <code>demo</code> 的值，會得到 <code>Hello, World</code>。下方為相關指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ GET demo</span><br></pre></td></tr></table></figure>\n\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"valkey-get-command.png\"\n  alt=\"Valkey GET command\"\n/></p>\n<p>過了 <code>5</code> 秒再次執行 <code>GET</code> 指令，會得到 <code>(nil)</code>：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"valkey-get-expired-value.png\"\n  alt=\"Valkey get expired value\"\n/></p>\n<h2 id=\"整合-NestJS-Cache\"><a href=\"#整合-NestJS-Cache\" class=\"headerlink\" title=\"整合 NestJS Cache\"></a>整合 NestJS Cache</h2><p>NestJS 針對 Cache 機制實作了 <code>CacheModule</code>，該 Module 封裝了 <a href=\"https://www.npmjs.com/package/cache-manager\">cache-manager</a>，目的是要讓發者可以輕易地實現 Cache 機制，甚至可以用 <strong>相同介面操作不同 Cache 媒介</strong> ，如：In-memory 的 Cache、Redis、Valkey 等。</p>\n<p>NestJS 11 版之後，告別第 <code>5</code> 版的 <code>cache-manager</code>，轉為使用第 <code>6</code> 版的 <code>cache-manager</code>，從這版開始底層使用了 <a href=\"https://keyv.org/\">Keyv</a> 這個套件，來強化 <strong>相同介面操作不同 Cache 媒介</strong> 的特性，也因此從 NestJS 11 開始，可以運用 Keyv 提供的套件來快速轉換 Cache 媒介，十分強大！</p>\n<h3 id=\"前置作業\"><a href=\"#前置作業\" class=\"headerlink\" title=\"前置作業\"></a>前置作業</h3><p>要使用 <code>CacheModule</code> 需要安裝下列依賴套件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install @nestjs/cache-manager cache-manager</span><br></pre></td></tr></table></figure>\n\n<p>如前面所述，我們可以運用 Keyv 提供的套件來快速轉換 Cache 媒介，以我們現在的情境來說，可以安裝 Keyv 提供的 <a href=\"https://keyv.org/docs/storage-adapters/valkey/\">@keyv&#x2F;valkey</a>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install @keyv/valkey</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用-CacheModule-操作-Valkey\"><a href=\"#用-CacheModule-操作-Valkey\" class=\"headerlink\" title=\"用 CacheModule 操作 Valkey\"></a>用 CacheModule 操作 Valkey</h3><p>在 NestJS 專案中，於 <code>AppModule</code> 匯入 <code>CacheModule</code>，並使用 <code>register</code> 方法來註冊，這裡指定 <code>stores</code> 為 <code>ValkeyKeyv</code> 的實例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CacheModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/cache-manager&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">ValkeyKeyv</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@keyv/valkey&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppController</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.controller&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.service&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">CacheModule</span>.<span class=\"title function_\">register</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">stores</span>: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ValkeyKeyv</span>(<span class=\"string\">&#x27;redis://localhost:6379&#x27;</span>)</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">controllers</span>: [<span class=\"title class_\">AppController</span>],</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [<span class=\"title class_\">AppService</span>],</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接著，調整 <code>AppController</code> 的內容，注入 <code>Cache</code> 並調整 <code>getHello</code> 方法，透過 <code>Cache</code> 的 <code>get</code> 方法取得 Key 為 <code>random</code> 的值，如果存在就回傳；反之，產生一組隨機字串，並透過 <code>Cache</code> 的 <code>set</code> 方法執行 Valkey 的 <code>SET</code>，Key 為 <code>random</code>、Value 為產生的隨機字串，同時設定 TTL 為 <code>10</code> 秒，最後再將結果回傳：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Controller</span>, <span class=\"title class_\">Get</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Cache</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/cache-manager&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Controller</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppController</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">cache</span>: <span class=\"title class_\">Cache</span></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Get</span>()</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"title function_\">getHello</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cacheKey = <span class=\"string\">&#x27;random&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">cache</span>.<span class=\"property\">get</span>&lt;<span class=\"built_in\">string</span>&gt;(cacheKey);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; value &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> randomValue = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>().<span class=\"title function_\">toString</span>(<span class=\"number\">36</span>).<span class=\"title function_\">substring</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> milliSeconds = <span class=\"number\">10</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">cache</span>.<span class=\"title function_\">set</span>(cacheKey, randomValue, milliSeconds);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: randomValue &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>補充</strong>：官方文件注入 <code>Cache</code> 的方式是透過 <code>@Inject</code> 裝飾器注入 Token 為 <code>CACHE_MANAGER</code> 的 Provider，該 Provider 的型別為 <code>cache-manager</code> 提供的 <code>Cache</code> 類，但其實 NestJS 在 <code>@nestjs/cache-manager</code> 有實現 <code>Cache</code> 類，該類的介面與 <code>cache-manager</code> 的 <code>Cache</code> 相同，用來當作上述 Provider 的 Alias Provider。上方範例使用的是 Alias Provider，可以簡化注入的程式碼。</p>\n</blockquote>\n<p>啟動 NestJS 專案後，透過 <code>[GET]</code> 方法存取 <a href=\"http://localhost:3000/\">http://localhost:3000</a> 即可嘗試看看在 NestJS 使用 Valkey 當 Cache 的效果哦！</p>\n<h2 id=\"體驗轉換-Cache-媒介\"><a href=\"#體驗轉換-Cache-媒介\" class=\"headerlink\" title=\"體驗轉換 Cache 媒介\"></a>體驗轉換 Cache 媒介</h2><p>假如現在有一個 NestJS 的專案要從 Redis 轉成 Valkey，理論上只需要將 <code>CacheModule</code> 的 <code>stores</code> 進行替換即可。這邊來實際模擬一下，首先，撰寫下方 <code>docker-compose.yml</code> 來快速啟動 Redis 與 Valkey：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.7&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis:7.4.2</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;6379:6379&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">valkey:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">valkey/valkey:8.0.2</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">valkey</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;6380:6379&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>透過下方指令將上述服務啟動：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker compose -p nestjs-valkey-example -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure>\n\n<p>啟動後來調整一下 NestJS 專案，現在要將 Cache 媒介轉換成 Redis，這裡可以安裝 <a href=\"https://keyv.org/docs/storage-adapters/redis/\">@keyv&#x2F;redis</a> 來達到此效果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install @keyv/redis</span><br></pre></td></tr></table></figure>\n\n<p>安裝完畢後，調整 <code>AppModule</code> 的內容，將 <code>stores</code> 內的 <code>ValkeyKeyv</code> 註解掉，換成 <code>RedisKeyv</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CacheModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/cache-manager&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">RedisKeyv</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@keyv/redis&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import ValkeyKeyv from &#x27;@keyv/valkey&#x27;;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppController</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.controller&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.service&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">CacheModule</span>.<span class=\"title function_\">register</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">stores</span>: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">RedisKeyv</span>(<span class=\"string\">&#x27;redis://localhost:6379&#x27;</span>),</span><br><span class=\"line\">        <span class=\"comment\">// new ValkeyKeyv(&#x27;redis://localhost:6380&#x27;)</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">controllers</span>: [<span class=\"title class_\">AppController</span>],</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [<span class=\"title class_\">AppService</span>],</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這樣就完成轉換了，可以透過 <code>[GET]</code> 方法存取 <a href=\"http://localhost:3000/\">http://localhost:3000</a> 來試試看效果。如果要切換回 Valkey 就將 <code>stores</code> 改成使用 <code>ValkeyKeyv</code> 即可：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CacheModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/cache-manager&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import RedisKeyv from &#x27;@keyv/redis&#x27;;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">ValkeyKeyv</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@keyv/valkey&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppController</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.controller&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.service&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">CacheModule</span>.<span class=\"title function_\">register</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">stores</span>: [</span><br><span class=\"line\">        <span class=\"comment\">// new RedisKeyv(&#x27;redis://localhost:6379&#x27;),</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ValkeyKeyv</span>(<span class=\"string\">&#x27;redis://localhost:6380&#x27;</span>)</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">controllers</span>: [<span class=\"title class_\">AppController</span>],</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [<span class=\"title class_\">AppService</span>],</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>我們可以看到 Valkey 作為 Redis 的開源替代方案，目前在使用體驗上與 Redis 十分相似甚至有相同之處，讓開發者可以大幅降低轉換成本。另外，由於 NestJS 內建的 <code>CacheModule</code> 採用了 <code>Keyv</code> 作為底層實作，使我們能夠透過簡單的設定，快速在不同的 Cache 媒介之間切換，提升開發的靈活性。</p>\n","excerpt":"","more":"<h2 id=\"什麼是-Valkey？\"><a href=\"#什麼是-Valkey？\" class=\"headerlink\" title=\"什麼是 Valkey？\"></a>什麼是 Valkey？</h2><p>在 2024 年時，Redis 官方宣佈要針對 License 進行異動，對於託管 Redis 的雲端服務供應商將不能免費使用 Redis，像是：AWS、Google Cloud Platform 等平台。因此，社群 fork 了 Redis 並建立開源的替代品 - <a href=\"https://valkey.io/\">Valkey</a>。它是一個高效的鍵值儲存系統，可以用來實現 <strong>快取(Cache)</strong>、<strong>訊息佇列(Message Queue)</strong> 等功能，在運行方面，同樣也支援 <strong>獨立運作模式(Standalone)</strong> 與 <strong>叢集運作模式(Cluster)</strong> 。</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"valkey-logo.png\"\n  alt=\"Valkey logo\"\n/></p>\n<p><a href=\"https://valkey.io/\">圖片來源</a></p>\n<blockquote>\n<p><strong>補充</strong>：對於 Redis 異動的內容，可以參考 Will 保哥<a href=\"https://gist.github.com/doggy8088/879f873e268df735049674481ebd4060\">翻譯後的版本</a>。</p>\n</blockquote>\n<h2 id=\"架設-Valkey\"><a href=\"#架設-Valkey\" class=\"headerlink\" title=\"架設 Valkey\"></a>架設 Valkey</h2><p>官方有提供 Binary 與 Docker 兩種方式，這裡我們使用 Docker 來進行架設。透過下方指令將 Valkey 的 Docker Image 從 DockerHub 下載下來：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull valkey/valkey:8.0.2</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>補充</strong>：這裡指定版本為 <code>8.0.2</code>，若有需要可以自行換成所需的版本號。</p>\n</blockquote>\n<p>在啟動 Valkey 之前，需要先準備可以操作 Valkey 的環境，所以這裡先建立一個 Valkey 使用的 Docker Network：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker network create valkey-example</span><br></pre></td></tr></table></figure>\n\n<p>建立完畢後，透過下方指令進行架設：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name valkey -p 6379:6379 --network valkey-example -d valkey/valkey:8.0.2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作-Valkey\"><a href=\"#操作-Valkey\" class=\"headerlink\" title=\"操作 Valkey\"></a>操作 Valkey</h2><p>Valkey 提供的 Docker Image 本身帶有 <a href=\"https://valkey.io/topics/cli/\">Valkey CLI</a> 的功能，透過下方指令即可快速啟動 CLI：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -it --<span class=\"built_in\">rm</span> --network valkey-example valkey/valkey:8.0.2 valkey-cli -h valkey -p 6379</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>補充</strong>：指令中的 <code>--network</code> 要跟 Valkey 架設時使用的 Docker Network 相同，以範例來說，就是先前建立的 <code>valkey-example</code>，而指令中使用的 <code>-h</code> 是 Valkey CLI 指定連線的 Hostname，以範例來說，我們架設的 Valkey Hostname 為 <code>valkey</code>，而 <code>-p</code> 代表的是 Valkey 架設時使用的 Port，以範例來說就是 <code>6379</code>。</p>\n</blockquote>\n<p>啟動成功會看到下方畫面：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"serve-valkey-cli.png\"\n  alt=\"Valkey CLI\"\n/></p>\n<p>來試試 Valkey 的 <code>SET</code>，與 Redis 的 <code>SET</code> 相同，會以 <strong>字串(String)</strong> 的形式進行保存。透過下方指令建立 Key 為 <code>demo</code>、Value 為 <code>Hello, World</code> 的資料，並設定 <strong>過期時間(Expire time)</strong> 為 <code>5</code> 秒：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ SET demo <span class=\"string\">&quot;Hello, World&quot;</span> EX 5</span><br></pre></td></tr></table></figure>\n\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"valkey-set-command.png\"\n  alt=\"Valkey SET command\"\n/></p>\n<p>執行完畢後，在 <code>5</code> 秒內透過 <code>GET</code> 指令取出 Key 為 <code>demo</code> 的值，會得到 <code>Hello, World</code>。下方為相關指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ GET demo</span><br></pre></td></tr></table></figure>\n\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"valkey-get-command.png\"\n  alt=\"Valkey GET command\"\n/></p>\n<p>過了 <code>5</code> 秒再次執行 <code>GET</code> 指令，會得到 <code>(nil)</code>：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"valkey-get-expired-value.png\"\n  alt=\"Valkey get expired value\"\n/></p>\n<h2 id=\"整合-NestJS-Cache\"><a href=\"#整合-NestJS-Cache\" class=\"headerlink\" title=\"整合 NestJS Cache\"></a>整合 NestJS Cache</h2><p>NestJS 針對 Cache 機制實作了 <code>CacheModule</code>，該 Module 封裝了 <a href=\"https://www.npmjs.com/package/cache-manager\">cache-manager</a>，目的是要讓發者可以輕易地實現 Cache 機制，甚至可以用 <strong>相同介面操作不同 Cache 媒介</strong> ，如：In-memory 的 Cache、Redis、Valkey 等。</p>\n<p>NestJS 11 版之後，告別第 <code>5</code> 版的 <code>cache-manager</code>，轉為使用第 <code>6</code> 版的 <code>cache-manager</code>，從這版開始底層使用了 <a href=\"https://keyv.org/\">Keyv</a> 這個套件，來強化 <strong>相同介面操作不同 Cache 媒介</strong> 的特性，也因此從 NestJS 11 開始，可以運用 Keyv 提供的套件來快速轉換 Cache 媒介，十分強大！</p>\n<h3 id=\"前置作業\"><a href=\"#前置作業\" class=\"headerlink\" title=\"前置作業\"></a>前置作業</h3><p>要使用 <code>CacheModule</code> 需要安裝下列依賴套件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install @nestjs/cache-manager cache-manager</span><br></pre></td></tr></table></figure>\n\n<p>如前面所述，我們可以運用 Keyv 提供的套件來快速轉換 Cache 媒介，以我們現在的情境來說，可以安裝 Keyv 提供的 <a href=\"https://keyv.org/docs/storage-adapters/valkey/\">@keyv&#x2F;valkey</a>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install @keyv/valkey</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用-CacheModule-操作-Valkey\"><a href=\"#用-CacheModule-操作-Valkey\" class=\"headerlink\" title=\"用 CacheModule 操作 Valkey\"></a>用 CacheModule 操作 Valkey</h3><p>在 NestJS 專案中，於 <code>AppModule</code> 匯入 <code>CacheModule</code>，並使用 <code>register</code> 方法來註冊，這裡指定 <code>stores</code> 為 <code>ValkeyKeyv</code> 的實例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CacheModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/cache-manager&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">ValkeyKeyv</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@keyv/valkey&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppController</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.controller&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.service&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">CacheModule</span>.<span class=\"title function_\">register</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">stores</span>: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ValkeyKeyv</span>(<span class=\"string\">&#x27;redis://localhost:6379&#x27;</span>)</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">controllers</span>: [<span class=\"title class_\">AppController</span>],</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [<span class=\"title class_\">AppService</span>],</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接著，調整 <code>AppController</code> 的內容，注入 <code>Cache</code> 並調整 <code>getHello</code> 方法，透過 <code>Cache</code> 的 <code>get</code> 方法取得 Key 為 <code>random</code> 的值，如果存在就回傳；反之，產生一組隨機字串，並透過 <code>Cache</code> 的 <code>set</code> 方法執行 Valkey 的 <code>SET</code>，Key 為 <code>random</code>、Value 為產生的隨機字串，同時設定 TTL 為 <code>10</code> 秒，最後再將結果回傳：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Controller</span>, <span class=\"title class_\">Get</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Cache</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/cache-manager&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Controller</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppController</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">cache</span>: <span class=\"title class_\">Cache</span></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Get</span>()</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"title function_\">getHello</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cacheKey = <span class=\"string\">&#x27;random&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">cache</span>.<span class=\"property\">get</span>&lt;<span class=\"built_in\">string</span>&gt;(cacheKey);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; value &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> randomValue = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>().<span class=\"title function_\">toString</span>(<span class=\"number\">36</span>).<span class=\"title function_\">substring</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> milliSeconds = <span class=\"number\">10</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">cache</span>.<span class=\"title function_\">set</span>(cacheKey, randomValue, milliSeconds);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: randomValue &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>補充</strong>：官方文件注入 <code>Cache</code> 的方式是透過 <code>@Inject</code> 裝飾器注入 Token 為 <code>CACHE_MANAGER</code> 的 Provider，該 Provider 的型別為 <code>cache-manager</code> 提供的 <code>Cache</code> 類，但其實 NestJS 在 <code>@nestjs/cache-manager</code> 有實現 <code>Cache</code> 類，該類的介面與 <code>cache-manager</code> 的 <code>Cache</code> 相同，用來當作上述 Provider 的 Alias Provider。上方範例使用的是 Alias Provider，可以簡化注入的程式碼。</p>\n</blockquote>\n<p>啟動 NestJS 專案後，透過 <code>[GET]</code> 方法存取 <a href=\"http://localhost:3000/\">http://localhost:3000</a> 即可嘗試看看在 NestJS 使用 Valkey 當 Cache 的效果哦！</p>\n<h2 id=\"體驗轉換-Cache-媒介\"><a href=\"#體驗轉換-Cache-媒介\" class=\"headerlink\" title=\"體驗轉換 Cache 媒介\"></a>體驗轉換 Cache 媒介</h2><p>假如現在有一個 NestJS 的專案要從 Redis 轉成 Valkey，理論上只需要將 <code>CacheModule</code> 的 <code>stores</code> 進行替換即可。這邊來實際模擬一下，首先，撰寫下方 <code>docker-compose.yml</code> 來快速啟動 Redis 與 Valkey：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.7&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis:7.4.2</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;6379:6379&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">valkey:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">valkey/valkey:8.0.2</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">valkey</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;6380:6379&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>透過下方指令將上述服務啟動：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker compose -p nestjs-valkey-example -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure>\n\n<p>啟動後來調整一下 NestJS 專案，現在要將 Cache 媒介轉換成 Redis，這裡可以安裝 <a href=\"https://keyv.org/docs/storage-adapters/redis/\">@keyv&#x2F;redis</a> 來達到此效果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install @keyv/redis</span><br></pre></td></tr></table></figure>\n\n<p>安裝完畢後，調整 <code>AppModule</code> 的內容，將 <code>stores</code> 內的 <code>ValkeyKeyv</code> 註解掉，換成 <code>RedisKeyv</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CacheModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/cache-manager&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">RedisKeyv</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@keyv/redis&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import ValkeyKeyv from &#x27;@keyv/valkey&#x27;;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppController</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.controller&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.service&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">CacheModule</span>.<span class=\"title function_\">register</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">stores</span>: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">RedisKeyv</span>(<span class=\"string\">&#x27;redis://localhost:6379&#x27;</span>),</span><br><span class=\"line\">        <span class=\"comment\">// new ValkeyKeyv(&#x27;redis://localhost:6380&#x27;)</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">controllers</span>: [<span class=\"title class_\">AppController</span>],</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [<span class=\"title class_\">AppService</span>],</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這樣就完成轉換了，可以透過 <code>[GET]</code> 方法存取 <a href=\"http://localhost:3000/\">http://localhost:3000</a> 來試試看效果。如果要切換回 Valkey 就將 <code>stores</code> 改成使用 <code>ValkeyKeyv</code> 即可：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CacheModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/cache-manager&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import RedisKeyv from &#x27;@keyv/redis&#x27;;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">ValkeyKeyv</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@keyv/valkey&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppController</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.controller&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.service&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">CacheModule</span>.<span class=\"title function_\">register</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">stores</span>: [</span><br><span class=\"line\">        <span class=\"comment\">// new RedisKeyv(&#x27;redis://localhost:6379&#x27;),</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ValkeyKeyv</span>(<span class=\"string\">&#x27;redis://localhost:6380&#x27;</span>)</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">controllers</span>: [<span class=\"title class_\">AppController</span>],</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [<span class=\"title class_\">AppService</span>],</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>我們可以看到 Valkey 作為 Redis 的開源替代方案，目前在使用體驗上與 Redis 十分相似甚至有相同之處，讓開發者可以大幅降低轉換成本。另外，由於 NestJS 內建的 <code>CacheModule</code> 採用了 <code>Keyv</code> 作為底層實作，使我們能夠透過簡單的設定，快速在不同的 Cache 媒介之間切換，提升開發的靈活性。</p>\n"},{"title":"在 NestJS 使用 Pact 實現契約測試","date":"2025-03-08T09:20:00.000Z","_content":"\n在微服務架構中，各個服務由不同團隊獨立開發、部署與維運，這樣的彈性雖然增加了開發效率，但也同時導致服務間互動的不確定性。如何確保每個服務在獨立更新的同時，仍能正確溝通與協作？ **契約測試(Contract Testing)** 正是解決這一問題的有效工具。\n\n## 什麼是 Contract Testing？\n\nContract Testing 是一種專注於驗證服務間 **介面(Interface)** 正確性的自動化測試方法。此方法論會將服務區分成兩個角色：\n\n* **提供者(Provider)** ：提供 API 的服務。\n* **消費者(Consumer)** ：使用 Provider 提供的 API 的服務。\n\nProvider 與 Consumer 之間會 **提前** 約定好 Interface，包含：請求格式、回應格式、錯誤處理機制等。這種約定可以是 OpenAPI、JSON Schema 或是其他 Contract Testing 工具來作為服務間共同遵循的標準，這套約定即 **契約(Contract)** 。而 Contract Testing 有兩種方法，分別是： **消費者驅動的契約測試(Consumer-Driven Contract Testing)** 與 **提供者驅動的契約測試(Provider-Driven Contract Testing)** 。\n\n> **注意**：Contract Testing 並 **不會也不該** 驗證 **完整的** Provider 商業邏輯，僅聚焦在 Interface 的驗證，商業邏輯的部分應屬於 **單元測試(Unit Testing)** 的範疇。\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"contract-testing-concept.png\"\n  alt=\"Contract testing concept\"\n/>\n\n### Consumer-Driven Contract Testing\n\n這類型的 Contract Testing 是由 **Consumer 定義契約內容來確保 Provider 提供的服務是否滿足它的期望**。這樣的好處是 Provider 可以根據 Consumer 的實際需求來驗證與實作，達到快速反饋以及減少整合風險的效果，是一個適合內部團隊使用的 Contract Testing 方法。\n\n### Provider-Driven Contract Testing\n\n這類型的 Contract Testing 是由 **Provider 定義契約內容來統一管理 API 的文件與版本**。這樣的好處是 Provider 可以讓所有 Consumer 依據統一的標準進行開發，是一個適合用於對外公開 API 的 Contract Testing 方法。\n\n## 為什麼需要 Contract Testing？\n\n如文章開頭所述，微服務架構使得服務之間的互動增加了不確定性，如果沒有驗證互動正確性的方式，當服務的 Interface 頻繁發生變化時，有可能會因此導致其他服務無法正常運作，造成損失。如果導入 Contract Testing 則可以提早捕捉到不兼容的問題，避免整合時才發現有這個狀況發生。另外，在驗證服務間是否如預期運作最常見的方式即 **端對端測試(E2E Testing)** ，但測試過程可能會涉及許多複雜的商業邏輯與其他依賴的項目，針對僅需驗證 Consumer 與 Provider 之間 Interface 是否符合預期的情境，使用成本較高且流程繁複的 E2E Testing 顯得有些大材小用，使用對完整環境要求低、能夠驗證 Interface 是否符合預期的 Contract Testing 會是更好的選擇。\n\n## Pact\n\nPact 是一套 **程式碼優先(code-first)** 的 Consumer-Driven Contract Testing 工具，提供多種程式語言的實作，如：[JavaScript](https://docs.pact.io/implementation_guides/javascript/readme)、[Java](https://docs.pact.io/implementation_guides/jvm)、[Golang](https://docs.pact.io/implementation_guides/go) 等。\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-logo.png\"\n  alt=\"Pact logo\"\n/>\n\n[圖片來源](https://docs.pact.io/implementation_guides/javascript/readme)\n\n### Pact 的運作流程\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-flow-concept.png\"\n  alt=\"Pact flow concept\"\n/>\n\n[圖片來源](https://docs.pact.io/)\n\nPact 在運作流程上可以拆成兩個階段： **Consumer 階段** 與 **Provider 階段** ：\n\n#### Consumer 階段\n\nConsumer 在自己的測試中使用對應語言的 Pact 函式庫來定義預期的請求(HTTP Method、Path、Headers、Body 等)與回應格式(HTTP Code、Headers、Response Body 等)。測試執行期間，Pact 會啟動一個 Mock Server，Consumer 發送的請求會送到這個 Server，並會收到事前定義好的回應。測試完成後，Pact 會根據這些定義產生一個 JSON 格式的 Contract，用來記錄 Consumer 所期望的 Interface。\n\n#### Provider 階段\n\nProvider 要使用 Consumer 定義的 Contract 來驗證服務提供的內容是否符合期望，所以必須在測試時啟動服務，並使用對應語言的 Pact 函式庫來執行 **Pact 驗證工具(Pact Verifier)** ，會讀取 Consumer 產生的 Contract 檔案並 **重放(Replay)** Contract 內定義的請求，進而驗證服務最終回傳的內容符合 Contract 內定義的格式。如果驗證結果發現回應的格式不如預期，此 Contract Testing 就會失敗，如此一來，便可以及早發現 Interface 不符期待的問題。\n\n## NestJS 與 Pact\n\nPact 有提供 [PactJS](https://docs.pact.io/implementation_guides/javascript/readme) 套件供 JavaScript、TypeScript 開發者使用。NestJS 固然可以在既有的測試流程中使用此套件來實現 Contract Testing，甚至官方還為 NestJS 實作了 [nestjs-pact](https://github.com/pact-foundation/nestjs-pact) 套件，十分貼心！\n\n### 前置作業\n\n假設已經有兩個基於 NestJS 實作的服務，一個是 Consumer、一個是 Provider，這些服務的專案需透過下方指令將 Pact 相關套件進行安裝：\n\n```bash\n$ npm install nestjs-pact @pact-foundation/pact -D\n```\n\n#### Consumer 測試的前置作業\n\n假設 Consumer 這個專案有一個 `TodoModule`，該 Module 內有 `TodoController` 與 `TodoService` 並匯入了 `HttpModule` 來呼叫 API。下方是 `TodoController`、`TodoService` 與 `HttpService` 之間的關係，以類別圖來呈現：\n\n{% mermaid %}\nclassDiagram\n  class HttpService {\n    +get(url)\n    +post(url, payload)\n    +delete(url)\n  }\n\n  class TodoService {\n    -HttpService httpService\n    -TodoConfig config\n    -String todoApiUrl\n    +createTodo(payload)\n    +getTodoById(id)\n    +completeTodoById(id, completed)\n    +deleteTodoById(id)\n  }\n\n  class TodoController {\n    -TodoService todoService\n    +createTodo(payload)\n    +getTodo(id)\n    +completeTodo(id, payload)\n    +deleteTodo(id)\n  }\n\n  TodoService --> HttpService\n  TodoController --> TodoService\n{% endmermaid %}\n\n前面有提到 Contract Testing 是驗證服務間 Interface 的測試方法，對 Consumer 而言，與 Provider 互動的元件為 `TodoService`，所以針對 `TodoService` 撰寫 Contract。那要如何開始呢？首先，會需要建立 Pact 的實例，這邊可以使用 `PactV3` 這個類，是目前的主要版本：\n\n```typescript\ndescribe('Todo API Pact test', () => {\n  let provider: PactV3;\n  // ...\n\n  beforeAll(() => {\n    provider = new PactV3({\n      consumer: 'TodoConsumer',\n      provider: 'TodoProvider',\n      port: 1234,\n      dir: path.resolve(process.cwd(), 'pacts', 'apps', 'consumer'),\n      logLevel: 'info',\n    });\n  });\n\n  // ...\n});\n```\n\n上方是建立 `PactV3` 實例的方式，可以看到有幾個參數：\n\n* `consumer`：Consumer 的名稱。\n* `provider`：Provider 的名稱。\n* `port`：Pact 在執行測試時，會啟動一個 Mock Server，此參數即 Mock Server 的 port。\n* `dir`：執行測試後會產生 Contract 檔案，會將檔案存放在此資料夾下。\n* `logLevel`：執行測試時要顯示的 Log Level。\n\n建立完畢後，緊接著就可以進行 NestJS 測試的前置作業：\n\n```typescript\ndescribe('Todo API Pact test', () => {\n  let provider: PactV3;\n  let moduleRef: TestingModule;\n  let todoService: TodoService;\n  let config: TodoConfig;\n\n  // ...\n\n  beforeEach(async () => {\n    moduleRef = await Test.createTestingModule({\n      imports: [\n        HttpModule.register({\n          httpAgent: new Agent({ keepAlive: false }),\n        }),\n      ],\n      providers: [\n        TodoService,\n        {\n          provide: todoConfig.KEY,\n          useValue: {\n            apiUrl: '',\n          },\n        },\n      ],\n    }).compile();\n    todoService = moduleRef.get(TodoService);\n    config = moduleRef.get(todoConfig.KEY);\n  });\n});\n```\n\n> **補充** ：上方範例可以看到 `HttpModule` 使用了 `Agent` 並將 `keepAlive` 設為 `false`，這是因為如果沒有這樣設定，預設會是 `true`，會導致 Mock Server 出錯。\n\n一切準備就緒後，就可以來針對 `TodoService` 與 Provider 互動的方法進行測試了。\n\n#### Provider 測試的前置作業\n\n假設 Provider 這個專案有一個 `TodoModule`，該 Module 內有 `TodoController`、`TodoService` 與 `TodoRepository`，其中，`TodoRepository` 會負責與資料庫進行互動。下方是 `TodoController`、`TodoService` 與 `TodoRepository` 之間的關係，以類別圖來呈現：\n\n{% mermaid %}\nclassDiagram\n  class TodoRepository {\n    +createTodo(params)\n    +getTodoById(id)\n    +completeTodoById(id, completed)\n    +deleteTodoById(id)\n  }\n\n  class TodoService {\n    -TodoRepository todoRepository\n    +createTodo(payload)\n    +getTodoById(id)\n    +completeTodoById(id, completed)\n    +deleteTodoById(id)\n  }\n\n  class TodoController {\n    -TodoService todoService\n    +createTodo(payload)\n    +getTodoById(id)\n    +completeTodoById(id, payload)\n    +deleteTodoById(id)\n  }\n\n  TodoService --> TodoRepository\n  TodoController --> TodoService\n{% endmermaid %}\n\n前面有提到 Provider 在執行 Contract Testing 時，會需要啟動服務來進行驗證，但啟動服務並不是希望驗證完整的商業邏輯，只是要確定 API 的結果是符合期望的，所以需要把一些依賴去除掉，以上方範例來說，我們可以將 `TodoRepository` 透過 **樁(Stub)** 的方式進行處理。這邊先撰寫一個 `TodoTestingRepository`：\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { Observable, of } from 'rxjs';\nimport { CreateTodo, Todo } from '@pact-example/todo/domain';\n\n@Injectable()\nexport class TodoTestingRepository {\n  private readonly todos: Array<Todo> = [];\n\n  createTodo(params: CreateTodo): Observable<Todo> {\n    const todo: Todo = {\n      id: crypto.randomUUID(),\n      title: params.title,\n      completed: false,\n    };\n    this.todos.push(todo);\n    return of(todo);\n  }\n\n  appendTodo(todo: Todo): Observable<Todo> {\n    const existTodo = this.todos.find((x) => x.id === todo.id);\n    if (existTodo) {\n      Object.assign(existTodo, todo);\n      return of(existTodo);\n    }\n    this.todos.push(todo);\n    return of(todo);\n  }\n\n  getTodoById(id: string): Observable<Todo | null> {\n    return of(this.todos.find((todo) => todo.id === id) ?? null);\n  }\n\n  completeTodoById(id: string, completed: boolean): Observable<Todo | null> {\n    const todo = this.todos.find((todo) => todo.id === id);\n    if (todo) {\n      todo.completed = completed;\n    }\n    return of(todo ?? null);\n  }\n\n  deleteTodoById(id: string): Observable<Todo | null> {\n    const index = this.todos.findIndex((todo) => todo.id === id);\n    if (index !== -1) {\n      return of(this.todos.splice(index, 1)[0]);\n    }\n    return of(null);\n  }\n}\n```\n\n這裡建立一個 `TodoTestingModule` 將 `TodoRepository` 當作 `TodoTestingRepository` 的 Token：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { TodoController } from '../../../app/todo/todo.controller';\nimport { TodoService } from '../../../app/todo/todo.service';\nimport { TodoRepository } from '../../../app/todo/todo.repository';\nimport { TodoTestingRepository } from './todo-testing.repository';\n\n@Module({\n  controllers: [TodoController],\n  providers: [\n    TodoService,\n    TodoTestingRepository,\n    {\n      provide: TodoRepository,\n      useExisting: TodoTestingRepository,\n    },\n  ],\n  exports: [TodoRepository],\n})\nexport class TodoTestingModule {}\n```\n\n這些都完成後，就可以來建置 Provider 的測試了。將 NestJS 測試的前置作業建立起來：\n\n```typescript\n// ...\ndescribe('Todo API Pact validation', () => {\n  let app: INestApplication;\n  const consoleLogger = new ConsoleLogger();\n\n  beforeAll(async () => {\n    const moduleRef = await Test.createTestingModule({\n      imports: [TodoTestingModule],\n    })\n    .compile();\n    app = moduleRef.createNestApplication();\n    app.setGlobalPrefix('api');\n    await app.init();\n  });\n\n  // ...\n\n  afterAll(async () => {\n    await app.close();\n  });\n});\n```\n\n接著，使用 `nestjs-pact` 提供的 `PactProviderModule` 來建立 Pact Verifier，在建立的時候，假如是採用讀取 Contract 檔案的方式，就需要帶入 `pactUrls` 這個參數。當一切就緒後，透過 `PactVerifierService` 的 `verify` 方法即可執行驗證：\n\n```typescript\n// ...\n// 避免 Contract Testing 超時\njest.setTimeout(60 * 1000);\n\ndescribe('Todo API Pact validation', () => {\n  // ...\n  let verifier: PactVerifierService;\n\n  beforeAll(async () => {\n    const moduleRef = await Test.createTestingModule({\n      imports: [\n        // ...\n        PactProviderModule.registerAsync({\n          useFactory: () => {\n            return {\n              pactUrls: [\n                path.resolve(process.cwd(), 'pacts', 'apps', 'consumer', 'TodoConsumer-TodoProvider.json'),\n              ],\n            };\n          },\n        }),\n      ],\n    })\n    .compile();\n    verifier = moduleRef.get(PactVerifierService);\n    // ...\n  });\n\n  // 執行驗證\n  it('should validate the pact contract', async () => {\n    await verifier.verify(app);\n    consoleLogger.log('Pact Verification Completed!');\n  });\n\n  // ...\n});\n```\n\n### 撰寫建立 Todo 的測試\n\n先假設 Provider 提供的 `[POST] /api/todos` API 的請求 Payload 如下：\n\n```typescript\ntype CreateTodo = {\n  title: string;\n};\n```\n\n回應的 HTTP Code 為 `201` 且 Body 格式如下：\n\n```typescript\ntype CreatedTodo = {\n  todo: {\n    id: string;\n    title: string;\n    completed: boolean;\n  };\n};\n```\n\n#### Consumer\n\n透過 `PactV3` 的 `withRequest` 定義發送請求的格式，以 `[POST] /api/todos` 來說，`method` 會定為 `POST`、`path` 會定為 `/api/todos`、`body` 會定為 `CreateTodo` 的格式。而預期的回應則透過 `withResponseWith` 來設置，`status` 會是 `201`、`headers` 會含有 `Content-Type` 為 `application/json` 的值，比較特別的是，`body` 使用了 Pact 提供的 `MatchersV3` 來輔助驗證格式與資料，達到更精準的驗證，同時也可以減少 hardcode 測試資料的情況。下方為範例程式碼：\n\n```typescript\ndescribe('Todo API Pact test', () => {\n  // ...\n\n  describe('When call the createTodo method of TodoService.', () => {\n    const responseExample: CreatedTodo = {\n      todo: {\n        id: '1',\n        title: 'todo 1',\n        completed: false,\n      },\n    };\n\n    beforeAll(() => {\n      provider\n        .uponReceiving('a request to create a todo')\n        .withRequest({\n          method: 'POST',\n          path: '/api/todos',\n          body: {\n            title: responseExample.todo.title,\n          },\n        })\n        .willRespondWith({\n          status: HttpStatus.CREATED,\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: {\n            // `like` 的用法是要求值要跟提供的模板是相同的類型\n            todo: MatchersV3.like({\n              // `uuid` 的用法是資料必須符合 UUID 的格式\n              id: MatchersV3.uuid(), \n              // `string` 的用法是資料必須是指定的字串\n              title: MatchersV3.string(responseExample.todo.title),\n              // `boolean` 的用法是資料必須是指定的布林值\n              completed: MatchersV3.boolean(responseExample.todo.completed),\n            }),\n          },\n        });\n    });\n\n    // ...\n  });\n});\n```\n\n定義好預期的請求與回應之後，可以透過 `executeTest` 來執行測試，會使用 Pact 啟動的 Mock Server 供 Consumer 進行行為的驗證。以範例來說，會針對與 Provider 互動的 `TodoService#createTodo` 方法進行行為驗證：\n\n```typescript\ndescribe('Todo API Pact test', () => {\n  // ...\n\n  describe('When call the createTodo method of TodoService.', () => {\n    // ...\n\n    it('should return a created todo.', async () => {\n      await provider.executeTest(async (mockServer) => {\n        // 指定存取的 url 為 Mock Server 提供的 url\n        config.apiUrl = mockServer.url;\n        const payload: CreateTodo = { title: responseExample.todo.title };\n        const expectedResponse: CreatedTodo = {\n          todo: {\n            ...responseExample.todo,\n            id: expect.any(String),\n          },\n        };\n\n        const response = await lastValueFrom(todoService.createTodo(payload));\n\n        // 檢查 `TodoService` 的 `createTodo` 方法回傳值是否符合預期\n        expect(response).toEqual(expectedResponse);\n      });\n    });\n  });\n});\n```\n\n### 撰寫取得 Todo 的測試\n\n先假設 Provider 提供 `[GET] /api/todos` API 回應的 HTTP Code 為 `200` 且 Body 格式如下：\n\n```typescript\ntype FoundTodo = {\n  todo: Todo | null;\n}\n```\n\n#### Consumer\n\n與撰寫建立 Todo 測試時的寫法大同小異，不過以取得 Todo 的情境來說，會分成「有找到 Todo」跟「沒找到 Todo」兩個情境。另外，為了要驗證取得的 Todo 符合 Consumer 所定義的格式，在雙方不 hardcode 的情況下，可以運用 `given` 讓 Consumer 傳遞 **狀態(State)** 給 Provider，Provider 會根據 State 做出對應的策略，以這個範例來說，Consumer 會將預期收到的 Todo 格式傳遞給 Provider，Provider 會在執行驗證之前，將該筆資料準備好，避免因 State 問題導致測試出錯：\n\n```typescript\ndescribe('Todo API Pact test', () => {\n  // ...\n\n  describe('When call the getTodoById method of TodoService.', () => {\n    let responseExample: FoundTodo;\n\n    describe('When the todo exists.', () => {\n      beforeAll(() => {\n        responseExample = {\n          todo: {\n            id: crypto.randomUUID(),\n            title: 'todo 1',\n            completed: false,\n          },\n        };\n      });\n\n      beforeAll(() => {\n        provider\n          // 透過 `given` 傳遞 State，確保執行驗證之前一定有這筆資料\n          .given('The todo exists', { todo: responseExample.todo })\n          .uponReceiving('a request to get a todo')\n          .withRequest({\n            method: 'GET',\n            path: `/api/todos/${responseExample.todo.id}`,\n          })\n          .willRespondWith({\n            status: HttpStatus.OK,\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: {\n              todo: MatchersV3.like({\n                id: MatchersV3.string(responseExample.todo.id),\n                title: MatchersV3.string(responseExample.todo.title),\n                completed: MatchersV3.boolean(responseExample.todo.completed),\n              }),\n            },\n          });\n      });\n\n      it('should return the todo.', async () => {\n        await provider.executeTest(async (mockServer) => {\n          config.apiUrl = mockServer.url;\n          const expectedResponse: FoundTodo = {\n            todo: {\n              ...responseExample.todo,\n            },\n          };\n\n          const response = await lastValueFrom(\n            todoService.getTodoById(responseExample.todo.id)\n          );\n\n          expect(response).toEqual(expectedResponse);\n        });\n      });\n    });\n\n    describe('When the todo does not exist.', () => {\n      const TODO_ID = '2';\n\n      beforeAll(() => {\n        responseExample = {\n          todo: null,\n        };\n      });\n\n      beforeAll(() => {\n        provider\n          .uponReceiving('a request to get a null todo')\n          .withRequest({\n            method: 'GET',\n            path: `/api/todos/${TODO_ID}`,\n          })\n          .willRespondWith({\n            status: HttpStatus.OK,\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: {\n              todo: MatchersV3.nullValue(),\n            },\n          });\n      });\n\n      it('should return null.', async () => {\n        await provider.executeTest(async (mockServer) => {\n          config.apiUrl = mockServer.url;\n          const expectedResponse: FoundTodo = {\n            todo: null,\n          };\n\n          const response = await lastValueFrom(\n            todoService.getTodoById(TODO_ID)\n          );\n\n          expect(response).toEqual(expectedResponse);\n        });\n      });\n    });\n  });\n\n  // ...\n});\n```\n\n#### Provider\n\n針對傳遞狀態的部分需要額外做處理，Pact 有提供 `stateHandlers` 讓我們可以根據不同情況執行不同策略進而處理 State。以前面 Consumer 傳遞的 `The todo exists` 來說，Provider 需要將傳遞進來的資料寫入 `TodoTestingRepository` 內，這樣在執行 API 存取時，就一定會有該筆資料存在。下方是範例程式碼：\n\n```typescript\n// ...\n\ndescribe('Todo API Pact validation', () => {\n  // ...\n\n  beforeAll(async () => {\n    const moduleRef = await Test.createTestingModule({\n      imports: [\n        // ...\n        PactProviderModule.registerAsync({\n          imports: [TodoTestingModule],\n          inject: [TodoRepository],\n          useFactory: (todoRepository: TodoTestingRepository) => {\n            return {\n              stateHandlers: {\n                'The todo exists': async (params) => {\n                  const { todo } = params as unknown as { todo: Todo };\n                  return lastValueFrom(todoRepository.appendTodo(todo));\n                },\n              },\n              pactUrls: [\n                path.resolve(process.cwd(), 'pacts', 'apps', 'consumer', 'TodoConsumer-TodoProvider.json'),\n              ],\n            };\n          },\n        }),\n      ],\n    })\n    .compile();\n    // ...\n  });\n\n  // ...\n});\n```\n\n> **注意**：上方程式碼中，將 `params` 強制轉型的原因是 Pact 在型別定義是寫 `string`，但事實上該參數的型別為 Consumer 傳遞的 State。\n\n### 執行驗證\n\n> **補充**：關於「完成 Todo 的測試」與「刪除 Todo 的測試」就不額外佔篇幅來寫了，處理方式大同小異。\n\n當 Consumer 執行測試時，成功的畫面如下圖：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"consumer-test-result.png\"\n  alt=\"Consumer Test Result\"\n/>\n\n並且會如預期產生一個 Contract 檔案：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"generated-contract.png\"\n  alt=\"Generated Contract\"\n/>\n\n此時執行 Provider 的測試時，成功的畫面如下圖：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"provider-test-result.png\"\n  alt=\"Provider Test Result\"\n/>\n\n## 結論\n\n當我們在微服務架構中導入 Contract Testing 時，能在開發過程中即時發現潛在的 API 變更問題。本篇文章是以手動執行 Contract Testing 的角度來撰寫，但實務上，手動執行 Contract Testing 並不足以應對持續變動的系統環境，因此將 Contract Testing 納入 CI/CD 流程成為關鍵的一環。\n\n透過 CI/CD，我們可以在每次變更時自動執行 Contract Testing，確保 API 的更新不會破壞現有的依賴關係。這不僅能減少因 API 變更導致的溝通成本，也能讓團隊更有信心地進行版本演進。此外，Pact 還有提供 [Pact Broker](https://docs.pact.io/getting_started/sharing_pacts) 這個工具，在 CI/CD 驅動驗證的流程中扮演了不可或缺的角色。它能夠集中管理所有 Contract，確保 Provider 與 Consumer 之間的 Contract 始終保持一致。\n\n最終，Contract Testing 與 CI/CD 的結合，使得 API 變更的驗證變得自動化、可預測，進而提升整體開發的穩定性。透過 Pact Broker，團隊可以輕鬆管理不同版本的 Contract，並確保每一次的部署都是在雙方協議之下進行，真正落實契約驅動的 API 開發模式。\n\n","source":"_posts/0005-nestjs-pact.md","raw":"---\ntitle: 在 NestJS 使用 Pact 實現契約測試\ndate: 2025-03-08 17:20:00\ntags:\n  - Backend\n  - NestJS\n  - Contract Testing\n  - Pact\ncategories:\n  - ['Backend', 'NestJS', 'Contract Testing']\n---\n\n在微服務架構中，各個服務由不同團隊獨立開發、部署與維運，這樣的彈性雖然增加了開發效率，但也同時導致服務間互動的不確定性。如何確保每個服務在獨立更新的同時，仍能正確溝通與協作？ **契約測試(Contract Testing)** 正是解決這一問題的有效工具。\n\n## 什麼是 Contract Testing？\n\nContract Testing 是一種專注於驗證服務間 **介面(Interface)** 正確性的自動化測試方法。此方法論會將服務區分成兩個角色：\n\n* **提供者(Provider)** ：提供 API 的服務。\n* **消費者(Consumer)** ：使用 Provider 提供的 API 的服務。\n\nProvider 與 Consumer 之間會 **提前** 約定好 Interface，包含：請求格式、回應格式、錯誤處理機制等。這種約定可以是 OpenAPI、JSON Schema 或是其他 Contract Testing 工具來作為服務間共同遵循的標準，這套約定即 **契約(Contract)** 。而 Contract Testing 有兩種方法，分別是： **消費者驅動的契約測試(Consumer-Driven Contract Testing)** 與 **提供者驅動的契約測試(Provider-Driven Contract Testing)** 。\n\n> **注意**：Contract Testing 並 **不會也不該** 驗證 **完整的** Provider 商業邏輯，僅聚焦在 Interface 的驗證，商業邏輯的部分應屬於 **單元測試(Unit Testing)** 的範疇。\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"contract-testing-concept.png\"\n  alt=\"Contract testing concept\"\n/>\n\n### Consumer-Driven Contract Testing\n\n這類型的 Contract Testing 是由 **Consumer 定義契約內容來確保 Provider 提供的服務是否滿足它的期望**。這樣的好處是 Provider 可以根據 Consumer 的實際需求來驗證與實作，達到快速反饋以及減少整合風險的效果，是一個適合內部團隊使用的 Contract Testing 方法。\n\n### Provider-Driven Contract Testing\n\n這類型的 Contract Testing 是由 **Provider 定義契約內容來統一管理 API 的文件與版本**。這樣的好處是 Provider 可以讓所有 Consumer 依據統一的標準進行開發，是一個適合用於對外公開 API 的 Contract Testing 方法。\n\n## 為什麼需要 Contract Testing？\n\n如文章開頭所述，微服務架構使得服務之間的互動增加了不確定性，如果沒有驗證互動正確性的方式，當服務的 Interface 頻繁發生變化時，有可能會因此導致其他服務無法正常運作，造成損失。如果導入 Contract Testing 則可以提早捕捉到不兼容的問題，避免整合時才發現有這個狀況發生。另外，在驗證服務間是否如預期運作最常見的方式即 **端對端測試(E2E Testing)** ，但測試過程可能會涉及許多複雜的商業邏輯與其他依賴的項目，針對僅需驗證 Consumer 與 Provider 之間 Interface 是否符合預期的情境，使用成本較高且流程繁複的 E2E Testing 顯得有些大材小用，使用對完整環境要求低、能夠驗證 Interface 是否符合預期的 Contract Testing 會是更好的選擇。\n\n## Pact\n\nPact 是一套 **程式碼優先(code-first)** 的 Consumer-Driven Contract Testing 工具，提供多種程式語言的實作，如：[JavaScript](https://docs.pact.io/implementation_guides/javascript/readme)、[Java](https://docs.pact.io/implementation_guides/jvm)、[Golang](https://docs.pact.io/implementation_guides/go) 等。\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-logo.png\"\n  alt=\"Pact logo\"\n/>\n\n[圖片來源](https://docs.pact.io/implementation_guides/javascript/readme)\n\n### Pact 的運作流程\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-flow-concept.png\"\n  alt=\"Pact flow concept\"\n/>\n\n[圖片來源](https://docs.pact.io/)\n\nPact 在運作流程上可以拆成兩個階段： **Consumer 階段** 與 **Provider 階段** ：\n\n#### Consumer 階段\n\nConsumer 在自己的測試中使用對應語言的 Pact 函式庫來定義預期的請求(HTTP Method、Path、Headers、Body 等)與回應格式(HTTP Code、Headers、Response Body 等)。測試執行期間，Pact 會啟動一個 Mock Server，Consumer 發送的請求會送到這個 Server，並會收到事前定義好的回應。測試完成後，Pact 會根據這些定義產生一個 JSON 格式的 Contract，用來記錄 Consumer 所期望的 Interface。\n\n#### Provider 階段\n\nProvider 要使用 Consumer 定義的 Contract 來驗證服務提供的內容是否符合期望，所以必須在測試時啟動服務，並使用對應語言的 Pact 函式庫來執行 **Pact 驗證工具(Pact Verifier)** ，會讀取 Consumer 產生的 Contract 檔案並 **重放(Replay)** Contract 內定義的請求，進而驗證服務最終回傳的內容符合 Contract 內定義的格式。如果驗證結果發現回應的格式不如預期，此 Contract Testing 就會失敗，如此一來，便可以及早發現 Interface 不符期待的問題。\n\n## NestJS 與 Pact\n\nPact 有提供 [PactJS](https://docs.pact.io/implementation_guides/javascript/readme) 套件供 JavaScript、TypeScript 開發者使用。NestJS 固然可以在既有的測試流程中使用此套件來實現 Contract Testing，甚至官方還為 NestJS 實作了 [nestjs-pact](https://github.com/pact-foundation/nestjs-pact) 套件，十分貼心！\n\n### 前置作業\n\n假設已經有兩個基於 NestJS 實作的服務，一個是 Consumer、一個是 Provider，這些服務的專案需透過下方指令將 Pact 相關套件進行安裝：\n\n```bash\n$ npm install nestjs-pact @pact-foundation/pact -D\n```\n\n#### Consumer 測試的前置作業\n\n假設 Consumer 這個專案有一個 `TodoModule`，該 Module 內有 `TodoController` 與 `TodoService` 並匯入了 `HttpModule` 來呼叫 API。下方是 `TodoController`、`TodoService` 與 `HttpService` 之間的關係，以類別圖來呈現：\n\n{% mermaid %}\nclassDiagram\n  class HttpService {\n    +get(url)\n    +post(url, payload)\n    +delete(url)\n  }\n\n  class TodoService {\n    -HttpService httpService\n    -TodoConfig config\n    -String todoApiUrl\n    +createTodo(payload)\n    +getTodoById(id)\n    +completeTodoById(id, completed)\n    +deleteTodoById(id)\n  }\n\n  class TodoController {\n    -TodoService todoService\n    +createTodo(payload)\n    +getTodo(id)\n    +completeTodo(id, payload)\n    +deleteTodo(id)\n  }\n\n  TodoService --> HttpService\n  TodoController --> TodoService\n{% endmermaid %}\n\n前面有提到 Contract Testing 是驗證服務間 Interface 的測試方法，對 Consumer 而言，與 Provider 互動的元件為 `TodoService`，所以針對 `TodoService` 撰寫 Contract。那要如何開始呢？首先，會需要建立 Pact 的實例，這邊可以使用 `PactV3` 這個類，是目前的主要版本：\n\n```typescript\ndescribe('Todo API Pact test', () => {\n  let provider: PactV3;\n  // ...\n\n  beforeAll(() => {\n    provider = new PactV3({\n      consumer: 'TodoConsumer',\n      provider: 'TodoProvider',\n      port: 1234,\n      dir: path.resolve(process.cwd(), 'pacts', 'apps', 'consumer'),\n      logLevel: 'info',\n    });\n  });\n\n  // ...\n});\n```\n\n上方是建立 `PactV3` 實例的方式，可以看到有幾個參數：\n\n* `consumer`：Consumer 的名稱。\n* `provider`：Provider 的名稱。\n* `port`：Pact 在執行測試時，會啟動一個 Mock Server，此參數即 Mock Server 的 port。\n* `dir`：執行測試後會產生 Contract 檔案，會將檔案存放在此資料夾下。\n* `logLevel`：執行測試時要顯示的 Log Level。\n\n建立完畢後，緊接著就可以進行 NestJS 測試的前置作業：\n\n```typescript\ndescribe('Todo API Pact test', () => {\n  let provider: PactV3;\n  let moduleRef: TestingModule;\n  let todoService: TodoService;\n  let config: TodoConfig;\n\n  // ...\n\n  beforeEach(async () => {\n    moduleRef = await Test.createTestingModule({\n      imports: [\n        HttpModule.register({\n          httpAgent: new Agent({ keepAlive: false }),\n        }),\n      ],\n      providers: [\n        TodoService,\n        {\n          provide: todoConfig.KEY,\n          useValue: {\n            apiUrl: '',\n          },\n        },\n      ],\n    }).compile();\n    todoService = moduleRef.get(TodoService);\n    config = moduleRef.get(todoConfig.KEY);\n  });\n});\n```\n\n> **補充** ：上方範例可以看到 `HttpModule` 使用了 `Agent` 並將 `keepAlive` 設為 `false`，這是因為如果沒有這樣設定，預設會是 `true`，會導致 Mock Server 出錯。\n\n一切準備就緒後，就可以來針對 `TodoService` 與 Provider 互動的方法進行測試了。\n\n#### Provider 測試的前置作業\n\n假設 Provider 這個專案有一個 `TodoModule`，該 Module 內有 `TodoController`、`TodoService` 與 `TodoRepository`，其中，`TodoRepository` 會負責與資料庫進行互動。下方是 `TodoController`、`TodoService` 與 `TodoRepository` 之間的關係，以類別圖來呈現：\n\n{% mermaid %}\nclassDiagram\n  class TodoRepository {\n    +createTodo(params)\n    +getTodoById(id)\n    +completeTodoById(id, completed)\n    +deleteTodoById(id)\n  }\n\n  class TodoService {\n    -TodoRepository todoRepository\n    +createTodo(payload)\n    +getTodoById(id)\n    +completeTodoById(id, completed)\n    +deleteTodoById(id)\n  }\n\n  class TodoController {\n    -TodoService todoService\n    +createTodo(payload)\n    +getTodoById(id)\n    +completeTodoById(id, payload)\n    +deleteTodoById(id)\n  }\n\n  TodoService --> TodoRepository\n  TodoController --> TodoService\n{% endmermaid %}\n\n前面有提到 Provider 在執行 Contract Testing 時，會需要啟動服務來進行驗證，但啟動服務並不是希望驗證完整的商業邏輯，只是要確定 API 的結果是符合期望的，所以需要把一些依賴去除掉，以上方範例來說，我們可以將 `TodoRepository` 透過 **樁(Stub)** 的方式進行處理。這邊先撰寫一個 `TodoTestingRepository`：\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { Observable, of } from 'rxjs';\nimport { CreateTodo, Todo } from '@pact-example/todo/domain';\n\n@Injectable()\nexport class TodoTestingRepository {\n  private readonly todos: Array<Todo> = [];\n\n  createTodo(params: CreateTodo): Observable<Todo> {\n    const todo: Todo = {\n      id: crypto.randomUUID(),\n      title: params.title,\n      completed: false,\n    };\n    this.todos.push(todo);\n    return of(todo);\n  }\n\n  appendTodo(todo: Todo): Observable<Todo> {\n    const existTodo = this.todos.find((x) => x.id === todo.id);\n    if (existTodo) {\n      Object.assign(existTodo, todo);\n      return of(existTodo);\n    }\n    this.todos.push(todo);\n    return of(todo);\n  }\n\n  getTodoById(id: string): Observable<Todo | null> {\n    return of(this.todos.find((todo) => todo.id === id) ?? null);\n  }\n\n  completeTodoById(id: string, completed: boolean): Observable<Todo | null> {\n    const todo = this.todos.find((todo) => todo.id === id);\n    if (todo) {\n      todo.completed = completed;\n    }\n    return of(todo ?? null);\n  }\n\n  deleteTodoById(id: string): Observable<Todo | null> {\n    const index = this.todos.findIndex((todo) => todo.id === id);\n    if (index !== -1) {\n      return of(this.todos.splice(index, 1)[0]);\n    }\n    return of(null);\n  }\n}\n```\n\n這裡建立一個 `TodoTestingModule` 將 `TodoRepository` 當作 `TodoTestingRepository` 的 Token：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { TodoController } from '../../../app/todo/todo.controller';\nimport { TodoService } from '../../../app/todo/todo.service';\nimport { TodoRepository } from '../../../app/todo/todo.repository';\nimport { TodoTestingRepository } from './todo-testing.repository';\n\n@Module({\n  controllers: [TodoController],\n  providers: [\n    TodoService,\n    TodoTestingRepository,\n    {\n      provide: TodoRepository,\n      useExisting: TodoTestingRepository,\n    },\n  ],\n  exports: [TodoRepository],\n})\nexport class TodoTestingModule {}\n```\n\n這些都完成後，就可以來建置 Provider 的測試了。將 NestJS 測試的前置作業建立起來：\n\n```typescript\n// ...\ndescribe('Todo API Pact validation', () => {\n  let app: INestApplication;\n  const consoleLogger = new ConsoleLogger();\n\n  beforeAll(async () => {\n    const moduleRef = await Test.createTestingModule({\n      imports: [TodoTestingModule],\n    })\n    .compile();\n    app = moduleRef.createNestApplication();\n    app.setGlobalPrefix('api');\n    await app.init();\n  });\n\n  // ...\n\n  afterAll(async () => {\n    await app.close();\n  });\n});\n```\n\n接著，使用 `nestjs-pact` 提供的 `PactProviderModule` 來建立 Pact Verifier，在建立的時候，假如是採用讀取 Contract 檔案的方式，就需要帶入 `pactUrls` 這個參數。當一切就緒後，透過 `PactVerifierService` 的 `verify` 方法即可執行驗證：\n\n```typescript\n// ...\n// 避免 Contract Testing 超時\njest.setTimeout(60 * 1000);\n\ndescribe('Todo API Pact validation', () => {\n  // ...\n  let verifier: PactVerifierService;\n\n  beforeAll(async () => {\n    const moduleRef = await Test.createTestingModule({\n      imports: [\n        // ...\n        PactProviderModule.registerAsync({\n          useFactory: () => {\n            return {\n              pactUrls: [\n                path.resolve(process.cwd(), 'pacts', 'apps', 'consumer', 'TodoConsumer-TodoProvider.json'),\n              ],\n            };\n          },\n        }),\n      ],\n    })\n    .compile();\n    verifier = moduleRef.get(PactVerifierService);\n    // ...\n  });\n\n  // 執行驗證\n  it('should validate the pact contract', async () => {\n    await verifier.verify(app);\n    consoleLogger.log('Pact Verification Completed!');\n  });\n\n  // ...\n});\n```\n\n### 撰寫建立 Todo 的測試\n\n先假設 Provider 提供的 `[POST] /api/todos` API 的請求 Payload 如下：\n\n```typescript\ntype CreateTodo = {\n  title: string;\n};\n```\n\n回應的 HTTP Code 為 `201` 且 Body 格式如下：\n\n```typescript\ntype CreatedTodo = {\n  todo: {\n    id: string;\n    title: string;\n    completed: boolean;\n  };\n};\n```\n\n#### Consumer\n\n透過 `PactV3` 的 `withRequest` 定義發送請求的格式，以 `[POST] /api/todos` 來說，`method` 會定為 `POST`、`path` 會定為 `/api/todos`、`body` 會定為 `CreateTodo` 的格式。而預期的回應則透過 `withResponseWith` 來設置，`status` 會是 `201`、`headers` 會含有 `Content-Type` 為 `application/json` 的值，比較特別的是，`body` 使用了 Pact 提供的 `MatchersV3` 來輔助驗證格式與資料，達到更精準的驗證，同時也可以減少 hardcode 測試資料的情況。下方為範例程式碼：\n\n```typescript\ndescribe('Todo API Pact test', () => {\n  // ...\n\n  describe('When call the createTodo method of TodoService.', () => {\n    const responseExample: CreatedTodo = {\n      todo: {\n        id: '1',\n        title: 'todo 1',\n        completed: false,\n      },\n    };\n\n    beforeAll(() => {\n      provider\n        .uponReceiving('a request to create a todo')\n        .withRequest({\n          method: 'POST',\n          path: '/api/todos',\n          body: {\n            title: responseExample.todo.title,\n          },\n        })\n        .willRespondWith({\n          status: HttpStatus.CREATED,\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: {\n            // `like` 的用法是要求值要跟提供的模板是相同的類型\n            todo: MatchersV3.like({\n              // `uuid` 的用法是資料必須符合 UUID 的格式\n              id: MatchersV3.uuid(), \n              // `string` 的用法是資料必須是指定的字串\n              title: MatchersV3.string(responseExample.todo.title),\n              // `boolean` 的用法是資料必須是指定的布林值\n              completed: MatchersV3.boolean(responseExample.todo.completed),\n            }),\n          },\n        });\n    });\n\n    // ...\n  });\n});\n```\n\n定義好預期的請求與回應之後，可以透過 `executeTest` 來執行測試，會使用 Pact 啟動的 Mock Server 供 Consumer 進行行為的驗證。以範例來說，會針對與 Provider 互動的 `TodoService#createTodo` 方法進行行為驗證：\n\n```typescript\ndescribe('Todo API Pact test', () => {\n  // ...\n\n  describe('When call the createTodo method of TodoService.', () => {\n    // ...\n\n    it('should return a created todo.', async () => {\n      await provider.executeTest(async (mockServer) => {\n        // 指定存取的 url 為 Mock Server 提供的 url\n        config.apiUrl = mockServer.url;\n        const payload: CreateTodo = { title: responseExample.todo.title };\n        const expectedResponse: CreatedTodo = {\n          todo: {\n            ...responseExample.todo,\n            id: expect.any(String),\n          },\n        };\n\n        const response = await lastValueFrom(todoService.createTodo(payload));\n\n        // 檢查 `TodoService` 的 `createTodo` 方法回傳值是否符合預期\n        expect(response).toEqual(expectedResponse);\n      });\n    });\n  });\n});\n```\n\n### 撰寫取得 Todo 的測試\n\n先假設 Provider 提供 `[GET] /api/todos` API 回應的 HTTP Code 為 `200` 且 Body 格式如下：\n\n```typescript\ntype FoundTodo = {\n  todo: Todo | null;\n}\n```\n\n#### Consumer\n\n與撰寫建立 Todo 測試時的寫法大同小異，不過以取得 Todo 的情境來說，會分成「有找到 Todo」跟「沒找到 Todo」兩個情境。另外，為了要驗證取得的 Todo 符合 Consumer 所定義的格式，在雙方不 hardcode 的情況下，可以運用 `given` 讓 Consumer 傳遞 **狀態(State)** 給 Provider，Provider 會根據 State 做出對應的策略，以這個範例來說，Consumer 會將預期收到的 Todo 格式傳遞給 Provider，Provider 會在執行驗證之前，將該筆資料準備好，避免因 State 問題導致測試出錯：\n\n```typescript\ndescribe('Todo API Pact test', () => {\n  // ...\n\n  describe('When call the getTodoById method of TodoService.', () => {\n    let responseExample: FoundTodo;\n\n    describe('When the todo exists.', () => {\n      beforeAll(() => {\n        responseExample = {\n          todo: {\n            id: crypto.randomUUID(),\n            title: 'todo 1',\n            completed: false,\n          },\n        };\n      });\n\n      beforeAll(() => {\n        provider\n          // 透過 `given` 傳遞 State，確保執行驗證之前一定有這筆資料\n          .given('The todo exists', { todo: responseExample.todo })\n          .uponReceiving('a request to get a todo')\n          .withRequest({\n            method: 'GET',\n            path: `/api/todos/${responseExample.todo.id}`,\n          })\n          .willRespondWith({\n            status: HttpStatus.OK,\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: {\n              todo: MatchersV3.like({\n                id: MatchersV3.string(responseExample.todo.id),\n                title: MatchersV3.string(responseExample.todo.title),\n                completed: MatchersV3.boolean(responseExample.todo.completed),\n              }),\n            },\n          });\n      });\n\n      it('should return the todo.', async () => {\n        await provider.executeTest(async (mockServer) => {\n          config.apiUrl = mockServer.url;\n          const expectedResponse: FoundTodo = {\n            todo: {\n              ...responseExample.todo,\n            },\n          };\n\n          const response = await lastValueFrom(\n            todoService.getTodoById(responseExample.todo.id)\n          );\n\n          expect(response).toEqual(expectedResponse);\n        });\n      });\n    });\n\n    describe('When the todo does not exist.', () => {\n      const TODO_ID = '2';\n\n      beforeAll(() => {\n        responseExample = {\n          todo: null,\n        };\n      });\n\n      beforeAll(() => {\n        provider\n          .uponReceiving('a request to get a null todo')\n          .withRequest({\n            method: 'GET',\n            path: `/api/todos/${TODO_ID}`,\n          })\n          .willRespondWith({\n            status: HttpStatus.OK,\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: {\n              todo: MatchersV3.nullValue(),\n            },\n          });\n      });\n\n      it('should return null.', async () => {\n        await provider.executeTest(async (mockServer) => {\n          config.apiUrl = mockServer.url;\n          const expectedResponse: FoundTodo = {\n            todo: null,\n          };\n\n          const response = await lastValueFrom(\n            todoService.getTodoById(TODO_ID)\n          );\n\n          expect(response).toEqual(expectedResponse);\n        });\n      });\n    });\n  });\n\n  // ...\n});\n```\n\n#### Provider\n\n針對傳遞狀態的部分需要額外做處理，Pact 有提供 `stateHandlers` 讓我們可以根據不同情況執行不同策略進而處理 State。以前面 Consumer 傳遞的 `The todo exists` 來說，Provider 需要將傳遞進來的資料寫入 `TodoTestingRepository` 內，這樣在執行 API 存取時，就一定會有該筆資料存在。下方是範例程式碼：\n\n```typescript\n// ...\n\ndescribe('Todo API Pact validation', () => {\n  // ...\n\n  beforeAll(async () => {\n    const moduleRef = await Test.createTestingModule({\n      imports: [\n        // ...\n        PactProviderModule.registerAsync({\n          imports: [TodoTestingModule],\n          inject: [TodoRepository],\n          useFactory: (todoRepository: TodoTestingRepository) => {\n            return {\n              stateHandlers: {\n                'The todo exists': async (params) => {\n                  const { todo } = params as unknown as { todo: Todo };\n                  return lastValueFrom(todoRepository.appendTodo(todo));\n                },\n              },\n              pactUrls: [\n                path.resolve(process.cwd(), 'pacts', 'apps', 'consumer', 'TodoConsumer-TodoProvider.json'),\n              ],\n            };\n          },\n        }),\n      ],\n    })\n    .compile();\n    // ...\n  });\n\n  // ...\n});\n```\n\n> **注意**：上方程式碼中，將 `params` 強制轉型的原因是 Pact 在型別定義是寫 `string`，但事實上該參數的型別為 Consumer 傳遞的 State。\n\n### 執行驗證\n\n> **補充**：關於「完成 Todo 的測試」與「刪除 Todo 的測試」就不額外佔篇幅來寫了，處理方式大同小異。\n\n當 Consumer 執行測試時，成功的畫面如下圖：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"consumer-test-result.png\"\n  alt=\"Consumer Test Result\"\n/>\n\n並且會如預期產生一個 Contract 檔案：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"generated-contract.png\"\n  alt=\"Generated Contract\"\n/>\n\n此時執行 Provider 的測試時，成功的畫面如下圖：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"provider-test-result.png\"\n  alt=\"Provider Test Result\"\n/>\n\n## 結論\n\n當我們在微服務架構中導入 Contract Testing 時，能在開發過程中即時發現潛在的 API 變更問題。本篇文章是以手動執行 Contract Testing 的角度來撰寫，但實務上，手動執行 Contract Testing 並不足以應對持續變動的系統環境，因此將 Contract Testing 納入 CI/CD 流程成為關鍵的一環。\n\n透過 CI/CD，我們可以在每次變更時自動執行 Contract Testing，確保 API 的更新不會破壞現有的依賴關係。這不僅能減少因 API 變更導致的溝通成本，也能讓團隊更有信心地進行版本演進。此外，Pact 還有提供 [Pact Broker](https://docs.pact.io/getting_started/sharing_pacts) 這個工具，在 CI/CD 驅動驗證的流程中扮演了不可或缺的角色。它能夠集中管理所有 Contract，確保 Provider 與 Consumer 之間的 Contract 始終保持一致。\n\n最終，Contract Testing 與 CI/CD 的結合，使得 API 變更的驗證變得自動化、可預測，進而提升整體開發的穩定性。透過 Pact Broker，團隊可以輕鬆管理不同版本的 Contract，並確保每一次的部署都是在雙方協議之下進行，真正落實契約驅動的 API 開發模式。\n\n","slug":"0005-nestjs-pact","published":1,"updated":"2025-04-08T13:59:54.320Z","comments":1,"layout":"post","photos":[],"_id":"cm9tztuvz001cfqgxgtnqe0qv","content":"<p>在微服務架構中，各個服務由不同團隊獨立開發、部署與維運，這樣的彈性雖然增加了開發效率，但也同時導致服務間互動的不確定性。如何確保每個服務在獨立更新的同時，仍能正確溝通與協作？ <strong>契約測試(Contract Testing)</strong> 正是解決這一問題的有效工具。</p>\n<h2 id=\"什麼是-Contract-Testing？\"><a href=\"#什麼是-Contract-Testing？\" class=\"headerlink\" title=\"什麼是 Contract Testing？\"></a>什麼是 Contract Testing？</h2><p>Contract Testing 是一種專注於驗證服務間 <strong>介面(Interface)</strong> 正確性的自動化測試方法。此方法論會將服務區分成兩個角色：</p>\n<ul>\n<li><strong>提供者(Provider)</strong> ：提供 API 的服務。</li>\n<li><strong>消費者(Consumer)</strong> ：使用 Provider 提供的 API 的服務。</li>\n</ul>\n<p>Provider 與 Consumer 之間會 <strong>提前</strong> 約定好 Interface，包含：請求格式、回應格式、錯誤處理機制等。這種約定可以是 OpenAPI、JSON Schema 或是其他 Contract Testing 工具來作為服務間共同遵循的標準，這套約定即 <strong>契約(Contract)</strong> 。而 Contract Testing 有兩種方法，分別是： <strong>消費者驅動的契約測試(Consumer-Driven Contract Testing)</strong> 與 <strong>提供者驅動的契約測試(Provider-Driven Contract Testing)</strong> 。</p>\n<blockquote>\n<p><strong>注意</strong>：Contract Testing 並 <strong>不會也不該</strong> 驗證 <strong>完整的</strong> Provider 商業邏輯，僅聚焦在 Interface 的驗證，商業邏輯的部分應屬於 <strong>單元測試(Unit Testing)</strong> 的範疇。</p>\n</blockquote>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"contract-testing-concept.png\"\n  alt=\"Contract testing concept\"\n/></p>\n<h3 id=\"Consumer-Driven-Contract-Testing\"><a href=\"#Consumer-Driven-Contract-Testing\" class=\"headerlink\" title=\"Consumer-Driven Contract Testing\"></a>Consumer-Driven Contract Testing</h3><p>這類型的 Contract Testing 是由 <strong>Consumer 定義契約內容來確保 Provider 提供的服務是否滿足它的期望</strong>。這樣的好處是 Provider 可以根據 Consumer 的實際需求來驗證與實作，達到快速反饋以及減少整合風險的效果，是一個適合內部團隊使用的 Contract Testing 方法。</p>\n<h3 id=\"Provider-Driven-Contract-Testing\"><a href=\"#Provider-Driven-Contract-Testing\" class=\"headerlink\" title=\"Provider-Driven Contract Testing\"></a>Provider-Driven Contract Testing</h3><p>這類型的 Contract Testing 是由 <strong>Provider 定義契約內容來統一管理 API 的文件與版本</strong>。這樣的好處是 Provider 可以讓所有 Consumer 依據統一的標準進行開發，是一個適合用於對外公開 API 的 Contract Testing 方法。</p>\n<h2 id=\"為什麼需要-Contract-Testing？\"><a href=\"#為什麼需要-Contract-Testing？\" class=\"headerlink\" title=\"為什麼需要 Contract Testing？\"></a>為什麼需要 Contract Testing？</h2><p>如文章開頭所述，微服務架構使得服務之間的互動增加了不確定性，如果沒有驗證互動正確性的方式，當服務的 Interface 頻繁發生變化時，有可能會因此導致其他服務無法正常運作，造成損失。如果導入 Contract Testing 則可以提早捕捉到不兼容的問題，避免整合時才發現有這個狀況發生。另外，在驗證服務間是否如預期運作最常見的方式即 <strong>端對端測試(E2E Testing)</strong> ，但測試過程可能會涉及許多複雜的商業邏輯與其他依賴的項目，針對僅需驗證 Consumer 與 Provider 之間 Interface 是否符合預期的情境，使用成本較高且流程繁複的 E2E Testing 顯得有些大材小用，使用對完整環境要求低、能夠驗證 Interface 是否符合預期的 Contract Testing 會是更好的選擇。</p>\n<h2 id=\"Pact\"><a href=\"#Pact\" class=\"headerlink\" title=\"Pact\"></a>Pact</h2><p>Pact 是一套 <strong>程式碼優先(code-first)</strong> 的 Consumer-Driven Contract Testing 工具，提供多種程式語言的實作，如：<a href=\"https://docs.pact.io/implementation_guides/javascript/readme\">JavaScript</a>、<a href=\"https://docs.pact.io/implementation_guides/jvm\">Java</a>、<a href=\"https://docs.pact.io/implementation_guides/go\">Golang</a> 等。</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-logo.png\"\n  alt=\"Pact logo\"\n/></p>\n<p><a href=\"https://docs.pact.io/implementation_guides/javascript/readme\">圖片來源</a></p>\n<h3 id=\"Pact-的運作流程\"><a href=\"#Pact-的運作流程\" class=\"headerlink\" title=\"Pact 的運作流程\"></a>Pact 的運作流程</h3><p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-flow-concept.png\"\n  alt=\"Pact flow concept\"\n/></p>\n<p><a href=\"https://docs.pact.io/\">圖片來源</a></p>\n<p>Pact 在運作流程上可以拆成兩個階段： <strong>Consumer 階段</strong> 與 <strong>Provider 階段</strong> ：</p>\n<h4 id=\"Consumer-階段\"><a href=\"#Consumer-階段\" class=\"headerlink\" title=\"Consumer 階段\"></a>Consumer 階段</h4><p>Consumer 在自己的測試中使用對應語言的 Pact 函式庫來定義預期的請求(HTTP Method、Path、Headers、Body 等)與回應格式(HTTP Code、Headers、Response Body 等)。測試執行期間，Pact 會啟動一個 Mock Server，Consumer 發送的請求會送到這個 Server，並會收到事前定義好的回應。測試完成後，Pact 會根據這些定義產生一個 JSON 格式的 Contract，用來記錄 Consumer 所期望的 Interface。</p>\n<h4 id=\"Provider-階段\"><a href=\"#Provider-階段\" class=\"headerlink\" title=\"Provider 階段\"></a>Provider 階段</h4><p>Provider 要使用 Consumer 定義的 Contract 來驗證服務提供的內容是否符合期望，所以必須在測試時啟動服務，並使用對應語言的 Pact 函式庫來執行 <strong>Pact 驗證工具(Pact Verifier)</strong> ，會讀取 Consumer 產生的 Contract 檔案並 <strong>重放(Replay)</strong> Contract 內定義的請求，進而驗證服務最終回傳的內容符合 Contract 內定義的格式。如果驗證結果發現回應的格式不如預期，此 Contract Testing 就會失敗，如此一來，便可以及早發現 Interface 不符期待的問題。</p>\n<h2 id=\"NestJS-與-Pact\"><a href=\"#NestJS-與-Pact\" class=\"headerlink\" title=\"NestJS 與 Pact\"></a>NestJS 與 Pact</h2><p>Pact 有提供 <a href=\"https://docs.pact.io/implementation_guides/javascript/readme\">PactJS</a> 套件供 JavaScript、TypeScript 開發者使用。NestJS 固然可以在既有的測試流程中使用此套件來實現 Contract Testing，甚至官方還為 NestJS 實作了 <a href=\"https://github.com/pact-foundation/nestjs-pact\">nestjs-pact</a> 套件，十分貼心！</p>\n<h3 id=\"前置作業\"><a href=\"#前置作業\" class=\"headerlink\" title=\"前置作業\"></a>前置作業</h3><p>假設已經有兩個基於 NestJS 實作的服務，一個是 Consumer、一個是 Provider，這些服務的專案需透過下方指令將 Pact 相關套件進行安裝：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install nestjs-pact @pact-foundation/pact -D</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Consumer-測試的前置作業\"><a href=\"#Consumer-測試的前置作業\" class=\"headerlink\" title=\"Consumer 測試的前置作業\"></a>Consumer 測試的前置作業</h4><p>假設 Consumer 這個專案有一個 <code>TodoModule</code>，該 Module 內有 <code>TodoController</code> 與 <code>TodoService</code> 並匯入了 <code>HttpModule</code> 來呼叫 API。下方是 <code>TodoController</code>、<code>TodoService</code> 與 <code>HttpService</code> 之間的關係，以類別圖來呈現：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n    classDiagram\n  class HttpService {\n    +get(url)\n    +post(url, payload)\n    +delete(url)\n  }\n\n  class TodoService {\n    -HttpService httpService\n    -TodoConfig config\n    -String todoApiUrl\n    +createTodo(payload)\n    +getTodoById(id)\n    +completeTodoById(id, completed)\n    +deleteTodoById(id)\n  }\n\n  class TodoController {\n    -TodoService todoService\n    +createTodo(payload)\n    +getTodo(id)\n    +completeTodo(id, payload)\n    +deleteTodo(id)\n  }\n\n  TodoService --&gt; HttpService\n  TodoController --&gt; TodoService\n  </pre></div>\n\n<p>前面有提到 Contract Testing 是驗證服務間 Interface 的測試方法，對 Consumer 而言，與 Provider 互動的元件為 <code>TodoService</code>，所以針對 <code>TodoService</code> 撰寫 Contract。那要如何開始呢？首先，會需要建立 Pact 的實例，這邊可以使用 <code>PactV3</code> 這個類，是目前的主要版本：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact test&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">provider</span>: <span class=\"title class_\">PactV3</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">beforeAll</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    provider = <span class=\"keyword\">new</span> <span class=\"title class_\">PactV3</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">consumer</span>: <span class=\"string\">&#x27;TodoConsumer&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">provider</span>: <span class=\"string\">&#x27;TodoProvider&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">port</span>: <span class=\"number\">1234</span>,</span><br><span class=\"line\">      <span class=\"attr\">dir</span>: path.<span class=\"title function_\">resolve</span>(process.<span class=\"title function_\">cwd</span>(), <span class=\"string\">&#x27;pacts&#x27;</span>, <span class=\"string\">&#x27;apps&#x27;</span>, <span class=\"string\">&#x27;consumer&#x27;</span>),</span><br><span class=\"line\">      <span class=\"attr\">logLevel</span>: <span class=\"string\">&#x27;info&#x27;</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上方是建立 <code>PactV3</code> 實例的方式，可以看到有幾個參數：</p>\n<ul>\n<li><code>consumer</code>：Consumer 的名稱。</li>\n<li><code>provider</code>：Provider 的名稱。</li>\n<li><code>port</code>：Pact 在執行測試時，會啟動一個 Mock Server，此參數即 Mock Server 的 port。</li>\n<li><code>dir</code>：執行測試後會產生 Contract 檔案，會將檔案存放在此資料夾下。</li>\n<li><code>logLevel</code>：執行測試時要顯示的 Log Level。</li>\n</ul>\n<p>建立完畢後，緊接著就可以進行 NestJS 測試的前置作業：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact test&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">provider</span>: <span class=\"title class_\">PactV3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">moduleRef</span>: <span class=\"title class_\">TestingModule</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">todoService</span>: <span class=\"title class_\">TodoService</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">config</span>: <span class=\"title class_\">TodoConfig</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">beforeEach</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    moduleRef = <span class=\"keyword\">await</span> <span class=\"title class_\">Test</span>.<span class=\"title function_\">createTestingModule</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">        <span class=\"title class_\">HttpModule</span>.<span class=\"title function_\">register</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">httpAgent</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">Agent</span>(&#123; <span class=\"attr\">keepAlive</span>: <span class=\"literal\">false</span> &#125;),</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"attr\">providers</span>: [</span><br><span class=\"line\">        <span class=\"title class_\">TodoService</span>,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">provide</span>: todoConfig.<span class=\"property\">KEY</span>,</span><br><span class=\"line\">          <span class=\"attr\">useValue</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">apiUrl</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">compile</span>();</span><br><span class=\"line\">    todoService = moduleRef.<span class=\"title function_\">get</span>(<span class=\"title class_\">TodoService</span>);</span><br><span class=\"line\">    config = moduleRef.<span class=\"title function_\">get</span>(todoConfig.<span class=\"property\">KEY</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>補充</strong> ：上方範例可以看到 <code>HttpModule</code> 使用了 <code>Agent</code> 並將 <code>keepAlive</code> 設為 <code>false</code>，這是因為如果沒有這樣設定，預設會是 <code>true</code>，會導致 Mock Server 出錯。</p>\n</blockquote>\n<p>一切準備就緒後，就可以來針對 <code>TodoService</code> 與 Provider 互動的方法進行測試了。</p>\n<h4 id=\"Provider-測試的前置作業\"><a href=\"#Provider-測試的前置作業\" class=\"headerlink\" title=\"Provider 測試的前置作業\"></a>Provider 測試的前置作業</h4><p>假設 Provider 這個專案有一個 <code>TodoModule</code>，該 Module 內有 <code>TodoController</code>、<code>TodoService</code> 與 <code>TodoRepository</code>，其中，<code>TodoRepository</code> 會負責與資料庫進行互動。下方是 <code>TodoController</code>、<code>TodoService</code> 與 <code>TodoRepository</code> 之間的關係，以類別圖來呈現：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n    classDiagram\n  class TodoRepository {\n    +createTodo(params)\n    +getTodoById(id)\n    +completeTodoById(id, completed)\n    +deleteTodoById(id)\n  }\n\n  class TodoService {\n    -TodoRepository todoRepository\n    +createTodo(payload)\n    +getTodoById(id)\n    +completeTodoById(id, completed)\n    +deleteTodoById(id)\n  }\n\n  class TodoController {\n    -TodoService todoService\n    +createTodo(payload)\n    +getTodoById(id)\n    +completeTodoById(id, payload)\n    +deleteTodoById(id)\n  }\n\n  TodoService --&gt; TodoRepository\n  TodoController --&gt; TodoService\n  </pre></div>\n\n<p>前面有提到 Provider 在執行 Contract Testing 時，會需要啟動服務來進行驗證，但啟動服務並不是希望驗證完整的商業邏輯，只是要確定 API 的結果是符合期望的，所以需要把一些依賴去除掉，以上方範例來說，我們可以將 <code>TodoRepository</code> 透過 <strong>樁(Stub)</strong> 的方式進行處理。這邊先撰寫一個 <code>TodoTestingRepository</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Injectable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span>, <span class=\"keyword\">of</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CreateTodo</span>, <span class=\"title class_\">Todo</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@pact-example/todo/domain&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TodoTestingRepository</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">todos</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">Todo</span>&gt; = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">createTodo</span>(<span class=\"attr\">params</span>: <span class=\"title class_\">CreateTodo</span>): <span class=\"title class_\">Observable</span>&lt;<span class=\"title class_\">Todo</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">Todo</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">id</span>: crypto.<span class=\"title function_\">randomUUID</span>(),</span><br><span class=\"line\">      <span class=\"attr\">title</span>: params.<span class=\"property\">title</span>,</span><br><span class=\"line\">      <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">push</span>(todo);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(todo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">appendTodo</span>(<span class=\"attr\">todo</span>: <span class=\"title class_\">Todo</span>): <span class=\"title class_\">Observable</span>&lt;<span class=\"title class_\">Todo</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> existTodo = <span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">find</span>(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x.<span class=\"property\">id</span> === todo.<span class=\"property\">id</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existTodo) &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>(existTodo, todo);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(existTodo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">push</span>(todo);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(todo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">getTodoById</span>(<span class=\"attr\">id</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">Observable</span>&lt;<span class=\"title class_\">Todo</span> | <span class=\"literal\">null</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">find</span>(<span class=\"function\">(<span class=\"params\">todo</span>) =&gt;</span> todo.<span class=\"property\">id</span> === id) ?? <span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">completeTodoById</span>(<span class=\"attr\">id</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span>): <span class=\"title class_\">Observable</span>&lt;<span class=\"title class_\">Todo</span> | <span class=\"literal\">null</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> todo = <span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">find</span>(<span class=\"function\">(<span class=\"params\">todo</span>) =&gt;</span> todo.<span class=\"property\">id</span> === id);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (todo) &#123;</span><br><span class=\"line\">      todo.<span class=\"property\">completed</span> = completed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(todo ?? <span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">deleteTodoById</span>(<span class=\"attr\">id</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">Observable</span>&lt;<span class=\"title class_\">Todo</span> | <span class=\"literal\">null</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">findIndex</span>(<span class=\"function\">(<span class=\"params\">todo</span>) =&gt;</span> todo.<span class=\"property\">id</span> === id);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">splice</span>(index, <span class=\"number\">1</span>)[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這裡建立一個 <code>TodoTestingModule</code> 將 <code>TodoRepository</code> 當作 <code>TodoTestingRepository</code> 的 Token：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">TodoController</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../../../app/todo/todo.controller&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">TodoService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../../../app/todo/todo.service&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">TodoRepository</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../../../app/todo/todo.repository&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">TodoTestingRepository</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./todo-testing.repository&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">controllers</span>: [<span class=\"title class_\">TodoController</span>],</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">TodoService</span>,</span><br><span class=\"line\">    <span class=\"title class_\">TodoTestingRepository</span>,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">provide</span>: <span class=\"title class_\">TodoRepository</span>,</span><br><span class=\"line\">      <span class=\"attr\">useExisting</span>: <span class=\"title class_\">TodoTestingRepository</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">exports</span>: [<span class=\"title class_\">TodoRepository</span>],</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TodoTestingModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這些都完成後，就可以來建置 Provider 的測試了。將 NestJS 測試的前置作業建立起來：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact validation&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">app</span>: <span class=\"title class_\">INestApplication</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> consoleLogger = <span class=\"keyword\">new</span> <span class=\"title class_\">ConsoleLogger</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">beforeAll</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleRef = <span class=\"keyword\">await</span> <span class=\"title class_\">Test</span>.<span class=\"title function_\">createTestingModule</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">imports</span>: [<span class=\"title class_\">TodoTestingModule</span>],</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">compile</span>();</span><br><span class=\"line\">    app = moduleRef.<span class=\"title function_\">createNestApplication</span>();</span><br><span class=\"line\">    app.<span class=\"title function_\">setGlobalPrefix</span>(<span class=\"string\">&#x27;api&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> app.<span class=\"title function_\">init</span>();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">afterAll</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> app.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>接著，使用 <code>nestjs-pact</code> 提供的 <code>PactProviderModule</code> 來建立 Pact Verifier，在建立的時候，假如是採用讀取 Contract 檔案的方式，就需要帶入 <code>pactUrls</code> 這個參數。當一切就緒後，透過 <code>PactVerifierService</code> 的 <code>verify</code> 方法即可執行驗證：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"comment\">// 避免 Contract Testing 超時</span></span><br><span class=\"line\">jest.<span class=\"built_in\">setTimeout</span>(<span class=\"number\">60</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact validation&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">verifier</span>: <span class=\"title class_\">PactVerifierService</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">beforeAll</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleRef = <span class=\"keyword\">await</span> <span class=\"title class_\">Test</span>.<span class=\"title function_\">createTestingModule</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"title class_\">PactProviderModule</span>.<span class=\"title function_\">registerAsync</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">useFactory</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">              <span class=\"attr\">pactUrls</span>: [</span><br><span class=\"line\">                path.<span class=\"title function_\">resolve</span>(process.<span class=\"title function_\">cwd</span>(), <span class=\"string\">&#x27;pacts&#x27;</span>, <span class=\"string\">&#x27;apps&#x27;</span>, <span class=\"string\">&#x27;consumer&#x27;</span>, <span class=\"string\">&#x27;TodoConsumer-TodoProvider.json&#x27;</span>),</span><br><span class=\"line\">              ],</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">compile</span>();</span><br><span class=\"line\">    verifier = moduleRef.<span class=\"title function_\">get</span>(<span class=\"title class_\">PactVerifierService</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 執行驗證</span></span><br><span class=\"line\">  <span class=\"title function_\">it</span>(<span class=\"string\">&#x27;should validate the pact contract&#x27;</span>, <span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> verifier.<span class=\"title function_\">verify</span>(app);</span><br><span class=\"line\">    consoleLogger.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Pact Verification Completed!&#x27;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"撰寫建立-Todo-的測試\"><a href=\"#撰寫建立-Todo-的測試\" class=\"headerlink\" title=\"撰寫建立 Todo 的測試\"></a>撰寫建立 Todo 的測試</h3><p>先假設 Provider 提供的 <code>[POST] /api/todos</code> API 的請求 Payload 如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">CreateTodo</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>回應的 HTTP Code 為 <code>201</code> 且 Body 格式如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">CreatedTodo</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">todo</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h4><p>透過 <code>PactV3</code> 的 <code>withRequest</code> 定義發送請求的格式，以 <code>[POST] /api/todos</code> 來說，<code>method</code> 會定為 <code>POST</code>、<code>path</code> 會定為 <code>/api/todos</code>、<code>body</code> 會定為 <code>CreateTodo</code> 的格式。而預期的回應則透過 <code>withResponseWith</code> 來設置，<code>status</code> 會是 <code>201</code>、<code>headers</code> 會含有 <code>Content-Type</code> 為 <code>application/json</code> 的值，比較特別的是，<code>body</code> 使用了 Pact 提供的 <code>MatchersV3</code> 來輔助驗證格式與資料，達到更精準的驗證，同時也可以減少 hardcode 測試資料的情況。下方為範例程式碼：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact test&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;When call the createTodo method of TodoService.&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">responseExample</span>: <span class=\"title class_\">CreatedTodo</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">todo</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">id</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">&#x27;todo 1&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">beforeAll</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      provider</span><br><span class=\"line\">        .<span class=\"title function_\">uponReceiving</span>(<span class=\"string\">&#x27;a request to create a todo&#x27;</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">withRequest</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">method</span>: <span class=\"string\">&#x27;POST&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/api/todos&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">body</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">title</span>: responseExample.<span class=\"property\">todo</span>.<span class=\"property\">title</span>,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .<span class=\"title function_\">willRespondWith</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">status</span>: <span class=\"title class_\">HttpStatus</span>.<span class=\"property\">CREATED</span>,</span><br><span class=\"line\">          <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"attr\">body</span>: &#123;</span><br><span class=\"line\">            <span class=\"comment\">// `like` 的用法是要求值要跟提供的模板是相同的類型</span></span><br><span class=\"line\">            <span class=\"attr\">todo</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">like</span>(&#123;</span><br><span class=\"line\">              <span class=\"comment\">// `uuid` 的用法是資料必須符合 UUID 的格式</span></span><br><span class=\"line\">              <span class=\"attr\">id</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">uuid</span>(), </span><br><span class=\"line\">              <span class=\"comment\">// `string` 的用法是資料必須是指定的字串</span></span><br><span class=\"line\">              <span class=\"attr\">title</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">string</span>(responseExample.<span class=\"property\">todo</span>.<span class=\"property\">title</span>),</span><br><span class=\"line\">              <span class=\"comment\">// `boolean` 的用法是資料必須是指定的布林值</span></span><br><span class=\"line\">              <span class=\"attr\">completed</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">boolean</span>(responseExample.<span class=\"property\">todo</span>.<span class=\"property\">completed</span>),</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>定義好預期的請求與回應之後，可以透過 <code>executeTest</code> 來執行測試，會使用 Pact 啟動的 Mock Server 供 Consumer 進行行為的驗證。以範例來說，會針對與 Provider 互動的 <code>TodoService#createTodo</code> 方法進行行為驗證：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact test&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;When call the createTodo method of TodoService.&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">it</span>(<span class=\"string\">&#x27;should return a created todo.&#x27;</span>, <span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> provider.<span class=\"title function_\">executeTest</span>(<span class=\"title function_\">async</span> (mockServer) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 指定存取的 url 為 Mock Server 提供的 url</span></span><br><span class=\"line\">        config.<span class=\"property\">apiUrl</span> = mockServer.<span class=\"property\">url</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"attr\">payload</span>: <span class=\"title class_\">CreateTodo</span> = &#123; <span class=\"attr\">title</span>: responseExample.<span class=\"property\">todo</span>.<span class=\"property\">title</span> &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"attr\">expectedResponse</span>: <span class=\"title class_\">CreatedTodo</span> = &#123;</span><br><span class=\"line\">          <span class=\"attr\">todo</span>: &#123;</span><br><span class=\"line\">            ...responseExample.<span class=\"property\">todo</span>,</span><br><span class=\"line\">            <span class=\"attr\">id</span>: expect.<span class=\"title function_\">any</span>(<span class=\"title class_\">String</span>),</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">lastValueFrom</span>(todoService.<span class=\"title function_\">createTodo</span>(payload));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 檢查 `TodoService` 的 `createTodo` 方法回傳值是否符合預期</span></span><br><span class=\"line\">        <span class=\"title function_\">expect</span>(response).<span class=\"title function_\">toEqual</span>(expectedResponse);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"撰寫取得-Todo-的測試\"><a href=\"#撰寫取得-Todo-的測試\" class=\"headerlink\" title=\"撰寫取得 Todo 的測試\"></a>撰寫取得 Todo 的測試</h3><p>先假設 Provider 提供 <code>[GET] /api/todos</code> API 回應的 HTTP Code 為 <code>200</code> 且 Body 格式如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FoundTodo</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">todo</span>: <span class=\"title class_\">Todo</span> | <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Consumer-1\"><a href=\"#Consumer-1\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h4><p>與撰寫建立 Todo 測試時的寫法大同小異，不過以取得 Todo 的情境來說，會分成「有找到 Todo」跟「沒找到 Todo」兩個情境。另外，為了要驗證取得的 Todo 符合 Consumer 所定義的格式，在雙方不 hardcode 的情況下，可以運用 <code>given</code> 讓 Consumer 傳遞 <strong>狀態(State)</strong> 給 Provider，Provider 會根據 State 做出對應的策略，以這個範例來說，Consumer 會將預期收到的 Todo 格式傳遞給 Provider，Provider 會在執行驗證之前，將該筆資料準備好，避免因 State 問題導致測試出錯：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact test&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;When call the getTodoById method of TodoService.&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"attr\">responseExample</span>: <span class=\"title class_\">FoundTodo</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;When the todo exists.&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">beforeAll</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        responseExample = &#123;</span><br><span class=\"line\">          <span class=\"attr\">todo</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">id</span>: crypto.<span class=\"title function_\">randomUUID</span>(),</span><br><span class=\"line\">            <span class=\"attr\">title</span>: <span class=\"string\">&#x27;todo 1&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">beforeAll</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        provider</span><br><span class=\"line\">          <span class=\"comment\">// 透過 `given` 傳遞 State，確保執行驗證之前一定有這筆資料</span></span><br><span class=\"line\">          .<span class=\"title function_\">given</span>(<span class=\"string\">&#x27;The todo exists&#x27;</span>, &#123; <span class=\"attr\">todo</span>: responseExample.<span class=\"property\">todo</span> &#125;)</span><br><span class=\"line\">          .<span class=\"title function_\">uponReceiving</span>(<span class=\"string\">&#x27;a request to get a todo&#x27;</span>)</span><br><span class=\"line\">          .<span class=\"title function_\">withRequest</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">method</span>: <span class=\"string\">&#x27;GET&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">path</span>: <span class=\"string\">`/api/todos/<span class=\"subst\">$&#123;responseExample.todo.id&#125;</span>`</span>,</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .<span class=\"title function_\">willRespondWith</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"title class_\">HttpStatus</span>.<span class=\"property\">OK</span>,</span><br><span class=\"line\">            <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">              <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">body</span>: &#123;</span><br><span class=\"line\">              <span class=\"attr\">todo</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">like</span>(&#123;</span><br><span class=\"line\">                <span class=\"attr\">id</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">string</span>(responseExample.<span class=\"property\">todo</span>.<span class=\"property\">id</span>),</span><br><span class=\"line\">                <span class=\"attr\">title</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">string</span>(responseExample.<span class=\"property\">todo</span>.<span class=\"property\">title</span>),</span><br><span class=\"line\">                <span class=\"attr\">completed</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">boolean</span>(responseExample.<span class=\"property\">todo</span>.<span class=\"property\">completed</span>),</span><br><span class=\"line\">              &#125;),</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">it</span>(<span class=\"string\">&#x27;should return the todo.&#x27;</span>, <span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> provider.<span class=\"title function_\">executeTest</span>(<span class=\"title function_\">async</span> (mockServer) =&gt; &#123;</span><br><span class=\"line\">          config.<span class=\"property\">apiUrl</span> = mockServer.<span class=\"property\">url</span>;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> <span class=\"attr\">expectedResponse</span>: <span class=\"title class_\">FoundTodo</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">todo</span>: &#123;</span><br><span class=\"line\">              ...responseExample.<span class=\"property\">todo</span>,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">lastValueFrom</span>(</span><br><span class=\"line\">            todoService.<span class=\"title function_\">getTodoById</span>(responseExample.<span class=\"property\">todo</span>.<span class=\"property\">id</span>)</span><br><span class=\"line\">          );</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"title function_\">expect</span>(response).<span class=\"title function_\">toEqual</span>(expectedResponse);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;When the todo does not exist.&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"variable constant_\">TODO_ID</span> = <span class=\"string\">&#x27;2&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">beforeAll</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        responseExample = &#123;</span><br><span class=\"line\">          <span class=\"attr\">todo</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">beforeAll</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        provider</span><br><span class=\"line\">          .<span class=\"title function_\">uponReceiving</span>(<span class=\"string\">&#x27;a request to get a null todo&#x27;</span>)</span><br><span class=\"line\">          .<span class=\"title function_\">withRequest</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">method</span>: <span class=\"string\">&#x27;GET&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">path</span>: <span class=\"string\">`/api/todos/<span class=\"subst\">$&#123;TODO_ID&#125;</span>`</span>,</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .<span class=\"title function_\">willRespondWith</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"title class_\">HttpStatus</span>.<span class=\"property\">OK</span>,</span><br><span class=\"line\">            <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">              <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">body</span>: &#123;</span><br><span class=\"line\">              <span class=\"attr\">todo</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">nullValue</span>(),</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">it</span>(<span class=\"string\">&#x27;should return null.&#x27;</span>, <span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> provider.<span class=\"title function_\">executeTest</span>(<span class=\"title function_\">async</span> (mockServer) =&gt; &#123;</span><br><span class=\"line\">          config.<span class=\"property\">apiUrl</span> = mockServer.<span class=\"property\">url</span>;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> <span class=\"attr\">expectedResponse</span>: <span class=\"title class_\">FoundTodo</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">todo</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">lastValueFrom</span>(</span><br><span class=\"line\">            todoService.<span class=\"title function_\">getTodoById</span>(<span class=\"variable constant_\">TODO_ID</span>)</span><br><span class=\"line\">          );</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"title function_\">expect</span>(response).<span class=\"title function_\">toEqual</span>(expectedResponse);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Provider\"><a href=\"#Provider\" class=\"headerlink\" title=\"Provider\"></a>Provider</h4><p>針對傳遞狀態的部分需要額外做處理，Pact 有提供 <code>stateHandlers</code> 讓我們可以根據不同情況執行不同策略進而處理 State。以前面 Consumer 傳遞的 <code>The todo exists</code> 來說，Provider 需要將傳遞進來的資料寫入 <code>TodoTestingRepository</code> 內，這樣在執行 API 存取時，就一定會有該筆資料存在。下方是範例程式碼：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact validation&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">beforeAll</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleRef = <span class=\"keyword\">await</span> <span class=\"title class_\">Test</span>.<span class=\"title function_\">createTestingModule</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"title class_\">PactProviderModule</span>.<span class=\"title function_\">registerAsync</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">imports</span>: [<span class=\"title class_\">TodoTestingModule</span>],</span><br><span class=\"line\">          <span class=\"attr\">inject</span>: [<span class=\"title class_\">TodoRepository</span>],</span><br><span class=\"line\">          <span class=\"attr\">useFactory</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">todoRepository</span>: <span class=\"title class_\">TodoTestingRepository</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">              <span class=\"attr\">stateHandlers</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;The todo exists&#x27;</span>: <span class=\"title function_\">async</span> (params) =&gt; &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">const</span> &#123; todo &#125; = params <span class=\"keyword\">as</span> <span class=\"built_in\">unknown</span> <span class=\"keyword\">as</span> &#123; <span class=\"attr\">todo</span>: <span class=\"title class_\">Todo</span> &#125;;</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> <span class=\"title function_\">lastValueFrom</span>(todoRepository.<span class=\"title function_\">appendTodo</span>(todo));</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              <span class=\"attr\">pactUrls</span>: [</span><br><span class=\"line\">                path.<span class=\"title function_\">resolve</span>(process.<span class=\"title function_\">cwd</span>(), <span class=\"string\">&#x27;pacts&#x27;</span>, <span class=\"string\">&#x27;apps&#x27;</span>, <span class=\"string\">&#x27;consumer&#x27;</span>, <span class=\"string\">&#x27;TodoConsumer-TodoProvider.json&#x27;</span>),</span><br><span class=\"line\">              ],</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">compile</span>();</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong>：上方程式碼中，將 <code>params</code> 強制轉型的原因是 Pact 在型別定義是寫 <code>string</code>，但事實上該參數的型別為 Consumer 傳遞的 State。</p>\n</blockquote>\n<h3 id=\"執行驗證\"><a href=\"#執行驗證\" class=\"headerlink\" title=\"執行驗證\"></a>執行驗證</h3><blockquote>\n<p><strong>補充</strong>：關於「完成 Todo 的測試」與「刪除 Todo 的測試」就不額外佔篇幅來寫了，處理方式大同小異。</p>\n</blockquote>\n<p>當 Consumer 執行測試時，成功的畫面如下圖：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"consumer-test-result.png\"\n  alt=\"Consumer Test Result\"\n/></p>\n<p>並且會如預期產生一個 Contract 檔案：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"generated-contract.png\"\n  alt=\"Generated Contract\"\n/></p>\n<p>此時執行 Provider 的測試時，成功的畫面如下圖：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"provider-test-result.png\"\n  alt=\"Provider Test Result\"\n/></p>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>當我們在微服務架構中導入 Contract Testing 時，能在開發過程中即時發現潛在的 API 變更問題。本篇文章是以手動執行 Contract Testing 的角度來撰寫，但實務上，手動執行 Contract Testing 並不足以應對持續變動的系統環境，因此將 Contract Testing 納入 CI&#x2F;CD 流程成為關鍵的一環。</p>\n<p>透過 CI&#x2F;CD，我們可以在每次變更時自動執行 Contract Testing，確保 API 的更新不會破壞現有的依賴關係。這不僅能減少因 API 變更導致的溝通成本，也能讓團隊更有信心地進行版本演進。此外，Pact 還有提供 <a href=\"https://docs.pact.io/getting_started/sharing_pacts\">Pact Broker</a> 這個工具，在 CI&#x2F;CD 驅動驗證的流程中扮演了不可或缺的角色。它能夠集中管理所有 Contract，確保 Provider 與 Consumer 之間的 Contract 始終保持一致。</p>\n<p>最終，Contract Testing 與 CI&#x2F;CD 的結合，使得 API 變更的驗證變得自動化、可預測，進而提升整體開發的穩定性。透過 Pact Broker，團隊可以輕鬆管理不同版本的 Contract，並確保每一次的部署都是在雙方協議之下進行，真正落實契約驅動的 API 開發模式。</p>\n","excerpt":"","more":"<p>在微服務架構中，各個服務由不同團隊獨立開發、部署與維運，這樣的彈性雖然增加了開發效率，但也同時導致服務間互動的不確定性。如何確保每個服務在獨立更新的同時，仍能正確溝通與協作？ <strong>契約測試(Contract Testing)</strong> 正是解決這一問題的有效工具。</p>\n<h2 id=\"什麼是-Contract-Testing？\"><a href=\"#什麼是-Contract-Testing？\" class=\"headerlink\" title=\"什麼是 Contract Testing？\"></a>什麼是 Contract Testing？</h2><p>Contract Testing 是一種專注於驗證服務間 <strong>介面(Interface)</strong> 正確性的自動化測試方法。此方法論會將服務區分成兩個角色：</p>\n<ul>\n<li><strong>提供者(Provider)</strong> ：提供 API 的服務。</li>\n<li><strong>消費者(Consumer)</strong> ：使用 Provider 提供的 API 的服務。</li>\n</ul>\n<p>Provider 與 Consumer 之間會 <strong>提前</strong> 約定好 Interface，包含：請求格式、回應格式、錯誤處理機制等。這種約定可以是 OpenAPI、JSON Schema 或是其他 Contract Testing 工具來作為服務間共同遵循的標準，這套約定即 <strong>契約(Contract)</strong> 。而 Contract Testing 有兩種方法，分別是： <strong>消費者驅動的契約測試(Consumer-Driven Contract Testing)</strong> 與 <strong>提供者驅動的契約測試(Provider-Driven Contract Testing)</strong> 。</p>\n<blockquote>\n<p><strong>注意</strong>：Contract Testing 並 <strong>不會也不該</strong> 驗證 <strong>完整的</strong> Provider 商業邏輯，僅聚焦在 Interface 的驗證，商業邏輯的部分應屬於 <strong>單元測試(Unit Testing)</strong> 的範疇。</p>\n</blockquote>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"contract-testing-concept.png\"\n  alt=\"Contract testing concept\"\n/></p>\n<h3 id=\"Consumer-Driven-Contract-Testing\"><a href=\"#Consumer-Driven-Contract-Testing\" class=\"headerlink\" title=\"Consumer-Driven Contract Testing\"></a>Consumer-Driven Contract Testing</h3><p>這類型的 Contract Testing 是由 <strong>Consumer 定義契約內容來確保 Provider 提供的服務是否滿足它的期望</strong>。這樣的好處是 Provider 可以根據 Consumer 的實際需求來驗證與實作，達到快速反饋以及減少整合風險的效果，是一個適合內部團隊使用的 Contract Testing 方法。</p>\n<h3 id=\"Provider-Driven-Contract-Testing\"><a href=\"#Provider-Driven-Contract-Testing\" class=\"headerlink\" title=\"Provider-Driven Contract Testing\"></a>Provider-Driven Contract Testing</h3><p>這類型的 Contract Testing 是由 <strong>Provider 定義契約內容來統一管理 API 的文件與版本</strong>。這樣的好處是 Provider 可以讓所有 Consumer 依據統一的標準進行開發，是一個適合用於對外公開 API 的 Contract Testing 方法。</p>\n<h2 id=\"為什麼需要-Contract-Testing？\"><a href=\"#為什麼需要-Contract-Testing？\" class=\"headerlink\" title=\"為什麼需要 Contract Testing？\"></a>為什麼需要 Contract Testing？</h2><p>如文章開頭所述，微服務架構使得服務之間的互動增加了不確定性，如果沒有驗證互動正確性的方式，當服務的 Interface 頻繁發生變化時，有可能會因此導致其他服務無法正常運作，造成損失。如果導入 Contract Testing 則可以提早捕捉到不兼容的問題，避免整合時才發現有這個狀況發生。另外，在驗證服務間是否如預期運作最常見的方式即 <strong>端對端測試(E2E Testing)</strong> ，但測試過程可能會涉及許多複雜的商業邏輯與其他依賴的項目，針對僅需驗證 Consumer 與 Provider 之間 Interface 是否符合預期的情境，使用成本較高且流程繁複的 E2E Testing 顯得有些大材小用，使用對完整環境要求低、能夠驗證 Interface 是否符合預期的 Contract Testing 會是更好的選擇。</p>\n<h2 id=\"Pact\"><a href=\"#Pact\" class=\"headerlink\" title=\"Pact\"></a>Pact</h2><p>Pact 是一套 <strong>程式碼優先(code-first)</strong> 的 Consumer-Driven Contract Testing 工具，提供多種程式語言的實作，如：<a href=\"https://docs.pact.io/implementation_guides/javascript/readme\">JavaScript</a>、<a href=\"https://docs.pact.io/implementation_guides/jvm\">Java</a>、<a href=\"https://docs.pact.io/implementation_guides/go\">Golang</a> 等。</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-logo.png\"\n  alt=\"Pact logo\"\n/></p>\n<p><a href=\"https://docs.pact.io/implementation_guides/javascript/readme\">圖片來源</a></p>\n<h3 id=\"Pact-的運作流程\"><a href=\"#Pact-的運作流程\" class=\"headerlink\" title=\"Pact 的運作流程\"></a>Pact 的運作流程</h3><p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-flow-concept.png\"\n  alt=\"Pact flow concept\"\n/></p>\n<p><a href=\"https://docs.pact.io/\">圖片來源</a></p>\n<p>Pact 在運作流程上可以拆成兩個階段： <strong>Consumer 階段</strong> 與 <strong>Provider 階段</strong> ：</p>\n<h4 id=\"Consumer-階段\"><a href=\"#Consumer-階段\" class=\"headerlink\" title=\"Consumer 階段\"></a>Consumer 階段</h4><p>Consumer 在自己的測試中使用對應語言的 Pact 函式庫來定義預期的請求(HTTP Method、Path、Headers、Body 等)與回應格式(HTTP Code、Headers、Response Body 等)。測試執行期間，Pact 會啟動一個 Mock Server，Consumer 發送的請求會送到這個 Server，並會收到事前定義好的回應。測試完成後，Pact 會根據這些定義產生一個 JSON 格式的 Contract，用來記錄 Consumer 所期望的 Interface。</p>\n<h4 id=\"Provider-階段\"><a href=\"#Provider-階段\" class=\"headerlink\" title=\"Provider 階段\"></a>Provider 階段</h4><p>Provider 要使用 Consumer 定義的 Contract 來驗證服務提供的內容是否符合期望，所以必須在測試時啟動服務，並使用對應語言的 Pact 函式庫來執行 <strong>Pact 驗證工具(Pact Verifier)</strong> ，會讀取 Consumer 產生的 Contract 檔案並 <strong>重放(Replay)</strong> Contract 內定義的請求，進而驗證服務最終回傳的內容符合 Contract 內定義的格式。如果驗證結果發現回應的格式不如預期，此 Contract Testing 就會失敗，如此一來，便可以及早發現 Interface 不符期待的問題。</p>\n<h2 id=\"NestJS-與-Pact\"><a href=\"#NestJS-與-Pact\" class=\"headerlink\" title=\"NestJS 與 Pact\"></a>NestJS 與 Pact</h2><p>Pact 有提供 <a href=\"https://docs.pact.io/implementation_guides/javascript/readme\">PactJS</a> 套件供 JavaScript、TypeScript 開發者使用。NestJS 固然可以在既有的測試流程中使用此套件來實現 Contract Testing，甚至官方還為 NestJS 實作了 <a href=\"https://github.com/pact-foundation/nestjs-pact\">nestjs-pact</a> 套件，十分貼心！</p>\n<h3 id=\"前置作業\"><a href=\"#前置作業\" class=\"headerlink\" title=\"前置作業\"></a>前置作業</h3><p>假設已經有兩個基於 NestJS 實作的服務，一個是 Consumer、一個是 Provider，這些服務的專案需透過下方指令將 Pact 相關套件進行安裝：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install nestjs-pact @pact-foundation/pact -D</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Consumer-測試的前置作業\"><a href=\"#Consumer-測試的前置作業\" class=\"headerlink\" title=\"Consumer 測試的前置作業\"></a>Consumer 測試的前置作業</h4><p>假設 Consumer 這個專案有一個 <code>TodoModule</code>，該 Module 內有 <code>TodoController</code> 與 <code>TodoService</code> 並匯入了 <code>HttpModule</code> 來呼叫 API。下方是 <code>TodoController</code>、<code>TodoService</code> 與 <code>HttpService</code> 之間的關係，以類別圖來呈現：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n    classDiagram\n  class HttpService {\n    +get(url)\n    +post(url, payload)\n    +delete(url)\n  }\n\n  class TodoService {\n    -HttpService httpService\n    -TodoConfig config\n    -String todoApiUrl\n    +createTodo(payload)\n    +getTodoById(id)\n    +completeTodoById(id, completed)\n    +deleteTodoById(id)\n  }\n\n  class TodoController {\n    -TodoService todoService\n    +createTodo(payload)\n    +getTodo(id)\n    +completeTodo(id, payload)\n    +deleteTodo(id)\n  }\n\n  TodoService --&gt; HttpService\n  TodoController --&gt; TodoService\n  </pre></div>\n\n<p>前面有提到 Contract Testing 是驗證服務間 Interface 的測試方法，對 Consumer 而言，與 Provider 互動的元件為 <code>TodoService</code>，所以針對 <code>TodoService</code> 撰寫 Contract。那要如何開始呢？首先，會需要建立 Pact 的實例，這邊可以使用 <code>PactV3</code> 這個類，是目前的主要版本：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact test&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">provider</span>: <span class=\"title class_\">PactV3</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">beforeAll</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    provider = <span class=\"keyword\">new</span> <span class=\"title class_\">PactV3</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">consumer</span>: <span class=\"string\">&#x27;TodoConsumer&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">provider</span>: <span class=\"string\">&#x27;TodoProvider&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">port</span>: <span class=\"number\">1234</span>,</span><br><span class=\"line\">      <span class=\"attr\">dir</span>: path.<span class=\"title function_\">resolve</span>(process.<span class=\"title function_\">cwd</span>(), <span class=\"string\">&#x27;pacts&#x27;</span>, <span class=\"string\">&#x27;apps&#x27;</span>, <span class=\"string\">&#x27;consumer&#x27;</span>),</span><br><span class=\"line\">      <span class=\"attr\">logLevel</span>: <span class=\"string\">&#x27;info&#x27;</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上方是建立 <code>PactV3</code> 實例的方式，可以看到有幾個參數：</p>\n<ul>\n<li><code>consumer</code>：Consumer 的名稱。</li>\n<li><code>provider</code>：Provider 的名稱。</li>\n<li><code>port</code>：Pact 在執行測試時，會啟動一個 Mock Server，此參數即 Mock Server 的 port。</li>\n<li><code>dir</code>：執行測試後會產生 Contract 檔案，會將檔案存放在此資料夾下。</li>\n<li><code>logLevel</code>：執行測試時要顯示的 Log Level。</li>\n</ul>\n<p>建立完畢後，緊接著就可以進行 NestJS 測試的前置作業：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact test&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">provider</span>: <span class=\"title class_\">PactV3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">moduleRef</span>: <span class=\"title class_\">TestingModule</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">todoService</span>: <span class=\"title class_\">TodoService</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">config</span>: <span class=\"title class_\">TodoConfig</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">beforeEach</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    moduleRef = <span class=\"keyword\">await</span> <span class=\"title class_\">Test</span>.<span class=\"title function_\">createTestingModule</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">        <span class=\"title class_\">HttpModule</span>.<span class=\"title function_\">register</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">httpAgent</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">Agent</span>(&#123; <span class=\"attr\">keepAlive</span>: <span class=\"literal\">false</span> &#125;),</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"attr\">providers</span>: [</span><br><span class=\"line\">        <span class=\"title class_\">TodoService</span>,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">provide</span>: todoConfig.<span class=\"property\">KEY</span>,</span><br><span class=\"line\">          <span class=\"attr\">useValue</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">apiUrl</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">compile</span>();</span><br><span class=\"line\">    todoService = moduleRef.<span class=\"title function_\">get</span>(<span class=\"title class_\">TodoService</span>);</span><br><span class=\"line\">    config = moduleRef.<span class=\"title function_\">get</span>(todoConfig.<span class=\"property\">KEY</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>補充</strong> ：上方範例可以看到 <code>HttpModule</code> 使用了 <code>Agent</code> 並將 <code>keepAlive</code> 設為 <code>false</code>，這是因為如果沒有這樣設定，預設會是 <code>true</code>，會導致 Mock Server 出錯。</p>\n</blockquote>\n<p>一切準備就緒後，就可以來針對 <code>TodoService</code> 與 Provider 互動的方法進行測試了。</p>\n<h4 id=\"Provider-測試的前置作業\"><a href=\"#Provider-測試的前置作業\" class=\"headerlink\" title=\"Provider 測試的前置作業\"></a>Provider 測試的前置作業</h4><p>假設 Provider 這個專案有一個 <code>TodoModule</code>，該 Module 內有 <code>TodoController</code>、<code>TodoService</code> 與 <code>TodoRepository</code>，其中，<code>TodoRepository</code> 會負責與資料庫進行互動。下方是 <code>TodoController</code>、<code>TodoService</code> 與 <code>TodoRepository</code> 之間的關係，以類別圖來呈現：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n    classDiagram\n  class TodoRepository {\n    +createTodo(params)\n    +getTodoById(id)\n    +completeTodoById(id, completed)\n    +deleteTodoById(id)\n  }\n\n  class TodoService {\n    -TodoRepository todoRepository\n    +createTodo(payload)\n    +getTodoById(id)\n    +completeTodoById(id, completed)\n    +deleteTodoById(id)\n  }\n\n  class TodoController {\n    -TodoService todoService\n    +createTodo(payload)\n    +getTodoById(id)\n    +completeTodoById(id, payload)\n    +deleteTodoById(id)\n  }\n\n  TodoService --&gt; TodoRepository\n  TodoController --&gt; TodoService\n  </pre></div>\n\n<p>前面有提到 Provider 在執行 Contract Testing 時，會需要啟動服務來進行驗證，但啟動服務並不是希望驗證完整的商業邏輯，只是要確定 API 的結果是符合期望的，所以需要把一些依賴去除掉，以上方範例來說，我們可以將 <code>TodoRepository</code> 透過 <strong>樁(Stub)</strong> 的方式進行處理。這邊先撰寫一個 <code>TodoTestingRepository</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Injectable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span>, <span class=\"keyword\">of</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CreateTodo</span>, <span class=\"title class_\">Todo</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@pact-example/todo/domain&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TodoTestingRepository</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">todos</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">Todo</span>&gt; = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">createTodo</span>(<span class=\"attr\">params</span>: <span class=\"title class_\">CreateTodo</span>): <span class=\"title class_\">Observable</span>&lt;<span class=\"title class_\">Todo</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">Todo</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">id</span>: crypto.<span class=\"title function_\">randomUUID</span>(),</span><br><span class=\"line\">      <span class=\"attr\">title</span>: params.<span class=\"property\">title</span>,</span><br><span class=\"line\">      <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">push</span>(todo);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(todo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">appendTodo</span>(<span class=\"attr\">todo</span>: <span class=\"title class_\">Todo</span>): <span class=\"title class_\">Observable</span>&lt;<span class=\"title class_\">Todo</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> existTodo = <span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">find</span>(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x.<span class=\"property\">id</span> === todo.<span class=\"property\">id</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existTodo) &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>(existTodo, todo);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(existTodo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">push</span>(todo);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(todo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">getTodoById</span>(<span class=\"attr\">id</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">Observable</span>&lt;<span class=\"title class_\">Todo</span> | <span class=\"literal\">null</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">find</span>(<span class=\"function\">(<span class=\"params\">todo</span>) =&gt;</span> todo.<span class=\"property\">id</span> === id) ?? <span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">completeTodoById</span>(<span class=\"attr\">id</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span>): <span class=\"title class_\">Observable</span>&lt;<span class=\"title class_\">Todo</span> | <span class=\"literal\">null</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> todo = <span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">find</span>(<span class=\"function\">(<span class=\"params\">todo</span>) =&gt;</span> todo.<span class=\"property\">id</span> === id);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (todo) &#123;</span><br><span class=\"line\">      todo.<span class=\"property\">completed</span> = completed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(todo ?? <span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">deleteTodoById</span>(<span class=\"attr\">id</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">Observable</span>&lt;<span class=\"title class_\">Todo</span> | <span class=\"literal\">null</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">findIndex</span>(<span class=\"function\">(<span class=\"params\">todo</span>) =&gt;</span> todo.<span class=\"property\">id</span> === id);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">todos</span>.<span class=\"title function_\">splice</span>(index, <span class=\"number\">1</span>)[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這裡建立一個 <code>TodoTestingModule</code> 將 <code>TodoRepository</code> 當作 <code>TodoTestingRepository</code> 的 Token：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Module</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@nestjs/common&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">TodoController</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../../../app/todo/todo.controller&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">TodoService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../../../app/todo/todo.service&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">TodoRepository</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../../../app/todo/todo.repository&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">TodoTestingRepository</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./todo-testing.repository&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Module</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">controllers</span>: [<span class=\"title class_\">TodoController</span>],</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">TodoService</span>,</span><br><span class=\"line\">    <span class=\"title class_\">TodoTestingRepository</span>,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">provide</span>: <span class=\"title class_\">TodoRepository</span>,</span><br><span class=\"line\">      <span class=\"attr\">useExisting</span>: <span class=\"title class_\">TodoTestingRepository</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">exports</span>: [<span class=\"title class_\">TodoRepository</span>],</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TodoTestingModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這些都完成後，就可以來建置 Provider 的測試了。將 NestJS 測試的前置作業建立起來：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact validation&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">app</span>: <span class=\"title class_\">INestApplication</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> consoleLogger = <span class=\"keyword\">new</span> <span class=\"title class_\">ConsoleLogger</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">beforeAll</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleRef = <span class=\"keyword\">await</span> <span class=\"title class_\">Test</span>.<span class=\"title function_\">createTestingModule</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">imports</span>: [<span class=\"title class_\">TodoTestingModule</span>],</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">compile</span>();</span><br><span class=\"line\">    app = moduleRef.<span class=\"title function_\">createNestApplication</span>();</span><br><span class=\"line\">    app.<span class=\"title function_\">setGlobalPrefix</span>(<span class=\"string\">&#x27;api&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> app.<span class=\"title function_\">init</span>();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">afterAll</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> app.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>接著，使用 <code>nestjs-pact</code> 提供的 <code>PactProviderModule</code> 來建立 Pact Verifier，在建立的時候，假如是採用讀取 Contract 檔案的方式，就需要帶入 <code>pactUrls</code> 這個參數。當一切就緒後，透過 <code>PactVerifierService</code> 的 <code>verify</code> 方法即可執行驗證：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"comment\">// 避免 Contract Testing 超時</span></span><br><span class=\"line\">jest.<span class=\"built_in\">setTimeout</span>(<span class=\"number\">60</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact validation&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">verifier</span>: <span class=\"title class_\">PactVerifierService</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">beforeAll</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleRef = <span class=\"keyword\">await</span> <span class=\"title class_\">Test</span>.<span class=\"title function_\">createTestingModule</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"title class_\">PactProviderModule</span>.<span class=\"title function_\">registerAsync</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">useFactory</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">              <span class=\"attr\">pactUrls</span>: [</span><br><span class=\"line\">                path.<span class=\"title function_\">resolve</span>(process.<span class=\"title function_\">cwd</span>(), <span class=\"string\">&#x27;pacts&#x27;</span>, <span class=\"string\">&#x27;apps&#x27;</span>, <span class=\"string\">&#x27;consumer&#x27;</span>, <span class=\"string\">&#x27;TodoConsumer-TodoProvider.json&#x27;</span>),</span><br><span class=\"line\">              ],</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">compile</span>();</span><br><span class=\"line\">    verifier = moduleRef.<span class=\"title function_\">get</span>(<span class=\"title class_\">PactVerifierService</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 執行驗證</span></span><br><span class=\"line\">  <span class=\"title function_\">it</span>(<span class=\"string\">&#x27;should validate the pact contract&#x27;</span>, <span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> verifier.<span class=\"title function_\">verify</span>(app);</span><br><span class=\"line\">    consoleLogger.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Pact Verification Completed!&#x27;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"撰寫建立-Todo-的測試\"><a href=\"#撰寫建立-Todo-的測試\" class=\"headerlink\" title=\"撰寫建立 Todo 的測試\"></a>撰寫建立 Todo 的測試</h3><p>先假設 Provider 提供的 <code>[POST] /api/todos</code> API 的請求 Payload 如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">CreateTodo</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>回應的 HTTP Code 為 <code>201</code> 且 Body 格式如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">CreatedTodo</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">todo</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h4><p>透過 <code>PactV3</code> 的 <code>withRequest</code> 定義發送請求的格式，以 <code>[POST] /api/todos</code> 來說，<code>method</code> 會定為 <code>POST</code>、<code>path</code> 會定為 <code>/api/todos</code>、<code>body</code> 會定為 <code>CreateTodo</code> 的格式。而預期的回應則透過 <code>withResponseWith</code> 來設置，<code>status</code> 會是 <code>201</code>、<code>headers</code> 會含有 <code>Content-Type</code> 為 <code>application/json</code> 的值，比較特別的是，<code>body</code> 使用了 Pact 提供的 <code>MatchersV3</code> 來輔助驗證格式與資料，達到更精準的驗證，同時也可以減少 hardcode 測試資料的情況。下方為範例程式碼：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact test&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;When call the createTodo method of TodoService.&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">responseExample</span>: <span class=\"title class_\">CreatedTodo</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">todo</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">id</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">&#x27;todo 1&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">beforeAll</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      provider</span><br><span class=\"line\">        .<span class=\"title function_\">uponReceiving</span>(<span class=\"string\">&#x27;a request to create a todo&#x27;</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">withRequest</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">method</span>: <span class=\"string\">&#x27;POST&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/api/todos&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">body</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">title</span>: responseExample.<span class=\"property\">todo</span>.<span class=\"property\">title</span>,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .<span class=\"title function_\">willRespondWith</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">status</span>: <span class=\"title class_\">HttpStatus</span>.<span class=\"property\">CREATED</span>,</span><br><span class=\"line\">          <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"attr\">body</span>: &#123;</span><br><span class=\"line\">            <span class=\"comment\">// `like` 的用法是要求值要跟提供的模板是相同的類型</span></span><br><span class=\"line\">            <span class=\"attr\">todo</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">like</span>(&#123;</span><br><span class=\"line\">              <span class=\"comment\">// `uuid` 的用法是資料必須符合 UUID 的格式</span></span><br><span class=\"line\">              <span class=\"attr\">id</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">uuid</span>(), </span><br><span class=\"line\">              <span class=\"comment\">// `string` 的用法是資料必須是指定的字串</span></span><br><span class=\"line\">              <span class=\"attr\">title</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">string</span>(responseExample.<span class=\"property\">todo</span>.<span class=\"property\">title</span>),</span><br><span class=\"line\">              <span class=\"comment\">// `boolean` 的用法是資料必須是指定的布林值</span></span><br><span class=\"line\">              <span class=\"attr\">completed</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">boolean</span>(responseExample.<span class=\"property\">todo</span>.<span class=\"property\">completed</span>),</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>定義好預期的請求與回應之後，可以透過 <code>executeTest</code> 來執行測試，會使用 Pact 啟動的 Mock Server 供 Consumer 進行行為的驗證。以範例來說，會針對與 Provider 互動的 <code>TodoService#createTodo</code> 方法進行行為驗證：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact test&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;When call the createTodo method of TodoService.&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">it</span>(<span class=\"string\">&#x27;should return a created todo.&#x27;</span>, <span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> provider.<span class=\"title function_\">executeTest</span>(<span class=\"title function_\">async</span> (mockServer) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 指定存取的 url 為 Mock Server 提供的 url</span></span><br><span class=\"line\">        config.<span class=\"property\">apiUrl</span> = mockServer.<span class=\"property\">url</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"attr\">payload</span>: <span class=\"title class_\">CreateTodo</span> = &#123; <span class=\"attr\">title</span>: responseExample.<span class=\"property\">todo</span>.<span class=\"property\">title</span> &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"attr\">expectedResponse</span>: <span class=\"title class_\">CreatedTodo</span> = &#123;</span><br><span class=\"line\">          <span class=\"attr\">todo</span>: &#123;</span><br><span class=\"line\">            ...responseExample.<span class=\"property\">todo</span>,</span><br><span class=\"line\">            <span class=\"attr\">id</span>: expect.<span class=\"title function_\">any</span>(<span class=\"title class_\">String</span>),</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">lastValueFrom</span>(todoService.<span class=\"title function_\">createTodo</span>(payload));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 檢查 `TodoService` 的 `createTodo` 方法回傳值是否符合預期</span></span><br><span class=\"line\">        <span class=\"title function_\">expect</span>(response).<span class=\"title function_\">toEqual</span>(expectedResponse);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"撰寫取得-Todo-的測試\"><a href=\"#撰寫取得-Todo-的測試\" class=\"headerlink\" title=\"撰寫取得 Todo 的測試\"></a>撰寫取得 Todo 的測試</h3><p>先假設 Provider 提供 <code>[GET] /api/todos</code> API 回應的 HTTP Code 為 <code>200</code> 且 Body 格式如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FoundTodo</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">todo</span>: <span class=\"title class_\">Todo</span> | <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Consumer-1\"><a href=\"#Consumer-1\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h4><p>與撰寫建立 Todo 測試時的寫法大同小異，不過以取得 Todo 的情境來說，會分成「有找到 Todo」跟「沒找到 Todo」兩個情境。另外，為了要驗證取得的 Todo 符合 Consumer 所定義的格式，在雙方不 hardcode 的情況下，可以運用 <code>given</code> 讓 Consumer 傳遞 <strong>狀態(State)</strong> 給 Provider，Provider 會根據 State 做出對應的策略，以這個範例來說，Consumer 會將預期收到的 Todo 格式傳遞給 Provider，Provider 會在執行驗證之前，將該筆資料準備好，避免因 State 問題導致測試出錯：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact test&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;When call the getTodoById method of TodoService.&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"attr\">responseExample</span>: <span class=\"title class_\">FoundTodo</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;When the todo exists.&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">beforeAll</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        responseExample = &#123;</span><br><span class=\"line\">          <span class=\"attr\">todo</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">id</span>: crypto.<span class=\"title function_\">randomUUID</span>(),</span><br><span class=\"line\">            <span class=\"attr\">title</span>: <span class=\"string\">&#x27;todo 1&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">beforeAll</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        provider</span><br><span class=\"line\">          <span class=\"comment\">// 透過 `given` 傳遞 State，確保執行驗證之前一定有這筆資料</span></span><br><span class=\"line\">          .<span class=\"title function_\">given</span>(<span class=\"string\">&#x27;The todo exists&#x27;</span>, &#123; <span class=\"attr\">todo</span>: responseExample.<span class=\"property\">todo</span> &#125;)</span><br><span class=\"line\">          .<span class=\"title function_\">uponReceiving</span>(<span class=\"string\">&#x27;a request to get a todo&#x27;</span>)</span><br><span class=\"line\">          .<span class=\"title function_\">withRequest</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">method</span>: <span class=\"string\">&#x27;GET&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">path</span>: <span class=\"string\">`/api/todos/<span class=\"subst\">$&#123;responseExample.todo.id&#125;</span>`</span>,</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .<span class=\"title function_\">willRespondWith</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"title class_\">HttpStatus</span>.<span class=\"property\">OK</span>,</span><br><span class=\"line\">            <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">              <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">body</span>: &#123;</span><br><span class=\"line\">              <span class=\"attr\">todo</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">like</span>(&#123;</span><br><span class=\"line\">                <span class=\"attr\">id</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">string</span>(responseExample.<span class=\"property\">todo</span>.<span class=\"property\">id</span>),</span><br><span class=\"line\">                <span class=\"attr\">title</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">string</span>(responseExample.<span class=\"property\">todo</span>.<span class=\"property\">title</span>),</span><br><span class=\"line\">                <span class=\"attr\">completed</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">boolean</span>(responseExample.<span class=\"property\">todo</span>.<span class=\"property\">completed</span>),</span><br><span class=\"line\">              &#125;),</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">it</span>(<span class=\"string\">&#x27;should return the todo.&#x27;</span>, <span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> provider.<span class=\"title function_\">executeTest</span>(<span class=\"title function_\">async</span> (mockServer) =&gt; &#123;</span><br><span class=\"line\">          config.<span class=\"property\">apiUrl</span> = mockServer.<span class=\"property\">url</span>;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> <span class=\"attr\">expectedResponse</span>: <span class=\"title class_\">FoundTodo</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">todo</span>: &#123;</span><br><span class=\"line\">              ...responseExample.<span class=\"property\">todo</span>,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">lastValueFrom</span>(</span><br><span class=\"line\">            todoService.<span class=\"title function_\">getTodoById</span>(responseExample.<span class=\"property\">todo</span>.<span class=\"property\">id</span>)</span><br><span class=\"line\">          );</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"title function_\">expect</span>(response).<span class=\"title function_\">toEqual</span>(expectedResponse);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;When the todo does not exist.&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"variable constant_\">TODO_ID</span> = <span class=\"string\">&#x27;2&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">beforeAll</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        responseExample = &#123;</span><br><span class=\"line\">          <span class=\"attr\">todo</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">beforeAll</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        provider</span><br><span class=\"line\">          .<span class=\"title function_\">uponReceiving</span>(<span class=\"string\">&#x27;a request to get a null todo&#x27;</span>)</span><br><span class=\"line\">          .<span class=\"title function_\">withRequest</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">method</span>: <span class=\"string\">&#x27;GET&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">path</span>: <span class=\"string\">`/api/todos/<span class=\"subst\">$&#123;TODO_ID&#125;</span>`</span>,</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .<span class=\"title function_\">willRespondWith</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"title class_\">HttpStatus</span>.<span class=\"property\">OK</span>,</span><br><span class=\"line\">            <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">              <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">body</span>: &#123;</span><br><span class=\"line\">              <span class=\"attr\">todo</span>: <span class=\"title class_\">MatchersV3</span>.<span class=\"title function_\">nullValue</span>(),</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">it</span>(<span class=\"string\">&#x27;should return null.&#x27;</span>, <span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> provider.<span class=\"title function_\">executeTest</span>(<span class=\"title function_\">async</span> (mockServer) =&gt; &#123;</span><br><span class=\"line\">          config.<span class=\"property\">apiUrl</span> = mockServer.<span class=\"property\">url</span>;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> <span class=\"attr\">expectedResponse</span>: <span class=\"title class_\">FoundTodo</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">todo</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">lastValueFrom</span>(</span><br><span class=\"line\">            todoService.<span class=\"title function_\">getTodoById</span>(<span class=\"variable constant_\">TODO_ID</span>)</span><br><span class=\"line\">          );</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"title function_\">expect</span>(response).<span class=\"title function_\">toEqual</span>(expectedResponse);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Provider\"><a href=\"#Provider\" class=\"headerlink\" title=\"Provider\"></a>Provider</h4><p>針對傳遞狀態的部分需要額外做處理，Pact 有提供 <code>stateHandlers</code> 讓我們可以根據不同情況執行不同策略進而處理 State。以前面 Consumer 傳遞的 <code>The todo exists</code> 來說，Provider 需要將傳遞進來的資料寫入 <code>TodoTestingRepository</code> 內，這樣在執行 API 存取時，就一定會有該筆資料存在。下方是範例程式碼：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&#x27;Todo API Pact validation&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">beforeAll</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleRef = <span class=\"keyword\">await</span> <span class=\"title class_\">Test</span>.<span class=\"title function_\">createTestingModule</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"title class_\">PactProviderModule</span>.<span class=\"title function_\">registerAsync</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">imports</span>: [<span class=\"title class_\">TodoTestingModule</span>],</span><br><span class=\"line\">          <span class=\"attr\">inject</span>: [<span class=\"title class_\">TodoRepository</span>],</span><br><span class=\"line\">          <span class=\"attr\">useFactory</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">todoRepository</span>: <span class=\"title class_\">TodoTestingRepository</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">              <span class=\"attr\">stateHandlers</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;The todo exists&#x27;</span>: <span class=\"title function_\">async</span> (params) =&gt; &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">const</span> &#123; todo &#125; = params <span class=\"keyword\">as</span> <span class=\"built_in\">unknown</span> <span class=\"keyword\">as</span> &#123; <span class=\"attr\">todo</span>: <span class=\"title class_\">Todo</span> &#125;;</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> <span class=\"title function_\">lastValueFrom</span>(todoRepository.<span class=\"title function_\">appendTodo</span>(todo));</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              <span class=\"attr\">pactUrls</span>: [</span><br><span class=\"line\">                path.<span class=\"title function_\">resolve</span>(process.<span class=\"title function_\">cwd</span>(), <span class=\"string\">&#x27;pacts&#x27;</span>, <span class=\"string\">&#x27;apps&#x27;</span>, <span class=\"string\">&#x27;consumer&#x27;</span>, <span class=\"string\">&#x27;TodoConsumer-TodoProvider.json&#x27;</span>),</span><br><span class=\"line\">              ],</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">compile</span>();</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong>：上方程式碼中，將 <code>params</code> 強制轉型的原因是 Pact 在型別定義是寫 <code>string</code>，但事實上該參數的型別為 Consumer 傳遞的 State。</p>\n</blockquote>\n<h3 id=\"執行驗證\"><a href=\"#執行驗證\" class=\"headerlink\" title=\"執行驗證\"></a>執行驗證</h3><blockquote>\n<p><strong>補充</strong>：關於「完成 Todo 的測試」與「刪除 Todo 的測試」就不額外佔篇幅來寫了，處理方式大同小異。</p>\n</blockquote>\n<p>當 Consumer 執行測試時，成功的畫面如下圖：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"consumer-test-result.png\"\n  alt=\"Consumer Test Result\"\n/></p>\n<p>並且會如預期產生一個 Contract 檔案：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"generated-contract.png\"\n  alt=\"Generated Contract\"\n/></p>\n<p>此時執行 Provider 的測試時，成功的畫面如下圖：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"provider-test-result.png\"\n  alt=\"Provider Test Result\"\n/></p>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>當我們在微服務架構中導入 Contract Testing 時，能在開發過程中即時發現潛在的 API 變更問題。本篇文章是以手動執行 Contract Testing 的角度來撰寫，但實務上，手動執行 Contract Testing 並不足以應對持續變動的系統環境，因此將 Contract Testing 納入 CI&#x2F;CD 流程成為關鍵的一環。</p>\n<p>透過 CI&#x2F;CD，我們可以在每次變更時自動執行 Contract Testing，確保 API 的更新不會破壞現有的依賴關係。這不僅能減少因 API 變更導致的溝通成本，也能讓團隊更有信心地進行版本演進。此外，Pact 還有提供 <a href=\"https://docs.pact.io/getting_started/sharing_pacts\">Pact Broker</a> 這個工具，在 CI&#x2F;CD 驅動驗證的流程中扮演了不可或缺的角色。它能夠集中管理所有 Contract，確保 Provider 與 Consumer 之間的 Contract 始終保持一致。</p>\n<p>最終，Contract Testing 與 CI&#x2F;CD 的結合，使得 API 變更的驗證變得自動化、可預測，進而提升整體開發的穩定性。透過 Pact Broker，團隊可以輕鬆管理不同版本的 Contract，並確保每一次的部署都是在雙方協議之下進行，真正落實契約驅動的 API 開發模式。</p>\n"},{"title":"NestJS 結合 Pact Broker 完善契約測試","date":"2025-04-15T09:20:00.000Z","_content":"\n## 什麼是 Pact Broker？\n\n契約測試可以用更快、更低的成本來測試服務之間的介面是否有破壞性變更，強化服務之間介面的穩固性。但此測試方式面臨了一些挑戰：\n\n* **契約管理**：在微服務架構中，每個服務之間的契約可能數量很多且版本頻繁變動。需要一個集中的平台來儲存、追蹤這些契約檔案，並協助團隊理解每個契約的來源與歷史。\n* **驗證結果管理**：當 Provider 驗證 Consumer 所提交的契約時，我們需要一個地方來儲存這些驗證結果，讓團隊成員可以清楚知道目前哪個版本的服務與哪個契約已經完成驗證、是否相容。\n\n為了解決上述問題，Pact 團隊打造了 [Pact Broker](https://docs.pact.io/pact_broker) 這個工具。它是一個專門設計來儲存和管理 Pact 契約與驗證結果的服務。透過 Pact Broker，我們可以更有效地管理微服務之間的契約、驗證狀態、版本關係，將其融入 CI/CD 即可打造自動化、高效的契約測試流程。\n\n> **補充**：有關於 Pact 相關的介紹可以參考[官方文件](https://docs.pact.io/)或是我之前寫的[文章](https://hao0731.github.io/2025/03/08/0005-nestjs-pact/)。\n\n### 參與者 (Pacticipants)\n\n**參與者 (Pacticipants)** 一詞是 Pact 與英文中的參與者 - Participants 合併後產生的單字。在 Pact Broker 中，最基本的單位就是參與契約測試的「服務」，也就是 Consumer 與 Provider，這些服務稱之為 Pacticipants。\n\n> **補充**：根據官方的說法，Pact Broker 的作者很後悔使用 Pacticipants 這個詞 XD\n\n### 版本 (Versioning)\n\n在 Pact Broker 的架構下，共有三種資源擁有版本，分別是：**Consumer 應用程式的版本** 、 **Provider 應用程式的版本** 與 **契約檔案的版本** 。\n\n#### 契約版本\n\n每一個被發佈到 Pact Broker 的契約都會有一個版本號，這塊是由 Pact Broker 自動處理的，開發人員並不需要針對契約設定版本。\n\n{% mermaid %}\ngraph TD\n  C0[\"Consumer\"]\n\n  subgraph Pact broker\n    P0[\"Contract (version:abc)\"]\n  end\n\n  C0 --> P0\n{% endmermaid %}\n\n#### Consumer 應用程式的版本\n\n每當一份契約被發佈到 Pact Broker 時，它會跟 **Consumer 的名稱** 、 **Consumer 應用程式的版本** 與 **Provider 的名稱** 產生關聯。其中，Consumer 的名稱與 Provider 的名稱會在撰寫契約測試時指定，版本的部分則是 Consumer 在發佈契約時指定的版本號，這個版本號必須是唯一的。這裡值得一提的是 Pact Broker 會針對 Consumer 發佈的契約進行雜湊比對，如果發佈的契約並沒有任何異動，則會將 Consumer 應用程式的版本與已經存在的契約建立關聯。\n\n{% mermaid %}\ngraph TD\n  subgraph Consumer\n    C0[\"Consumer v0.0.0\"]\n    C1[\"Consumer v0.0.1\"]\n    C2[\"Consumer v0.0.2\"]\n  end\n\n  subgraph Contracts\n    P1[\"Contract A (hash: abc123)\"]\n    P2[\"Contract B (hash: def456)\"]\n  end\n\n  C0 --> P1\n  C1 --> P1\n  C2 --> P2\n{% endmermaid %}\n\n讓多個 Consumer 應用程式版本指向同一個版本的契約不僅可以減少重複的內容，還可以避免重複驗證的情形，舉例來說，Consumer 版本為 `v0.0.0` 與 `v0.0.1` 時，並沒有改變契約的內容，那麼假設 Provider 已經針對 `v0.0.0` 發佈的契約進行驗證且通過，`v0.0.1` 也會視為驗證通過。\n\n> **注意**：為了讓檢查重複契約的機制可以順利運作，在撰寫測試的時候，應該要 **避免隨機產生資料的行為** ，因為如果有隨機產生的資料，進行雜湊的時候一定會不同，就會導致明明沒有改變契約內容卻因隨機資料而判定為契約有異動的情況。\n\n#### Provider 應用程式的版本\n\nProvider 與 Consumer 一樣需要定義應用程式版本，該版本會跟 Consumer 發佈的契約產生關聯，每當 Provider 發佈新版本時，需要針對關聯的契約進行驗證，確保 Provider 的異動可以通過契約測試。\n\n{% mermaid %}\ngraph TD\n  subgraph Consumer\n    C0[\"Consumer v0.0.0\"]\n  end\n\n  subgraph Contracts\n    CT1[\"Contract A (hash: abc123)\"]\n  end\n\n  subgraph Provider\n    P0[\"Provider v0.0.0\"]\n    P1[\"Provider v0.0.1\"]\n  end\n\n  C0 --> CT1\n  CT1 -- ❌ --- P0\n  CT1 -- ✅ --- P1\n{% endmermaid %}\n\n從上方概念圖可以看出，Consumer 版本 `v0.0.0` 產生的契約在 Provider 版本 `v0.0.0` 時驗證失敗，後來 Provider 釋出 `v0.0.1` 重新進行驗證就通過了，這裡可以看出是 Provider 在 `v0.0.0` 時有問題，所以釋出 `v0.0.1` 進行修正。\n\n#### Consumer 與 Provider 版本策略\n\n為了發揮契約測試的最大效用，會建議不論是開發功能的 `feature/*` 分支、準備部署到 Staging 環境的 `release/*` 分支又或是正式版的 `main` 分支都執行契約測試，這樣的好處是可以確保在各個階段都能驗證介面是否符合契約內容，及早發現問題。但也代表 Consumer 與 Provider 在版本策略上需要做出改變。\n\n在過去，版本的定義時間點可能會發生在部署到某個環境之前，這就表示開發功能的 `feature/*` 分支 **並不會有一個定義好的版本** ，那針對需要給定 Consumer 應用程式版本的 Pact Broker 來說就不符合規則，所以要改變的策略就是 **預定義版本**。根據 Pact 官方建議，可以在版本上添加 Git SHA 這類唯一且可識別版本的資訊，確保版本號一定不會有重複且能夠做到預定義版本。下圖是使用 Git Graph 繪製出的預定義版本情境，可以看到除了 `dev` 分支本身的 commit 有對應的版本外，`feature/a` 這個分支上也有定義版本：\n\n{% mermaid %}\n%%{init: { 'gitGraph': { 'mainBranchName': 'dev' } }}%%\ngitGraph\n  commit id: \"4fc667fb\" tag:\"v0.0.1-4fc667fb\"\n  commit id: \"2eed1c17\" tag:\"v0.0.1-2eed1c17\"\n\n  branch feature/a\n  checkout feature/a\n  commit\n  commit id: \"563c6421\" tag:\"v0.0.1-563c6421\"\n  commit\n  commit\n  commit\n  commit id: \"c517b5d3\" tag:\"v0.0.1-c517b5d3\"\n\n{% endmermaid %}\n\n### 矩陣 (Matrix)\n\nMatrix 是 Pact Broker 的核心功能，它是一張 Consumer 發佈契約與 Provider 驗證結果的記錄表，從這張表可以看出哪些 Consumer 版本發佈的契約在哪個 Provider 版本下是通過驗證的，進而得知 Consumer 版本與 Provider 版本之間的相容性。\n\n下方是一張範例表，從該表可以看出，Banana 這個 Provider 在釋出 `1.1.0` 的時候去驗證 Apple `1.0.0` 發佈的契約，驗證結果為不通過，就表示 Banana `1.1.0` 這個版本 **不相容** 於 Apple `1.0.0`，所以後來 Banana 釋出了 `1.1.1` 進行修復，從驗證結果來看是有正確修復的，就表示 Banana `1.1.1` 相容於 Apple `1.0.0`，而最後一筆可以看出，Apple 釋出了 `1.1.0` 也相容於 Banana `1.1.1` 版本：\n\n|Consumer|Consumer Version|Provider|Provider Version|Verification Result|\n|--------|----------------|--------|----------------|-------------------|\n|Apple   |1.0.0           |Banana  |1.0.0           |✅                 |\n|Apple   |1.0.0           |Banana  |1.1.0           |❌                 |\n|Apple   |1.0.0           |Banana  |1.1.1           |✅                 |\n|Apple   |1.1.0           |Banana  |1.1.1           |✅                 |\n\n> **補充**：Pact Broker 有提供十分強大的 Matrix UI 讓 Pacticipant 的開發者可以清楚知道上述的關係，後續會再做進一步的說明。\n\n## 架設 Pact Broker\n\nPact Broker 預設使用 [Postgres](https://www.postgresql.org/) 做為儲存資料的媒介。我們可以透過 Docker Compose 同時啟動 Postgres 與 Pact Broker。下方是 Docker Compose 的 YAML 範例：\n\n```yaml\nversion: '3'\nservices:\n  postgres:\n    image: postgres:12\n    environment:\n      POSTGRES_PASSWORD: mysecretpassword\n      POSTGRES_USER: postgres\n      POSTGRES_DB: pact_broker\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n\n  pact-broker:\n    image: pactfoundation/pact-broker\n    ports:\n      - \"9292:9292\"\n    environment:\n      PACT_BROKER_DATABASE_USERNAME: postgres\n      PACT_BROKER_DATABASE_PASSWORD: mysecretpassword\n      PACT_BROKER_DATABASE_HOST: postgres\n      PACT_BROKER_DATABASE_NAME: pact_broker\n    depends_on:\n      - postgres\n```\n\n在 `postgres` 設置了三個環境變數：\n\n* `POSTGRES_PASSWORD`：用來設置 系統管理員(Superuser) 的密碼。\n* `POSTGRES_USER`：用來設置 Superuser 的名稱。\n* `POSTGRES_DB`：用來設置預設資料庫的名稱。\n\n而在 `pact-broker` 的部分設置了四個環境變數：\n\n* `PACT_BROKER_DATABASE_USERNAME`：Pact Broker 存取資料庫的使用者名稱。\n* `PACT_BROKER_DATABASE_PASSWORD`：Pact Broker 存取資料庫的使用者密碼。\n* `PACT_BROKER_DATABASE_HOST`：Pact Broker 存取的資料庫 Host 位址。\n* `PACT_BROKER_DATABASE_NAME`：Pact Broker 要存取的資料庫名稱。\n\n透過下方指令執行 Docker Compose 並架設 Pact Broker 與 Postgres：\n\n```bash\n$ docker compose up -d\n```\n\n## 初探 Pact Broker UI\n\n架設完 Pact Broker 後，打開瀏覽器存取 [http://localhost:9292/](http://localhost:9292/) 會看到下方畫面：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui.png\"\n  alt=\"Pact Broker UI\"\n/>\n\n畫面中呈現了 Consumer 為「Example App」與 Provider 為「Example API」的組合，並呈現最後一次的驗證結果，可以看到上面寫「1 day ago」且背景色為綠色，表示最後一次驗證是發生在一天前且驗證通過。\n\n畫面上可以看到有一個表格的圖案：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix-entry.png\"\n  alt=\"Pact Broker UI Matrix Entry\"\n/>\n\n點擊後會顯示這個 Consumer、Provider 組合的 Matrix，預設情況下會顯示剛剛首頁呈現的最新一筆的驗證結果：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix.png\"\n  alt=\"Pact Broker UI Matrix\"\n/>\n\n透過畫面上方的查詢表單可以查到這個 Consumer、Provider 組合的所有版本、驗證結果的 Matrix：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix-all-result1.png\"\n  alt=\"Pact Broker UI Matrix All Result 1\"\n/>\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix-all-result2.png\"\n  alt=\"Pact Broker UI Matrix All Result 2\"\n/>\n\n從畫面中可以看到 Consumer 在版本為 `6c992f8` 的時候，Provider 並沒有執行驗證，而是到了 Consumer 發佈 `e15da45` 的兩天後，Provider 才使用 `480e5ae` 這個版本執行驗證，不過很可惜這邊出了問題所以驗證失敗，所以後續 Provider 使用 `1315e0b` 進行驗證並且結果是通過的。\n\n## Pact CLI\n\nPact 官方有推出 CLI 讓開發者可以透過其部署、檢索契約等操作。除了[獨立安裝檔](https://github.com/pact-foundation/pact-ruby-standalone/releases)外，還有推出 Docker Image 讓開發者可以更輕易地使用。透過下方指令從 DockerHub 進行下載：\n\n```bash\n$ docker pull pactfoundation/pact-cli:latest\n```\n\n下載完畢後，可以透過下方指令呼叫幫助清單：\n\n```bash\n$ docker run --rm pactfoundation/pact-cli help\n```\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-cli-help.png\"\n  alt=\"Pact CLI help\"\n/>\n\n### 部署契約\n\n延續「[在 NestJS 使用 Pact 實現契約測試](https://hao0731.github.io/2025/03/08/0005-nestjs-pact/)」文章中的測試，將這份契約透過 Pact CLI 發佈到 Pact Broker 上。\n\n> **注意**：請先將契約檔案產生出來。\n\nPact CLI 發佈契約會使用 `publish` 指令，格式如下：\n\n```bash\n$ docker run -it --rm -w ${PWD} -v ${PWD}:${PWD} --network=<PACT_BROKER_DOCKER_NETWORK> pactfoundation/pact-cli publish <CONTRACT_FILE_PATH> --consumer-app-version <GIT_SHA> --branch <GIT_BRANCH> --broker-base-url <PACT_BROKER_URL>\n```\n\n> **注意**：因為是使用 Docker 的方式來操作 Pact CLI，所以需要指定 Workspace 與 Volume，確保可以正確讀到契約檔案。\n\n從上方 `publish` 指令可以看到有許多參數，這裡一一解釋：\n\n* `<CONTRACT_FILE_PATH>`：契約檔案的位置。\n* `--consumer-app-version`：Consumer 發佈契約當下的應用程式版本，上方範例使用 `<GIT_SHA>` 作為佔位符，實際情況可以帶入該 Commit 的 Git SHA 值。\n* `--branch`：Consumer 發佈契約當下的分支。\n* `--broker-base-url`：Pact Broker 的 URL。\n\n下方是實際執行的畫面，可以看到執行完以後會顯示成功的訊息：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-cli-publish.png\"\n  alt=\"Pact CLI Publish\"\n/>\n\n進入 Pact Broker UI 看一下發佈的契約，可以看到有顯示出來且還沒有任何驗證結果：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-cli-publish-result.png\"\n  alt=\"Pact CLI Publish Result\"\n/>\n\n## 整合契約驗證\n\n","source":"_posts/0006-nestjs-pact-broker.md","raw":"---\ntitle: NestJS 結合 Pact Broker 完善契約測試\ndate: 2025-04-15 17:20:00\ntags:\n  - Backend\n  - NestJS\n  - Contract Testing\n  - Pact\n  - Pact Broker\ncategories:\n  - ['Backend', 'NestJS', 'Contract Testing']\n---\n\n## 什麼是 Pact Broker？\n\n契約測試可以用更快、更低的成本來測試服務之間的介面是否有破壞性變更，強化服務之間介面的穩固性。但此測試方式面臨了一些挑戰：\n\n* **契約管理**：在微服務架構中，每個服務之間的契約可能數量很多且版本頻繁變動。需要一個集中的平台來儲存、追蹤這些契約檔案，並協助團隊理解每個契約的來源與歷史。\n* **驗證結果管理**：當 Provider 驗證 Consumer 所提交的契約時，我們需要一個地方來儲存這些驗證結果，讓團隊成員可以清楚知道目前哪個版本的服務與哪個契約已經完成驗證、是否相容。\n\n為了解決上述問題，Pact 團隊打造了 [Pact Broker](https://docs.pact.io/pact_broker) 這個工具。它是一個專門設計來儲存和管理 Pact 契約與驗證結果的服務。透過 Pact Broker，我們可以更有效地管理微服務之間的契約、驗證狀態、版本關係，將其融入 CI/CD 即可打造自動化、高效的契約測試流程。\n\n> **補充**：有關於 Pact 相關的介紹可以參考[官方文件](https://docs.pact.io/)或是我之前寫的[文章](https://hao0731.github.io/2025/03/08/0005-nestjs-pact/)。\n\n### 參與者 (Pacticipants)\n\n**參與者 (Pacticipants)** 一詞是 Pact 與英文中的參與者 - Participants 合併後產生的單字。在 Pact Broker 中，最基本的單位就是參與契約測試的「服務」，也就是 Consumer 與 Provider，這些服務稱之為 Pacticipants。\n\n> **補充**：根據官方的說法，Pact Broker 的作者很後悔使用 Pacticipants 這個詞 XD\n\n### 版本 (Versioning)\n\n在 Pact Broker 的架構下，共有三種資源擁有版本，分別是：**Consumer 應用程式的版本** 、 **Provider 應用程式的版本** 與 **契約檔案的版本** 。\n\n#### 契約版本\n\n每一個被發佈到 Pact Broker 的契約都會有一個版本號，這塊是由 Pact Broker 自動處理的，開發人員並不需要針對契約設定版本。\n\n{% mermaid %}\ngraph TD\n  C0[\"Consumer\"]\n\n  subgraph Pact broker\n    P0[\"Contract (version:abc)\"]\n  end\n\n  C0 --> P0\n{% endmermaid %}\n\n#### Consumer 應用程式的版本\n\n每當一份契約被發佈到 Pact Broker 時，它會跟 **Consumer 的名稱** 、 **Consumer 應用程式的版本** 與 **Provider 的名稱** 產生關聯。其中，Consumer 的名稱與 Provider 的名稱會在撰寫契約測試時指定，版本的部分則是 Consumer 在發佈契約時指定的版本號，這個版本號必須是唯一的。這裡值得一提的是 Pact Broker 會針對 Consumer 發佈的契約進行雜湊比對，如果發佈的契約並沒有任何異動，則會將 Consumer 應用程式的版本與已經存在的契約建立關聯。\n\n{% mermaid %}\ngraph TD\n  subgraph Consumer\n    C0[\"Consumer v0.0.0\"]\n    C1[\"Consumer v0.0.1\"]\n    C2[\"Consumer v0.0.2\"]\n  end\n\n  subgraph Contracts\n    P1[\"Contract A (hash: abc123)\"]\n    P2[\"Contract B (hash: def456)\"]\n  end\n\n  C0 --> P1\n  C1 --> P1\n  C2 --> P2\n{% endmermaid %}\n\n讓多個 Consumer 應用程式版本指向同一個版本的契約不僅可以減少重複的內容，還可以避免重複驗證的情形，舉例來說，Consumer 版本為 `v0.0.0` 與 `v0.0.1` 時，並沒有改變契約的內容，那麼假設 Provider 已經針對 `v0.0.0` 發佈的契約進行驗證且通過，`v0.0.1` 也會視為驗證通過。\n\n> **注意**：為了讓檢查重複契約的機制可以順利運作，在撰寫測試的時候，應該要 **避免隨機產生資料的行為** ，因為如果有隨機產生的資料，進行雜湊的時候一定會不同，就會導致明明沒有改變契約內容卻因隨機資料而判定為契約有異動的情況。\n\n#### Provider 應用程式的版本\n\nProvider 與 Consumer 一樣需要定義應用程式版本，該版本會跟 Consumer 發佈的契約產生關聯，每當 Provider 發佈新版本時，需要針對關聯的契約進行驗證，確保 Provider 的異動可以通過契約測試。\n\n{% mermaid %}\ngraph TD\n  subgraph Consumer\n    C0[\"Consumer v0.0.0\"]\n  end\n\n  subgraph Contracts\n    CT1[\"Contract A (hash: abc123)\"]\n  end\n\n  subgraph Provider\n    P0[\"Provider v0.0.0\"]\n    P1[\"Provider v0.0.1\"]\n  end\n\n  C0 --> CT1\n  CT1 -- ❌ --- P0\n  CT1 -- ✅ --- P1\n{% endmermaid %}\n\n從上方概念圖可以看出，Consumer 版本 `v0.0.0` 產生的契約在 Provider 版本 `v0.0.0` 時驗證失敗，後來 Provider 釋出 `v0.0.1` 重新進行驗證就通過了，這裡可以看出是 Provider 在 `v0.0.0` 時有問題，所以釋出 `v0.0.1` 進行修正。\n\n#### Consumer 與 Provider 版本策略\n\n為了發揮契約測試的最大效用，會建議不論是開發功能的 `feature/*` 分支、準備部署到 Staging 環境的 `release/*` 分支又或是正式版的 `main` 分支都執行契約測試，這樣的好處是可以確保在各個階段都能驗證介面是否符合契約內容，及早發現問題。但也代表 Consumer 與 Provider 在版本策略上需要做出改變。\n\n在過去，版本的定義時間點可能會發生在部署到某個環境之前，這就表示開發功能的 `feature/*` 分支 **並不會有一個定義好的版本** ，那針對需要給定 Consumer 應用程式版本的 Pact Broker 來說就不符合規則，所以要改變的策略就是 **預定義版本**。根據 Pact 官方建議，可以在版本上添加 Git SHA 這類唯一且可識別版本的資訊，確保版本號一定不會有重複且能夠做到預定義版本。下圖是使用 Git Graph 繪製出的預定義版本情境，可以看到除了 `dev` 分支本身的 commit 有對應的版本外，`feature/a` 這個分支上也有定義版本：\n\n{% mermaid %}\n%%{init: { 'gitGraph': { 'mainBranchName': 'dev' } }}%%\ngitGraph\n  commit id: \"4fc667fb\" tag:\"v0.0.1-4fc667fb\"\n  commit id: \"2eed1c17\" tag:\"v0.0.1-2eed1c17\"\n\n  branch feature/a\n  checkout feature/a\n  commit\n  commit id: \"563c6421\" tag:\"v0.0.1-563c6421\"\n  commit\n  commit\n  commit\n  commit id: \"c517b5d3\" tag:\"v0.0.1-c517b5d3\"\n\n{% endmermaid %}\n\n### 矩陣 (Matrix)\n\nMatrix 是 Pact Broker 的核心功能，它是一張 Consumer 發佈契約與 Provider 驗證結果的記錄表，從這張表可以看出哪些 Consumer 版本發佈的契約在哪個 Provider 版本下是通過驗證的，進而得知 Consumer 版本與 Provider 版本之間的相容性。\n\n下方是一張範例表，從該表可以看出，Banana 這個 Provider 在釋出 `1.1.0` 的時候去驗證 Apple `1.0.0` 發佈的契約，驗證結果為不通過，就表示 Banana `1.1.0` 這個版本 **不相容** 於 Apple `1.0.0`，所以後來 Banana 釋出了 `1.1.1` 進行修復，從驗證結果來看是有正確修復的，就表示 Banana `1.1.1` 相容於 Apple `1.0.0`，而最後一筆可以看出，Apple 釋出了 `1.1.0` 也相容於 Banana `1.1.1` 版本：\n\n|Consumer|Consumer Version|Provider|Provider Version|Verification Result|\n|--------|----------------|--------|----------------|-------------------|\n|Apple   |1.0.0           |Banana  |1.0.0           |✅                 |\n|Apple   |1.0.0           |Banana  |1.1.0           |❌                 |\n|Apple   |1.0.0           |Banana  |1.1.1           |✅                 |\n|Apple   |1.1.0           |Banana  |1.1.1           |✅                 |\n\n> **補充**：Pact Broker 有提供十分強大的 Matrix UI 讓 Pacticipant 的開發者可以清楚知道上述的關係，後續會再做進一步的說明。\n\n## 架設 Pact Broker\n\nPact Broker 預設使用 [Postgres](https://www.postgresql.org/) 做為儲存資料的媒介。我們可以透過 Docker Compose 同時啟動 Postgres 與 Pact Broker。下方是 Docker Compose 的 YAML 範例：\n\n```yaml\nversion: '3'\nservices:\n  postgres:\n    image: postgres:12\n    environment:\n      POSTGRES_PASSWORD: mysecretpassword\n      POSTGRES_USER: postgres\n      POSTGRES_DB: pact_broker\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n\n  pact-broker:\n    image: pactfoundation/pact-broker\n    ports:\n      - \"9292:9292\"\n    environment:\n      PACT_BROKER_DATABASE_USERNAME: postgres\n      PACT_BROKER_DATABASE_PASSWORD: mysecretpassword\n      PACT_BROKER_DATABASE_HOST: postgres\n      PACT_BROKER_DATABASE_NAME: pact_broker\n    depends_on:\n      - postgres\n```\n\n在 `postgres` 設置了三個環境變數：\n\n* `POSTGRES_PASSWORD`：用來設置 系統管理員(Superuser) 的密碼。\n* `POSTGRES_USER`：用來設置 Superuser 的名稱。\n* `POSTGRES_DB`：用來設置預設資料庫的名稱。\n\n而在 `pact-broker` 的部分設置了四個環境變數：\n\n* `PACT_BROKER_DATABASE_USERNAME`：Pact Broker 存取資料庫的使用者名稱。\n* `PACT_BROKER_DATABASE_PASSWORD`：Pact Broker 存取資料庫的使用者密碼。\n* `PACT_BROKER_DATABASE_HOST`：Pact Broker 存取的資料庫 Host 位址。\n* `PACT_BROKER_DATABASE_NAME`：Pact Broker 要存取的資料庫名稱。\n\n透過下方指令執行 Docker Compose 並架設 Pact Broker 與 Postgres：\n\n```bash\n$ docker compose up -d\n```\n\n## 初探 Pact Broker UI\n\n架設完 Pact Broker 後，打開瀏覽器存取 [http://localhost:9292/](http://localhost:9292/) 會看到下方畫面：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui.png\"\n  alt=\"Pact Broker UI\"\n/>\n\n畫面中呈現了 Consumer 為「Example App」與 Provider 為「Example API」的組合，並呈現最後一次的驗證結果，可以看到上面寫「1 day ago」且背景色為綠色，表示最後一次驗證是發生在一天前且驗證通過。\n\n畫面上可以看到有一個表格的圖案：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix-entry.png\"\n  alt=\"Pact Broker UI Matrix Entry\"\n/>\n\n點擊後會顯示這個 Consumer、Provider 組合的 Matrix，預設情況下會顯示剛剛首頁呈現的最新一筆的驗證結果：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix.png\"\n  alt=\"Pact Broker UI Matrix\"\n/>\n\n透過畫面上方的查詢表單可以查到這個 Consumer、Provider 組合的所有版本、驗證結果的 Matrix：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix-all-result1.png\"\n  alt=\"Pact Broker UI Matrix All Result 1\"\n/>\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix-all-result2.png\"\n  alt=\"Pact Broker UI Matrix All Result 2\"\n/>\n\n從畫面中可以看到 Consumer 在版本為 `6c992f8` 的時候，Provider 並沒有執行驗證，而是到了 Consumer 發佈 `e15da45` 的兩天後，Provider 才使用 `480e5ae` 這個版本執行驗證，不過很可惜這邊出了問題所以驗證失敗，所以後續 Provider 使用 `1315e0b` 進行驗證並且結果是通過的。\n\n## Pact CLI\n\nPact 官方有推出 CLI 讓開發者可以透過其部署、檢索契約等操作。除了[獨立安裝檔](https://github.com/pact-foundation/pact-ruby-standalone/releases)外，還有推出 Docker Image 讓開發者可以更輕易地使用。透過下方指令從 DockerHub 進行下載：\n\n```bash\n$ docker pull pactfoundation/pact-cli:latest\n```\n\n下載完畢後，可以透過下方指令呼叫幫助清單：\n\n```bash\n$ docker run --rm pactfoundation/pact-cli help\n```\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-cli-help.png\"\n  alt=\"Pact CLI help\"\n/>\n\n### 部署契約\n\n延續「[在 NestJS 使用 Pact 實現契約測試](https://hao0731.github.io/2025/03/08/0005-nestjs-pact/)」文章中的測試，將這份契約透過 Pact CLI 發佈到 Pact Broker 上。\n\n> **注意**：請先將契約檔案產生出來。\n\nPact CLI 發佈契約會使用 `publish` 指令，格式如下：\n\n```bash\n$ docker run -it --rm -w ${PWD} -v ${PWD}:${PWD} --network=<PACT_BROKER_DOCKER_NETWORK> pactfoundation/pact-cli publish <CONTRACT_FILE_PATH> --consumer-app-version <GIT_SHA> --branch <GIT_BRANCH> --broker-base-url <PACT_BROKER_URL>\n```\n\n> **注意**：因為是使用 Docker 的方式來操作 Pact CLI，所以需要指定 Workspace 與 Volume，確保可以正確讀到契約檔案。\n\n從上方 `publish` 指令可以看到有許多參數，這裡一一解釋：\n\n* `<CONTRACT_FILE_PATH>`：契約檔案的位置。\n* `--consumer-app-version`：Consumer 發佈契約當下的應用程式版本，上方範例使用 `<GIT_SHA>` 作為佔位符，實際情況可以帶入該 Commit 的 Git SHA 值。\n* `--branch`：Consumer 發佈契約當下的分支。\n* `--broker-base-url`：Pact Broker 的 URL。\n\n下方是實際執行的畫面，可以看到執行完以後會顯示成功的訊息：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-cli-publish.png\"\n  alt=\"Pact CLI Publish\"\n/>\n\n進入 Pact Broker UI 看一下發佈的契約，可以看到有顯示出來且還沒有任何驗證結果：\n\n<img\n  style=\"max-width: 500px;\"\n  src=\"pact-cli-publish-result.png\"\n  alt=\"Pact CLI Publish Result\"\n/>\n\n## 整合契約驗證\n\n","slug":"0006-nestjs-pact-broker","published":1,"updated":"2025-04-20T13:42:31.868Z","comments":1,"layout":"post","photos":[],"_id":"cm9tztuw0001dfqgx9m5t90wg","content":"<h2 id=\"什麼是-Pact-Broker？\"><a href=\"#什麼是-Pact-Broker？\" class=\"headerlink\" title=\"什麼是 Pact Broker？\"></a>什麼是 Pact Broker？</h2><p>契約測試可以用更快、更低的成本來測試服務之間的介面是否有破壞性變更，強化服務之間介面的穩固性。但此測試方式面臨了一些挑戰：</p>\n<ul>\n<li><strong>契約管理</strong>：在微服務架構中，每個服務之間的契約可能數量很多且版本頻繁變動。需要一個集中的平台來儲存、追蹤這些契約檔案，並協助團隊理解每個契約的來源與歷史。</li>\n<li><strong>驗證結果管理</strong>：當 Provider 驗證 Consumer 所提交的契約時，我們需要一個地方來儲存這些驗證結果，讓團隊成員可以清楚知道目前哪個版本的服務與哪個契約已經完成驗證、是否相容。</li>\n</ul>\n<p>為了解決上述問題，Pact 團隊打造了 <a href=\"https://docs.pact.io/pact_broker\">Pact Broker</a> 這個工具。它是一個專門設計來儲存和管理 Pact 契約與驗證結果的服務。透過 Pact Broker，我們可以更有效地管理微服務之間的契約、驗證狀態、版本關係，將其融入 CI&#x2F;CD 即可打造自動化、高效的契約測試流程。</p>\n<blockquote>\n<p><strong>補充</strong>：有關於 Pact 相關的介紹可以參考<a href=\"https://docs.pact.io/\">官方文件</a>或是我之前寫的<a href=\"https://hao0731.github.io/2025/03/08/0005-nestjs-pact/\">文章</a>。</p>\n</blockquote>\n<h3 id=\"參與者-Pacticipants\"><a href=\"#參與者-Pacticipants\" class=\"headerlink\" title=\"參與者 (Pacticipants)\"></a>參與者 (Pacticipants)</h3><p><strong>參與者 (Pacticipants)</strong> 一詞是 Pact 與英文中的參與者 - Participants 合併後產生的單字。在 Pact Broker 中，最基本的單位就是參與契約測試的「服務」，也就是 Consumer 與 Provider，這些服務稱之為 Pacticipants。</p>\n<blockquote>\n<p><strong>補充</strong>：根據官方的說法，Pact Broker 的作者很後悔使用 Pacticipants 這個詞 XD</p>\n</blockquote>\n<h3 id=\"版本-Versioning\"><a href=\"#版本-Versioning\" class=\"headerlink\" title=\"版本 (Versioning)\"></a>版本 (Versioning)</h3><p>在 Pact Broker 的架構下，共有三種資源擁有版本，分別是：<strong>Consumer 應用程式的版本</strong> 、 <strong>Provider 應用程式的版本</strong> 與 <strong>契約檔案的版本</strong> 。</p>\n<h4 id=\"契約版本\"><a href=\"#契約版本\" class=\"headerlink\" title=\"契約版本\"></a>契約版本</h4><p>每一個被發佈到 Pact Broker 的契約都會有一個版本號，這塊是由 Pact Broker 自動處理的，開發人員並不需要針對契約設定版本。</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n    graph TD\n  C0[&quot;Consumer&quot;]\n\n  subgraph Pact broker\n    P0[&quot;Contract (version:abc)&quot;]\n  end\n\n  C0 --&gt; P0\n  </pre></div>\n\n<h4 id=\"Consumer-應用程式的版本\"><a href=\"#Consumer-應用程式的版本\" class=\"headerlink\" title=\"Consumer 應用程式的版本\"></a>Consumer 應用程式的版本</h4><p>每當一份契約被發佈到 Pact Broker 時，它會跟 <strong>Consumer 的名稱</strong> 、 <strong>Consumer 應用程式的版本</strong> 與 <strong>Provider 的名稱</strong> 產生關聯。其中，Consumer 的名稱與 Provider 的名稱會在撰寫契約測試時指定，版本的部分則是 Consumer 在發佈契約時指定的版本號，這個版本號必須是唯一的。這裡值得一提的是 Pact Broker 會針對 Consumer 發佈的契約進行雜湊比對，如果發佈的契約並沒有任何異動，則會將 Consumer 應用程式的版本與已經存在的契約建立關聯。</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n    graph TD\n  subgraph Consumer\n    C0[&quot;Consumer v0.0.0&quot;]\n    C1[&quot;Consumer v0.0.1&quot;]\n    C2[&quot;Consumer v0.0.2&quot;]\n  end\n\n  subgraph Contracts\n    P1[&quot;Contract A (hash: abc123)&quot;]\n    P2[&quot;Contract B (hash: def456)&quot;]\n  end\n\n  C0 --&gt; P1\n  C1 --&gt; P1\n  C2 --&gt; P2\n  </pre></div>\n\n<p>讓多個 Consumer 應用程式版本指向同一個版本的契約不僅可以減少重複的內容，還可以避免重複驗證的情形，舉例來說，Consumer 版本為 <code>v0.0.0</code> 與 <code>v0.0.1</code> 時，並沒有改變契約的內容，那麼假設 Provider 已經針對 <code>v0.0.0</code> 發佈的契約進行驗證且通過，<code>v0.0.1</code> 也會視為驗證通過。</p>\n<blockquote>\n<p><strong>注意</strong>：為了讓檢查重複契約的機制可以順利運作，在撰寫測試的時候，應該要 <strong>避免隨機產生資料的行為</strong> ，因為如果有隨機產生的資料，進行雜湊的時候一定會不同，就會導致明明沒有改變契約內容卻因隨機資料而判定為契約有異動的情況。</p>\n</blockquote>\n<h4 id=\"Provider-應用程式的版本\"><a href=\"#Provider-應用程式的版本\" class=\"headerlink\" title=\"Provider 應用程式的版本\"></a>Provider 應用程式的版本</h4><p>Provider 與 Consumer 一樣需要定義應用程式版本，該版本會跟 Consumer 發佈的契約產生關聯，每當 Provider 發佈新版本時，需要針對關聯的契約進行驗證，確保 Provider 的異動可以通過契約測試。</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n    graph TD\n  subgraph Consumer\n    C0[&quot;Consumer v0.0.0&quot;]\n  end\n\n  subgraph Contracts\n    CT1[&quot;Contract A (hash: abc123)&quot;]\n  end\n\n  subgraph Provider\n    P0[&quot;Provider v0.0.0&quot;]\n    P1[&quot;Provider v0.0.1&quot;]\n  end\n\n  C0 --&gt; CT1\n  CT1 -- ❌ --- P0\n  CT1 -- ✅ --- P1\n  </pre></div>\n\n<p>從上方概念圖可以看出，Consumer 版本 <code>v0.0.0</code> 產生的契約在 Provider 版本 <code>v0.0.0</code> 時驗證失敗，後來 Provider 釋出 <code>v0.0.1</code> 重新進行驗證就通過了，這裡可以看出是 Provider 在 <code>v0.0.0</code> 時有問題，所以釋出 <code>v0.0.1</code> 進行修正。</p>\n<h4 id=\"Consumer-與-Provider-版本策略\"><a href=\"#Consumer-與-Provider-版本策略\" class=\"headerlink\" title=\"Consumer 與 Provider 版本策略\"></a>Consumer 與 Provider 版本策略</h4><p>為了發揮契約測試的最大效用，會建議不論是開發功能的 <code>feature/*</code> 分支、準備部署到 Staging 環境的 <code>release/*</code> 分支又或是正式版的 <code>main</code> 分支都執行契約測試，這樣的好處是可以確保在各個階段都能驗證介面是否符合契約內容，及早發現問題。但也代表 Consumer 與 Provider 在版本策略上需要做出改變。</p>\n<p>在過去，版本的定義時間點可能會發生在部署到某個環境之前，這就表示開發功能的 <code>feature/*</code> 分支 <strong>並不會有一個定義好的版本</strong> ，那針對需要給定 Consumer 應用程式版本的 Pact Broker 來說就不符合規則，所以要改變的策略就是 <strong>預定義版本</strong>。根據 Pact 官方建議，可以在版本上添加 Git SHA 這類唯一且可識別版本的資訊，確保版本號一定不會有重複且能夠做到預定義版本。下圖是使用 Git Graph 繪製出的預定義版本情境，可以看到除了 <code>dev</code> 分支本身的 commit 有對應的版本外，<code>feature/a</code> 這個分支上也有定義版本：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n    %%{init: { &#39;gitGraph&#39;: { &#39;mainBranchName&#39;: &#39;dev&#39; } }}%%\ngitGraph\n  commit id: &quot;4fc667fb&quot; tag:&quot;v0.0.1-4fc667fb&quot;\n  commit id: &quot;2eed1c17&quot; tag:&quot;v0.0.1-2eed1c17&quot;\n\n  branch feature&#x2F;a\n  checkout feature&#x2F;a\n  commit\n  commit id: &quot;563c6421&quot; tag:&quot;v0.0.1-563c6421&quot;\n  commit\n  commit\n  commit\n  commit id: &quot;c517b5d3&quot; tag:&quot;v0.0.1-c517b5d3&quot;\n\n  </pre></div>\n\n<h3 id=\"矩陣-Matrix\"><a href=\"#矩陣-Matrix\" class=\"headerlink\" title=\"矩陣 (Matrix)\"></a>矩陣 (Matrix)</h3><p>Matrix 是 Pact Broker 的核心功能，它是一張 Consumer 發佈契約與 Provider 驗證結果的記錄表，從這張表可以看出哪些 Consumer 版本發佈的契約在哪個 Provider 版本下是通過驗證的，進而得知 Consumer 版本與 Provider 版本之間的相容性。</p>\n<p>下方是一張範例表，從該表可以看出，Banana 這個 Provider 在釋出 <code>1.1.0</code> 的時候去驗證 Apple <code>1.0.0</code> 發佈的契約，驗證結果為不通過，就表示 Banana <code>1.1.0</code> 這個版本 <strong>不相容</strong> 於 Apple <code>1.0.0</code>，所以後來 Banana 釋出了 <code>1.1.1</code> 進行修復，從驗證結果來看是有正確修復的，就表示 Banana <code>1.1.1</code> 相容於 Apple <code>1.0.0</code>，而最後一筆可以看出，Apple 釋出了 <code>1.1.0</code> 也相容於 Banana <code>1.1.1</code> 版本：</p>\n<table>\n<thead>\n<tr>\n<th>Consumer</th>\n<th>Consumer Version</th>\n<th>Provider</th>\n<th>Provider Version</th>\n<th>Verification Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Apple</td>\n<td>1.0.0</td>\n<td>Banana</td>\n<td>1.0.0</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Apple</td>\n<td>1.0.0</td>\n<td>Banana</td>\n<td>1.1.0</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>Apple</td>\n<td>1.0.0</td>\n<td>Banana</td>\n<td>1.1.1</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Apple</td>\n<td>1.1.0</td>\n<td>Banana</td>\n<td>1.1.1</td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>補充</strong>：Pact Broker 有提供十分強大的 Matrix UI 讓 Pacticipant 的開發者可以清楚知道上述的關係，後續會再做進一步的說明。</p>\n</blockquote>\n<h2 id=\"架設-Pact-Broker\"><a href=\"#架設-Pact-Broker\" class=\"headerlink\" title=\"架設 Pact Broker\"></a>架設 Pact Broker</h2><p>Pact Broker 預設使用 <a href=\"https://www.postgresql.org/\">Postgres</a> 做為儲存資料的媒介。我們可以透過 Docker Compose 同時啟動 Postgres 與 Pact Broker。下方是 Docker Compose 的 YAML 範例：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">postgres:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">postgres:12</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">POSTGRES_PASSWORD:</span> <span class=\"string\">mysecretpassword</span></span><br><span class=\"line\">      <span class=\"attr\">POSTGRES_USER:</span> <span class=\"string\">postgres</span></span><br><span class=\"line\">      <span class=\"attr\">POSTGRES_DB:</span> <span class=\"string\">pact_broker</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;5432:5432&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">pgdata:/var/lib/postgresql/data</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">pact-broker:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">pactfoundation/pact-broker</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;9292:9292&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">PACT_BROKER_DATABASE_USERNAME:</span> <span class=\"string\">postgres</span></span><br><span class=\"line\">      <span class=\"attr\">PACT_BROKER_DATABASE_PASSWORD:</span> <span class=\"string\">mysecretpassword</span></span><br><span class=\"line\">      <span class=\"attr\">PACT_BROKER_DATABASE_HOST:</span> <span class=\"string\">postgres</span></span><br><span class=\"line\">      <span class=\"attr\">PACT_BROKER_DATABASE_NAME:</span> <span class=\"string\">pact_broker</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">postgres</span></span><br></pre></td></tr></table></figure>\n\n<p>在 <code>postgres</code> 設置了三個環境變數：</p>\n<ul>\n<li><code>POSTGRES_PASSWORD</code>：用來設置 系統管理員(Superuser) 的密碼。</li>\n<li><code>POSTGRES_USER</code>：用來設置 Superuser 的名稱。</li>\n<li><code>POSTGRES_DB</code>：用來設置預設資料庫的名稱。</li>\n</ul>\n<p>而在 <code>pact-broker</code> 的部分設置了四個環境變數：</p>\n<ul>\n<li><code>PACT_BROKER_DATABASE_USERNAME</code>：Pact Broker 存取資料庫的使用者名稱。</li>\n<li><code>PACT_BROKER_DATABASE_PASSWORD</code>：Pact Broker 存取資料庫的使用者密碼。</li>\n<li><code>PACT_BROKER_DATABASE_HOST</code>：Pact Broker 存取的資料庫 Host 位址。</li>\n<li><code>PACT_BROKER_DATABASE_NAME</code>：Pact Broker 要存取的資料庫名稱。</li>\n</ul>\n<p>透過下方指令執行 Docker Compose 並架設 Pact Broker 與 Postgres：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker compose up -d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初探-Pact-Broker-UI\"><a href=\"#初探-Pact-Broker-UI\" class=\"headerlink\" title=\"初探 Pact Broker UI\"></a>初探 Pact Broker UI</h2><p>架設完 Pact Broker 後，打開瀏覽器存取 <a href=\"http://localhost:9292/\">http://localhost:9292/</a> 會看到下方畫面：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui.png\"\n  alt=\"Pact Broker UI\"\n/></p>\n<p>畫面中呈現了 Consumer 為「Example App」與 Provider 為「Example API」的組合，並呈現最後一次的驗證結果，可以看到上面寫「1 day ago」且背景色為綠色，表示最後一次驗證是發生在一天前且驗證通過。</p>\n<p>畫面上可以看到有一個表格的圖案：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix-entry.png\"\n  alt=\"Pact Broker UI Matrix Entry\"\n/></p>\n<p>點擊後會顯示這個 Consumer、Provider 組合的 Matrix，預設情況下會顯示剛剛首頁呈現的最新一筆的驗證結果：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix.png\"\n  alt=\"Pact Broker UI Matrix\"\n/></p>\n<p>透過畫面上方的查詢表單可以查到這個 Consumer、Provider 組合的所有版本、驗證結果的 Matrix：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix-all-result1.png\"\n  alt=\"Pact Broker UI Matrix All Result 1\"\n/></p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix-all-result2.png\"\n  alt=\"Pact Broker UI Matrix All Result 2\"\n/></p>\n<p>從畫面中可以看到 Consumer 在版本為 <code>6c992f8</code> 的時候，Provider 並沒有執行驗證，而是到了 Consumer 發佈 <code>e15da45</code> 的兩天後，Provider 才使用 <code>480e5ae</code> 這個版本執行驗證，不過很可惜這邊出了問題所以驗證失敗，所以後續 Provider 使用 <code>1315e0b</code> 進行驗證並且結果是通過的。</p>\n<h2 id=\"Pact-CLI\"><a href=\"#Pact-CLI\" class=\"headerlink\" title=\"Pact CLI\"></a>Pact CLI</h2><p>Pact 官方有推出 CLI 讓開發者可以透過其部署、檢索契約等操作。除了<a href=\"https://github.com/pact-foundation/pact-ruby-standalone/releases\">獨立安裝檔</a>外，還有推出 Docker Image 讓開發者可以更輕易地使用。透過下方指令從 DockerHub 進行下載：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull pactfoundation/pact-cli:latest</span><br></pre></td></tr></table></figure>\n\n<p>下載完畢後，可以透過下方指令呼叫幫助清單：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --<span class=\"built_in\">rm</span> pactfoundation/pact-cli <span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-cli-help.png\"\n  alt=\"Pact CLI help\"\n/></p>\n<h3 id=\"部署契約\"><a href=\"#部署契約\" class=\"headerlink\" title=\"部署契約\"></a>部署契約</h3><p>延續「<a href=\"https://hao0731.github.io/2025/03/08/0005-nestjs-pact/\">在 NestJS 使用 Pact 實現契約測試</a>」文章中的測試，將這份契約透過 Pact CLI 發佈到 Pact Broker 上。</p>\n<blockquote>\n<p><strong>注意</strong>：請先將契約檔案產生出來。</p>\n</blockquote>\n<p>Pact CLI 發佈契約會使用 <code>publish</code> 指令，格式如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -it --<span class=\"built_in\">rm</span> -w <span class=\"variable\">$&#123;PWD&#125;</span> -v <span class=\"variable\">$&#123;PWD&#125;</span>:<span class=\"variable\">$&#123;PWD&#125;</span> --network=&lt;PACT_BROKER_DOCKER_NETWORK&gt; pactfoundation/pact-cli publish &lt;CONTRACT_FILE_PATH&gt; --consumer-app-version &lt;GIT_SHA&gt; --branch &lt;GIT_BRANCH&gt; --broker-base-url &lt;PACT_BROKER_URL&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong>：因為是使用 Docker 的方式來操作 Pact CLI，所以需要指定 Workspace 與 Volume，確保可以正確讀到契約檔案。</p>\n</blockquote>\n<p>從上方 <code>publish</code> 指令可以看到有許多參數，這裡一一解釋：</p>\n<ul>\n<li><code>&lt;CONTRACT_FILE_PATH&gt;</code>：契約檔案的位置。</li>\n<li><code>--consumer-app-version</code>：Consumer 發佈契約當下的應用程式版本，上方範例使用 <code>&lt;GIT_SHA&gt;</code> 作為佔位符，實際情況可以帶入該 Commit 的 Git SHA 值。</li>\n<li><code>--branch</code>：Consumer 發佈契約當下的分支。</li>\n<li><code>--broker-base-url</code>：Pact Broker 的 URL。</li>\n</ul>\n<p>下方是實際執行的畫面，可以看到執行完以後會顯示成功的訊息：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-cli-publish.png\"\n  alt=\"Pact CLI Publish\"\n/></p>\n<p>進入 Pact Broker UI 看一下發佈的契約，可以看到有顯示出來且還沒有任何驗證結果：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-cli-publish-result.png\"\n  alt=\"Pact CLI Publish Result\"\n/></p>\n<h2 id=\"整合契約驗證\"><a href=\"#整合契約驗證\" class=\"headerlink\" title=\"整合契約驗證\"></a>整合契約驗證</h2>","excerpt":"","more":"<h2 id=\"什麼是-Pact-Broker？\"><a href=\"#什麼是-Pact-Broker？\" class=\"headerlink\" title=\"什麼是 Pact Broker？\"></a>什麼是 Pact Broker？</h2><p>契約測試可以用更快、更低的成本來測試服務之間的介面是否有破壞性變更，強化服務之間介面的穩固性。但此測試方式面臨了一些挑戰：</p>\n<ul>\n<li><strong>契約管理</strong>：在微服務架構中，每個服務之間的契約可能數量很多且版本頻繁變動。需要一個集中的平台來儲存、追蹤這些契約檔案，並協助團隊理解每個契約的來源與歷史。</li>\n<li><strong>驗證結果管理</strong>：當 Provider 驗證 Consumer 所提交的契約時，我們需要一個地方來儲存這些驗證結果，讓團隊成員可以清楚知道目前哪個版本的服務與哪個契約已經完成驗證、是否相容。</li>\n</ul>\n<p>為了解決上述問題，Pact 團隊打造了 <a href=\"https://docs.pact.io/pact_broker\">Pact Broker</a> 這個工具。它是一個專門設計來儲存和管理 Pact 契約與驗證結果的服務。透過 Pact Broker，我們可以更有效地管理微服務之間的契約、驗證狀態、版本關係，將其融入 CI&#x2F;CD 即可打造自動化、高效的契約測試流程。</p>\n<blockquote>\n<p><strong>補充</strong>：有關於 Pact 相關的介紹可以參考<a href=\"https://docs.pact.io/\">官方文件</a>或是我之前寫的<a href=\"https://hao0731.github.io/2025/03/08/0005-nestjs-pact/\">文章</a>。</p>\n</blockquote>\n<h3 id=\"參與者-Pacticipants\"><a href=\"#參與者-Pacticipants\" class=\"headerlink\" title=\"參與者 (Pacticipants)\"></a>參與者 (Pacticipants)</h3><p><strong>參與者 (Pacticipants)</strong> 一詞是 Pact 與英文中的參與者 - Participants 合併後產生的單字。在 Pact Broker 中，最基本的單位就是參與契約測試的「服務」，也就是 Consumer 與 Provider，這些服務稱之為 Pacticipants。</p>\n<blockquote>\n<p><strong>補充</strong>：根據官方的說法，Pact Broker 的作者很後悔使用 Pacticipants 這個詞 XD</p>\n</blockquote>\n<h3 id=\"版本-Versioning\"><a href=\"#版本-Versioning\" class=\"headerlink\" title=\"版本 (Versioning)\"></a>版本 (Versioning)</h3><p>在 Pact Broker 的架構下，共有三種資源擁有版本，分別是：<strong>Consumer 應用程式的版本</strong> 、 <strong>Provider 應用程式的版本</strong> 與 <strong>契約檔案的版本</strong> 。</p>\n<h4 id=\"契約版本\"><a href=\"#契約版本\" class=\"headerlink\" title=\"契約版本\"></a>契約版本</h4><p>每一個被發佈到 Pact Broker 的契約都會有一個版本號，這塊是由 Pact Broker 自動處理的，開發人員並不需要針對契約設定版本。</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n    graph TD\n  C0[&quot;Consumer&quot;]\n\n  subgraph Pact broker\n    P0[&quot;Contract (version:abc)&quot;]\n  end\n\n  C0 --&gt; P0\n  </pre></div>\n\n<h4 id=\"Consumer-應用程式的版本\"><a href=\"#Consumer-應用程式的版本\" class=\"headerlink\" title=\"Consumer 應用程式的版本\"></a>Consumer 應用程式的版本</h4><p>每當一份契約被發佈到 Pact Broker 時，它會跟 <strong>Consumer 的名稱</strong> 、 <strong>Consumer 應用程式的版本</strong> 與 <strong>Provider 的名稱</strong> 產生關聯。其中，Consumer 的名稱與 Provider 的名稱會在撰寫契約測試時指定，版本的部分則是 Consumer 在發佈契約時指定的版本號，這個版本號必須是唯一的。這裡值得一提的是 Pact Broker 會針對 Consumer 發佈的契約進行雜湊比對，如果發佈的契約並沒有任何異動，則會將 Consumer 應用程式的版本與已經存在的契約建立關聯。</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n    graph TD\n  subgraph Consumer\n    C0[&quot;Consumer v0.0.0&quot;]\n    C1[&quot;Consumer v0.0.1&quot;]\n    C2[&quot;Consumer v0.0.2&quot;]\n  end\n\n  subgraph Contracts\n    P1[&quot;Contract A (hash: abc123)&quot;]\n    P2[&quot;Contract B (hash: def456)&quot;]\n  end\n\n  C0 --&gt; P1\n  C1 --&gt; P1\n  C2 --&gt; P2\n  </pre></div>\n\n<p>讓多個 Consumer 應用程式版本指向同一個版本的契約不僅可以減少重複的內容，還可以避免重複驗證的情形，舉例來說，Consumer 版本為 <code>v0.0.0</code> 與 <code>v0.0.1</code> 時，並沒有改變契約的內容，那麼假設 Provider 已經針對 <code>v0.0.0</code> 發佈的契約進行驗證且通過，<code>v0.0.1</code> 也會視為驗證通過。</p>\n<blockquote>\n<p><strong>注意</strong>：為了讓檢查重複契約的機制可以順利運作，在撰寫測試的時候，應該要 <strong>避免隨機產生資料的行為</strong> ，因為如果有隨機產生的資料，進行雜湊的時候一定會不同，就會導致明明沒有改變契約內容卻因隨機資料而判定為契約有異動的情況。</p>\n</blockquote>\n<h4 id=\"Provider-應用程式的版本\"><a href=\"#Provider-應用程式的版本\" class=\"headerlink\" title=\"Provider 應用程式的版本\"></a>Provider 應用程式的版本</h4><p>Provider 與 Consumer 一樣需要定義應用程式版本，該版本會跟 Consumer 發佈的契約產生關聯，每當 Provider 發佈新版本時，需要針對關聯的契約進行驗證，確保 Provider 的異動可以通過契約測試。</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n    graph TD\n  subgraph Consumer\n    C0[&quot;Consumer v0.0.0&quot;]\n  end\n\n  subgraph Contracts\n    CT1[&quot;Contract A (hash: abc123)&quot;]\n  end\n\n  subgraph Provider\n    P0[&quot;Provider v0.0.0&quot;]\n    P1[&quot;Provider v0.0.1&quot;]\n  end\n\n  C0 --&gt; CT1\n  CT1 -- ❌ --- P0\n  CT1 -- ✅ --- P1\n  </pre></div>\n\n<p>從上方概念圖可以看出，Consumer 版本 <code>v0.0.0</code> 產生的契約在 Provider 版本 <code>v0.0.0</code> 時驗證失敗，後來 Provider 釋出 <code>v0.0.1</code> 重新進行驗證就通過了，這裡可以看出是 Provider 在 <code>v0.0.0</code> 時有問題，所以釋出 <code>v0.0.1</code> 進行修正。</p>\n<h4 id=\"Consumer-與-Provider-版本策略\"><a href=\"#Consumer-與-Provider-版本策略\" class=\"headerlink\" title=\"Consumer 與 Provider 版本策略\"></a>Consumer 與 Provider 版本策略</h4><p>為了發揮契約測試的最大效用，會建議不論是開發功能的 <code>feature/*</code> 分支、準備部署到 Staging 環境的 <code>release/*</code> 分支又或是正式版的 <code>main</code> 分支都執行契約測試，這樣的好處是可以確保在各個階段都能驗證介面是否符合契約內容，及早發現問題。但也代表 Consumer 與 Provider 在版本策略上需要做出改變。</p>\n<p>在過去，版本的定義時間點可能會發生在部署到某個環境之前，這就表示開發功能的 <code>feature/*</code> 分支 <strong>並不會有一個定義好的版本</strong> ，那針對需要給定 Consumer 應用程式版本的 Pact Broker 來說就不符合規則，所以要改變的策略就是 <strong>預定義版本</strong>。根據 Pact 官方建議，可以在版本上添加 Git SHA 這類唯一且可識別版本的資訊，確保版本號一定不會有重複且能夠做到預定義版本。下圖是使用 Git Graph 繪製出的預定義版本情境，可以看到除了 <code>dev</code> 分支本身的 commit 有對應的版本外，<code>feature/a</code> 這個分支上也有定義版本：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n    %%{init: { &#39;gitGraph&#39;: { &#39;mainBranchName&#39;: &#39;dev&#39; } }}%%\ngitGraph\n  commit id: &quot;4fc667fb&quot; tag:&quot;v0.0.1-4fc667fb&quot;\n  commit id: &quot;2eed1c17&quot; tag:&quot;v0.0.1-2eed1c17&quot;\n\n  branch feature&#x2F;a\n  checkout feature&#x2F;a\n  commit\n  commit id: &quot;563c6421&quot; tag:&quot;v0.0.1-563c6421&quot;\n  commit\n  commit\n  commit\n  commit id: &quot;c517b5d3&quot; tag:&quot;v0.0.1-c517b5d3&quot;\n\n  </pre></div>\n\n<h3 id=\"矩陣-Matrix\"><a href=\"#矩陣-Matrix\" class=\"headerlink\" title=\"矩陣 (Matrix)\"></a>矩陣 (Matrix)</h3><p>Matrix 是 Pact Broker 的核心功能，它是一張 Consumer 發佈契約與 Provider 驗證結果的記錄表，從這張表可以看出哪些 Consumer 版本發佈的契約在哪個 Provider 版本下是通過驗證的，進而得知 Consumer 版本與 Provider 版本之間的相容性。</p>\n<p>下方是一張範例表，從該表可以看出，Banana 這個 Provider 在釋出 <code>1.1.0</code> 的時候去驗證 Apple <code>1.0.0</code> 發佈的契約，驗證結果為不通過，就表示 Banana <code>1.1.0</code> 這個版本 <strong>不相容</strong> 於 Apple <code>1.0.0</code>，所以後來 Banana 釋出了 <code>1.1.1</code> 進行修復，從驗證結果來看是有正確修復的，就表示 Banana <code>1.1.1</code> 相容於 Apple <code>1.0.0</code>，而最後一筆可以看出，Apple 釋出了 <code>1.1.0</code> 也相容於 Banana <code>1.1.1</code> 版本：</p>\n<table>\n<thead>\n<tr>\n<th>Consumer</th>\n<th>Consumer Version</th>\n<th>Provider</th>\n<th>Provider Version</th>\n<th>Verification Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Apple</td>\n<td>1.0.0</td>\n<td>Banana</td>\n<td>1.0.0</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Apple</td>\n<td>1.0.0</td>\n<td>Banana</td>\n<td>1.1.0</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>Apple</td>\n<td>1.0.0</td>\n<td>Banana</td>\n<td>1.1.1</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Apple</td>\n<td>1.1.0</td>\n<td>Banana</td>\n<td>1.1.1</td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>補充</strong>：Pact Broker 有提供十分強大的 Matrix UI 讓 Pacticipant 的開發者可以清楚知道上述的關係，後續會再做進一步的說明。</p>\n</blockquote>\n<h2 id=\"架設-Pact-Broker\"><a href=\"#架設-Pact-Broker\" class=\"headerlink\" title=\"架設 Pact Broker\"></a>架設 Pact Broker</h2><p>Pact Broker 預設使用 <a href=\"https://www.postgresql.org/\">Postgres</a> 做為儲存資料的媒介。我們可以透過 Docker Compose 同時啟動 Postgres 與 Pact Broker。下方是 Docker Compose 的 YAML 範例：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">postgres:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">postgres:12</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">POSTGRES_PASSWORD:</span> <span class=\"string\">mysecretpassword</span></span><br><span class=\"line\">      <span class=\"attr\">POSTGRES_USER:</span> <span class=\"string\">postgres</span></span><br><span class=\"line\">      <span class=\"attr\">POSTGRES_DB:</span> <span class=\"string\">pact_broker</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;5432:5432&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">pgdata:/var/lib/postgresql/data</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">pact-broker:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">pactfoundation/pact-broker</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;9292:9292&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">PACT_BROKER_DATABASE_USERNAME:</span> <span class=\"string\">postgres</span></span><br><span class=\"line\">      <span class=\"attr\">PACT_BROKER_DATABASE_PASSWORD:</span> <span class=\"string\">mysecretpassword</span></span><br><span class=\"line\">      <span class=\"attr\">PACT_BROKER_DATABASE_HOST:</span> <span class=\"string\">postgres</span></span><br><span class=\"line\">      <span class=\"attr\">PACT_BROKER_DATABASE_NAME:</span> <span class=\"string\">pact_broker</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">postgres</span></span><br></pre></td></tr></table></figure>\n\n<p>在 <code>postgres</code> 設置了三個環境變數：</p>\n<ul>\n<li><code>POSTGRES_PASSWORD</code>：用來設置 系統管理員(Superuser) 的密碼。</li>\n<li><code>POSTGRES_USER</code>：用來設置 Superuser 的名稱。</li>\n<li><code>POSTGRES_DB</code>：用來設置預設資料庫的名稱。</li>\n</ul>\n<p>而在 <code>pact-broker</code> 的部分設置了四個環境變數：</p>\n<ul>\n<li><code>PACT_BROKER_DATABASE_USERNAME</code>：Pact Broker 存取資料庫的使用者名稱。</li>\n<li><code>PACT_BROKER_DATABASE_PASSWORD</code>：Pact Broker 存取資料庫的使用者密碼。</li>\n<li><code>PACT_BROKER_DATABASE_HOST</code>：Pact Broker 存取的資料庫 Host 位址。</li>\n<li><code>PACT_BROKER_DATABASE_NAME</code>：Pact Broker 要存取的資料庫名稱。</li>\n</ul>\n<p>透過下方指令執行 Docker Compose 並架設 Pact Broker 與 Postgres：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker compose up -d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初探-Pact-Broker-UI\"><a href=\"#初探-Pact-Broker-UI\" class=\"headerlink\" title=\"初探 Pact Broker UI\"></a>初探 Pact Broker UI</h2><p>架設完 Pact Broker 後，打開瀏覽器存取 <a href=\"http://localhost:9292/\">http://localhost:9292/</a> 會看到下方畫面：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui.png\"\n  alt=\"Pact Broker UI\"\n/></p>\n<p>畫面中呈現了 Consumer 為「Example App」與 Provider 為「Example API」的組合，並呈現最後一次的驗證結果，可以看到上面寫「1 day ago」且背景色為綠色，表示最後一次驗證是發生在一天前且驗證通過。</p>\n<p>畫面上可以看到有一個表格的圖案：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix-entry.png\"\n  alt=\"Pact Broker UI Matrix Entry\"\n/></p>\n<p>點擊後會顯示這個 Consumer、Provider 組合的 Matrix，預設情況下會顯示剛剛首頁呈現的最新一筆的驗證結果：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix.png\"\n  alt=\"Pact Broker UI Matrix\"\n/></p>\n<p>透過畫面上方的查詢表單可以查到這個 Consumer、Provider 組合的所有版本、驗證結果的 Matrix：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix-all-result1.png\"\n  alt=\"Pact Broker UI Matrix All Result 1\"\n/></p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-broker-ui-matrix-all-result2.png\"\n  alt=\"Pact Broker UI Matrix All Result 2\"\n/></p>\n<p>從畫面中可以看到 Consumer 在版本為 <code>6c992f8</code> 的時候，Provider 並沒有執行驗證，而是到了 Consumer 發佈 <code>e15da45</code> 的兩天後，Provider 才使用 <code>480e5ae</code> 這個版本執行驗證，不過很可惜這邊出了問題所以驗證失敗，所以後續 Provider 使用 <code>1315e0b</code> 進行驗證並且結果是通過的。</p>\n<h2 id=\"Pact-CLI\"><a href=\"#Pact-CLI\" class=\"headerlink\" title=\"Pact CLI\"></a>Pact CLI</h2><p>Pact 官方有推出 CLI 讓開發者可以透過其部署、檢索契約等操作。除了<a href=\"https://github.com/pact-foundation/pact-ruby-standalone/releases\">獨立安裝檔</a>外，還有推出 Docker Image 讓開發者可以更輕易地使用。透過下方指令從 DockerHub 進行下載：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull pactfoundation/pact-cli:latest</span><br></pre></td></tr></table></figure>\n\n<p>下載完畢後，可以透過下方指令呼叫幫助清單：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --<span class=\"built_in\">rm</span> pactfoundation/pact-cli <span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-cli-help.png\"\n  alt=\"Pact CLI help\"\n/></p>\n<h3 id=\"部署契約\"><a href=\"#部署契約\" class=\"headerlink\" title=\"部署契約\"></a>部署契約</h3><p>延續「<a href=\"https://hao0731.github.io/2025/03/08/0005-nestjs-pact/\">在 NestJS 使用 Pact 實現契約測試</a>」文章中的測試，將這份契約透過 Pact CLI 發佈到 Pact Broker 上。</p>\n<blockquote>\n<p><strong>注意</strong>：請先將契約檔案產生出來。</p>\n</blockquote>\n<p>Pact CLI 發佈契約會使用 <code>publish</code> 指令，格式如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -it --<span class=\"built_in\">rm</span> -w <span class=\"variable\">$&#123;PWD&#125;</span> -v <span class=\"variable\">$&#123;PWD&#125;</span>:<span class=\"variable\">$&#123;PWD&#125;</span> --network=&lt;PACT_BROKER_DOCKER_NETWORK&gt; pactfoundation/pact-cli publish &lt;CONTRACT_FILE_PATH&gt; --consumer-app-version &lt;GIT_SHA&gt; --branch &lt;GIT_BRANCH&gt; --broker-base-url &lt;PACT_BROKER_URL&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong>：因為是使用 Docker 的方式來操作 Pact CLI，所以需要指定 Workspace 與 Volume，確保可以正確讀到契約檔案。</p>\n</blockquote>\n<p>從上方 <code>publish</code> 指令可以看到有許多參數，這裡一一解釋：</p>\n<ul>\n<li><code>&lt;CONTRACT_FILE_PATH&gt;</code>：契約檔案的位置。</li>\n<li><code>--consumer-app-version</code>：Consumer 發佈契約當下的應用程式版本，上方範例使用 <code>&lt;GIT_SHA&gt;</code> 作為佔位符，實際情況可以帶入該 Commit 的 Git SHA 值。</li>\n<li><code>--branch</code>：Consumer 發佈契約當下的分支。</li>\n<li><code>--broker-base-url</code>：Pact Broker 的 URL。</li>\n</ul>\n<p>下方是實際執行的畫面，可以看到執行完以後會顯示成功的訊息：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-cli-publish.png\"\n  alt=\"Pact CLI Publish\"\n/></p>\n<p>進入 Pact Broker UI 看一下發佈的契約，可以看到有顯示出來且還沒有任何驗證結果：</p>\n<p><img\n  style=\"max-width: 500px;\"\n  src=\"pact-cli-publish-result.png\"\n  alt=\"Pact CLI Publish Result\"\n/></p>\n<h2 id=\"整合契約驗證\"><a href=\"#整合契約驗證\" class=\"headerlink\" title=\"整合契約驗證\"></a>整合契約驗證</h2>"}],"PostAsset":[{"_id":"source/_posts/0001-dynamic-load-web-component/web-component-dynamic-loader.png","post":"cm9tztuvj0003fqgx1oan4apl","slug":"web-component-dynamic-loader.png","modified":1,"renderable":0},{"_id":"source/_posts/0001-dynamic-load-web-component/web-component-for-framework.png","post":"cm9tztuvj0003fqgx1oan4apl","slug":"web-component-for-framework.png","modified":1,"renderable":0},{"_id":"source/_posts/0003-what-is-krakend/health-check-result.png","post":"cm9tztuvn0006fqgxdrg05uhh","slug":"health-check-result.png","modified":1,"renderable":0},{"_id":"source/_posts/0003-what-is-krakend/krakend-flow.png","post":"cm9tztuvn0006fqgxdrg05uhh","slug":"krakend-flow.png","modified":1,"renderable":0},{"_id":"source/_posts/0003-what-is-krakend/krakend-help.png","post":"cm9tztuvn0006fqgxdrg05uhh","slug":"krakend-help.png","modified":1,"renderable":0},{"_id":"source/_posts/0003-what-is-krakend/krakend-result.png","post":"cm9tztuvn0006fqgxdrg05uhh","slug":"krakend-result.png","modified":1,"renderable":0},{"_id":"source/_posts/0004-nestjs-valkey/serve-valkey-cli.png","post":"cm9tztuvp0009fqgx1gi5f55b","slug":"serve-valkey-cli.png","modified":1,"renderable":0},{"_id":"source/_posts/0004-nestjs-valkey/valkey-get-command.png","post":"cm9tztuvp0009fqgx1gi5f55b","slug":"valkey-get-command.png","modified":1,"renderable":0},{"_id":"source/_posts/0004-nestjs-valkey/valkey-get-expired-value.png","post":"cm9tztuvp0009fqgx1gi5f55b","slug":"valkey-get-expired-value.png","modified":1,"renderable":0},{"_id":"source/_posts/0004-nestjs-valkey/valkey-logo.png","post":"cm9tztuvp0009fqgx1gi5f55b","slug":"valkey-logo.png","modified":1,"renderable":0},{"_id":"source/_posts/0004-nestjs-valkey/valkey-set-command.png","post":"cm9tztuvp0009fqgx1gi5f55b","slug":"valkey-set-command.png","modified":1,"renderable":0},{"_id":"source/_posts/0005-nestjs-pact/consumer-class-diagram.png","post":"cm9tztuvz001cfqgxgtnqe0qv","slug":"consumer-class-diagram.png","modified":1,"renderable":0},{"_id":"source/_posts/0005-nestjs-pact/consumer-test-result.png","post":"cm9tztuvz001cfqgxgtnqe0qv","slug":"consumer-test-result.png","modified":1,"renderable":0},{"_id":"source/_posts/0005-nestjs-pact/contract-testing-concept.png","post":"cm9tztuvz001cfqgxgtnqe0qv","slug":"contract-testing-concept.png","modified":1,"renderable":0},{"_id":"source/_posts/0005-nestjs-pact/generated-contract.png","post":"cm9tztuvz001cfqgxgtnqe0qv","slug":"generated-contract.png","modified":1,"renderable":0},{"_id":"source/_posts/0005-nestjs-pact/pact-flow-concept.png","post":"cm9tztuvz001cfqgxgtnqe0qv","slug":"pact-flow-concept.png","modified":1,"renderable":0},{"_id":"source/_posts/0005-nestjs-pact/pact-logo.png","post":"cm9tztuvz001cfqgxgtnqe0qv","slug":"pact-logo.png","modified":1,"renderable":0},{"_id":"source/_posts/0005-nestjs-pact/provider-class-diagram.png","post":"cm9tztuvz001cfqgxgtnqe0qv","slug":"provider-class-diagram.png","modified":1,"renderable":0},{"_id":"source/_posts/0005-nestjs-pact/provider-test-result.png","post":"cm9tztuvz001cfqgxgtnqe0qv","slug":"provider-test-result.png","modified":1,"renderable":0},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-broker-ui-matrix-all-result1.png","post":"cm9tztuw0001dfqgx9m5t90wg","slug":"pact-broker-ui-matrix-all-result1.png","modified":1,"renderable":0},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-broker-ui-matrix-all-result2.png","post":"cm9tztuw0001dfqgx9m5t90wg","slug":"pact-broker-ui-matrix-all-result2.png","modified":1,"renderable":0},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-broker-ui-matrix-entry.png","post":"cm9tztuw0001dfqgx9m5t90wg","slug":"pact-broker-ui-matrix-entry.png","modified":1,"renderable":0},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-broker-ui-matrix.png","post":"cm9tztuw0001dfqgx9m5t90wg","slug":"pact-broker-ui-matrix.png","modified":1,"renderable":0},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-broker-ui.png","post":"cm9tztuw0001dfqgx9m5t90wg","slug":"pact-broker-ui.png","modified":1,"renderable":0},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-cli-help.png","post":"cm9tztuw0001dfqgx9m5t90wg","slug":"pact-cli-help.png","modified":1,"renderable":0},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-cli-publish-result.png","post":"cm9tztuw0001dfqgx9m5t90wg","slug":"pact-cli-publish-result.png","modified":1,"renderable":0},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-cli-publish.png","post":"cm9tztuw0001dfqgx9m5t90wg","slug":"pact-cli-publish.png","modified":1,"renderable":0},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-verification-result1.png","post":"cm9tztuw0001dfqgx9m5t90wg","slug":"pact-verification-result1.png","modified":1,"renderable":0},{"_id":"source/_posts/0006-nestjs-pact-broker/pact-verification-result2.png","post":"cm9tztuw0001dfqgx9m5t90wg","slug":"pact-verification-result2.png","modified":1,"renderable":0}],"PostCategory":[{"post_id":"cm9tztuvp0009fqgx1gi5f55b","category_id":"cm9tztuvn0007fqgx7lfvgylc","_id":"cm9tztuvv000mfqgx046tb9va"},{"post_id":"cm9tztuvp0009fqgx1gi5f55b","category_id":"cm9tztuvt000gfqgx5bu87vsr","_id":"cm9tztuvv000ofqgx3fqwa4jz"},{"post_id":"cm9tztuvj0003fqgx1oan4apl","category_id":"cm9tztuvq000bfqgxgi510df9","_id":"cm9tztuvw000vfqgx7pveb4xv"},{"post_id":"cm9tztuvj0003fqgx1oan4apl","category_id":"cm9tztuvu000kfqgx5ur81yen","_id":"cm9tztuvw000wfqgxhuj723z7"},{"post_id":"cm9tztuvn0006fqgxdrg05uhh","category_id":"cm9tztuvn0007fqgx7lfvgylc","_id":"cm9tztuvx000yfqgx7vgcglgy"},{"post_id":"cm9tztuvn0006fqgxdrg05uhh","category_id":"cm9tztuvv000qfqgxc2g8de9c","_id":"cm9tztuvx0010fqgxei13cqid"},{"post_id":"cm9tztuvf0001fqgxgz64g437","category_id":"cm9tztuvn0007fqgx7lfvgylc","_id":"cm9tztuvx0013fqgx9rn4hgnm"},{"post_id":"cm9tztuvf0001fqgxgz64g437","category_id":"cm9tztuvt000gfqgx5bu87vsr","_id":"cm9tztuvx0015fqgxfay8b6kk"},{"post_id":"cm9tztuvf0001fqgxgz64g437","category_id":"cm9tztuvw000tfqgx86dg3x6e","_id":"cm9tztuvy0017fqgx1er5adoq"},{"post_id":"cm9tztuvz001cfqgxgtnqe0qv","category_id":"cm9tztuvn0007fqgx7lfvgylc","_id":"cm9tztuw2001kfqgxh4tz4272"},{"post_id":"cm9tztuvz001cfqgxgtnqe0qv","category_id":"cm9tztuvt000gfqgx5bu87vsr","_id":"cm9tztuw2001nfqgxfmg4gv8f"},{"post_id":"cm9tztuvz001cfqgxgtnqe0qv","category_id":"cm9tztuw1001ffqgxgxxi3wrs","_id":"cm9tztuw2001pfqgx1odw8k7d"},{"post_id":"cm9tztuw0001dfqgx9m5t90wg","category_id":"cm9tztuvn0007fqgx7lfvgylc","_id":"cm9tztuw3001sfqgx2gju23d9"},{"post_id":"cm9tztuw0001dfqgx9m5t90wg","category_id":"cm9tztuvt000gfqgx5bu87vsr","_id":"cm9tztuw3001tfqgxdotohzhk"},{"post_id":"cm9tztuw0001dfqgx9m5t90wg","category_id":"cm9tztuw1001ffqgxgxxi3wrs","_id":"cm9tztuw3001ufqgx7un9g10e"}],"PostTag":[{"post_id":"cm9tztuvf0001fqgxgz64g437","tag_id":"cm9tztuvl0004fqgx26zu8n3c","_id":"cm9tztuvt000efqgxedck0rqt"},{"post_id":"cm9tztuvf0001fqgxgz64g437","tag_id":"cm9tztuvq000afqgx4ee3cak1","_id":"cm9tztuvt000ffqgxe1tl47vm"},{"post_id":"cm9tztuvj0003fqgx1oan4apl","tag_id":"cm9tztuvr000cfqgx396pcopd","_id":"cm9tztuvv000nfqgxfbslcl49"},{"post_id":"cm9tztuvj0003fqgx1oan4apl","tag_id":"cm9tztuvt000hfqgxgql51iw7","_id":"cm9tztuvv000pfqgx1eqv2c0c"},{"post_id":"cm9tztuvj0003fqgx1oan4apl","tag_id":"cm9tztuvu000jfqgx6rz80g4p","_id":"cm9tztuvw000sfqgxf1vz6hkf"},{"post_id":"cm9tztuvn0006fqgxdrg05uhh","tag_id":"cm9tztuvl0004fqgx26zu8n3c","_id":"cm9tztuvx000zfqgxezw65w20"},{"post_id":"cm9tztuvn0006fqgxdrg05uhh","tag_id":"cm9tztuvv000rfqgxc6s3gzwr","_id":"cm9tztuvx0011fqgx96jqh2u4"},{"post_id":"cm9tztuvn0006fqgxdrg05uhh","tag_id":"cm9tztuvw000ufqgx216284us","_id":"cm9tztuvx0014fqgx40xgflsd"},{"post_id":"cm9tztuvp0009fqgx1gi5f55b","tag_id":"cm9tztuvl0004fqgx26zu8n3c","_id":"cm9tztuvy0018fqgxazpw9mm2"},{"post_id":"cm9tztuvp0009fqgx1gi5f55b","tag_id":"cm9tztuvq000afqgx4ee3cak1","_id":"cm9tztuvy0019fqgxd9d93j99"},{"post_id":"cm9tztuvp0009fqgx1gi5f55b","tag_id":"cm9tztuvx0012fqgxdtgm9m4t","_id":"cm9tztuvy001afqgx2m9yhvjo"},{"post_id":"cm9tztuvp0009fqgx1gi5f55b","tag_id":"cm9tztuvx0016fqgxdpad9b4j","_id":"cm9tztuvy001bfqgx6licbm60"},{"post_id":"cm9tztuvz001cfqgxgtnqe0qv","tag_id":"cm9tztuvl0004fqgx26zu8n3c","_id":"cm9tztuw2001jfqgxcfanfbcs"},{"post_id":"cm9tztuvz001cfqgxgtnqe0qv","tag_id":"cm9tztuvq000afqgx4ee3cak1","_id":"cm9tztuw2001lfqgxdvi62ts2"},{"post_id":"cm9tztuvz001cfqgxgtnqe0qv","tag_id":"cm9tztuw0001efqgx4j4jgrwd","_id":"cm9tztuw2001ofqgxefsmf4d2"},{"post_id":"cm9tztuvz001cfqgxgtnqe0qv","tag_id":"cm9tztuw1001gfqgxagbm7jwa","_id":"cm9tztuw2001qfqgxgtj49xi4"},{"post_id":"cm9tztuw0001dfqgx9m5t90wg","tag_id":"cm9tztuvl0004fqgx26zu8n3c","_id":"cm9tztuw3001vfqgx6agk2335"},{"post_id":"cm9tztuw0001dfqgx9m5t90wg","tag_id":"cm9tztuvq000afqgx4ee3cak1","_id":"cm9tztuw3001wfqgxc9tpft7t"},{"post_id":"cm9tztuw0001dfqgx9m5t90wg","tag_id":"cm9tztuw0001efqgx4j4jgrwd","_id":"cm9tztuw3001xfqgx6v3w05qe"},{"post_id":"cm9tztuw0001dfqgx9m5t90wg","tag_id":"cm9tztuw1001gfqgxagbm7jwa","_id":"cm9tztuw3001yfqgx5vgb3kg6"},{"post_id":"cm9tztuw0001dfqgx9m5t90wg","tag_id":"cm9tztuw2001rfqgx8gt42orf","_id":"cm9tztuw3001zfqgxfkid9r7p"}],"Tag":[{"name":"Backend","_id":"cm9tztuvl0004fqgx26zu8n3c"},{"name":"NestJS","_id":"cm9tztuvq000afqgx4ee3cak1"},{"name":"Frontend","_id":"cm9tztuvr000cfqgx396pcopd"},{"name":"Angular","_id":"cm9tztuvt000hfqgxgql51iw7"},{"name":"Web Component","_id":"cm9tztuvu000jfqgx6rz80g4p"},{"name":"APIGateway","_id":"cm9tztuvv000rfqgxc6s3gzwr"},{"name":"KrakenD","_id":"cm9tztuvw000ufqgx216284us"},{"name":"Cache","_id":"cm9tztuvx0012fqgxdtgm9m4t"},{"name":"Valkey","_id":"cm9tztuvx0016fqgxdpad9b4j"},{"name":"Contract Testing","_id":"cm9tztuw0001efqgx4j4jgrwd"},{"name":"Pact","_id":"cm9tztuw1001gfqgxagbm7jwa"},{"name":"Pact Broker","_id":"cm9tztuw2001rfqgx8gt42orf"}]}}